---
layout: post
title:  "인덱스(index)를 이용하여 데이터베이스의 검색 속도 높이기" 
excerpt: "인덱스는 데이터베이스 테이블에서 검색 속도를 높이기 위해 사용되는 자료구조이다. 인덱스하고자 하는 데이터를 별도의 공간에 정렬해두고, 빠르게 해당 데이터의 물리적 주소에 접근하여 조회 성능을 높일 수 있다. 다만 테이블의 크기가 크거나 빈번한 데이터 변경이 발생하는 테이블에는 권장하지 않을 수도 있다. 기본적으로 PK에 많이 적용되며, B-Tree와 관련된 자료구조가 주로 사용된다."
date:   2022-11-15 15:00:00 +0900
categories: swe
tags: [database]
---

<br>

## 인덱스(Index)란?

인덱스는 데이터베이스 테이블에서 검색 속도를 높이기 위해 사용되는 자료구조이다. 

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcQi8RP%2Fbtq8BkRrRfb%2Fa5C0jH5pfSA2KKz7C9fB7k%2Fimg.png)  
*@그림 1 : 데이터베이스에서 인덱스를 생성했을 경우의 예시 - 코딩팩토리*

위의 그림처럼 특정 컬럼에 대한 인덱스를 생성하면 아래의 두 단계가 진행된다.
1. 해당 컬럼의 데이터를 정렬한다.
2. 별도의 메모리 공간에 데이터와 해당 데이터의 물리적 주소가 저장된다.

인덱스를 생성한 컬럼을 조회하면, 그림의 가운데에 위치한 옵티마이저(Optimizer)에서 마치 책에서 목차를 보고 해당 페이지로 바로 이동하는 것과 같이 해당 인덱스에 대한 물리적 주소를 반환하여 바로 해당 값을 조회하도록 한다. 

<br>

## 인덱스를 사용하는 이유

### 1. 빠른 조회 속도

인덱스는 기본적으로 테이블 내에 있는 데이터를 정렬하여 저장한다. 테이블 내부에 데이터가 쌓이면 테이블의 레코드가 정렬되지 않은 상태로 계속 저장되고, 추후 WHERE을 사용하게 되면 데이터를 처음부터 끝까지 모두 읽어서(Full Table Scan) 검색 조건과 맞는지 확인해야 하는 경우가 생긴다. 하지만 인덱스는 테이블 내의 데이터를 정렬하여 저장하고 있기 때문에, 해당 조건에 맞는 데이터를 빠르게 조회할 수 있다.

> 여기서 데이터를 정렬하여 저장한다고 하는 문구에 주목하자. 위의 그림1에서 볼 수 있는 것처럼, 인덱스는 기존에 존재하는 테이블에 추가적인 옵션으로 제공되는 것이 아니라 별도의 자료 구조 테이블을 만드는 것이라고 이해하는 것이 좋다. 그리고 이러한 특징은 추후 다루게 될 인덱스의 단점에도 이유를 제공한다.

### 2. 별도의 작업 없이도 정렬된 데이터

위에서 다룬 장점에 이어, 인덱스 자료구조 내에 이미 정렬된 데이터들이 존재하기 때문에 별도의 ORDER BY에 의한 정렬 작업을 진행하지 않아도 된다. 

ORDER BY 정렬과정의 내부를 살펴보면, 생각했던 것 보다 복잡한 단계를 거친다.
1. ORDER BY가 실행되면, 메모리에서 데이터에 대한 정렬이 진행된다.
2. 만약 메모리보다 데이터가 많을 경우, 데이터베이스로의 디스크 I/O가 추가적으로 발생한다.

하지만 인덱스를 사용하면, 인덱스 자료구조에 해당 데이터가 추가되면서 매 순간 정렬하기 때문에 추가적인 자원 소모가 발생하지 않게 된다. 즉 전반적인 시스템의 부하가 줄어들 수 있다.

### 3. MIN, MAX, COUNT

데이터가 정렬되어 있기 때문에, 데이터의 최소, 최대 혹은 전체 개수를 조회하는 작업에 매우 용이하다. 

<br>

## 그렇다면 항상 인덱스는 좋은 방법일까?

인덱스가 데이터 변경이 발생할때마다 매 순간 내부를 정렬한다는 것은 장점이자 단점이기도 하다. 특히 데이터의 추가/삭제가 빈번하게 발생하는 테이블의 경우에는 이를 정렬하는 것이 꽤 많은 자원소모를 발생시킬 수 있다. 

또한 인덱스가 존재하는 것과 별개로, 기존에 존재하는 데이터베이스 테이블 또한 데이터 추가/삭제에 따른 변경이 함께 이루어져야 하기 때문에 이에 대한 성능 저하도 발생할 수 있다. 만약 데이터베이스 테이블 내에 존재하는 데이터 중 과반수 이상의 데이터를 인덱스한다고 하면, 배보다 배꼽이 더 큰 상황이 발생할 수도 있다.

```
인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 계속 수행된다면 위에서 설명한대로 계속된 정렬에 따른 부하가 발생하게 된다.
이를 방지하기 위해, 인덱스에서는 DELETE의 경우에도 데이터 삭제가 아닌 "인덱스 미사용"으로 대신 처리하고 있다.

- INSERT : 새로운 데이터에 대한 인덱스 추가
- UPDATE : 기존에 인덱스를 미사용 처리하고, 새로운 데이터에 대한 인덱스 추가
- DELETE : 삭제하려는 데이터의 인덱스를 미사용 처리
```

<br>

## 인덱스를 사용하면 좋은 경우는?

테이블 내에서 데이터가 최대한 많이 분포되어 있고, 조건절에 자주 호출되어 사용되는 컬럼을 인덱스 하는 것이 가장 좋은 방법이다. 그렇기 때문에 가장 많이 사용되는 방법은 PK(Primary Key)를 인덱스하는 것이다. 만약 동일한 값을 여러 데이터에서 사용하는 컬럼을 인덱스 한다면, 불필요한 자원 낭비만 발생할 것이다.

정리하면,
1. 테이블의 규모가 작은 경우 (이 중 테이블의 10~15%의 데이터를 인덱스하여 처리하는 것을 권장)
2. INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
3. JOIN, WHERE, ORDER BY 등에 자주 사용되는 컬럼
4. 중복되는 데이터가 적은, 분포도가 좋은 컬럼

<br>

## 자료구조 : B-Tree

인덱스에는 여러 종류가 있는데, 큰 범주로는 해시테이블을 이용하거나 B-Tree를 이용하고 있다. 해시테이블의 경우에는 {Key, Value} 구조를 이용하여 시간복잡도를 O(1)으로 만들어 빠르게 데이터를 검색할 수 있다는 장점이 있지만, 부등호 연산을 다양하게 사용해야 하는 데이터베이스 검색에 적합하지 않다는 단점이 있다.

> 참고로 해시테이블은 '=' 등호 연산에 특화되어 있으며, '<' '>'와 같은 연산을 사용하는 데이터베이스 검색의 경우 사용하기 어렵다. 예를 들어 "서울"이라는 단어로 시작하는 모든 데이터를 검색하고자 할 때, 인덱스의 혜택을 받기 어렵게 된다.

B-Tree에는 B*Tree와 B+Tree 두 종류가 존재한다.

### 1. B*Tree

B*Tree는 대부분의 DBMS, 특히 오라클에서 사용하고 있는 인덱스 자료구조이다. 

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbdRpkm%2Fbtq8NcRX3gF%2FbCvX7rupbpi1UVMCjkoTAk%2Fimg.png)  
*@그림 2 : B*Tree 자료구조 - 코딩팩토리*

위의 그림과 같이 Root, Branch, Leaf 노드로 구성되며, 특정 컬럼을 인덱스에 추가하면 아래와 같은 순서로 데이터가 저장된다.
1. 컬럼의 값들을 정렬한다.
2. 정렬 순서의 중간쯤 되는 데이터를 ROOT 블록으로 지정한다.
3. Root 블록을 기준으로 가지 형태의 Branch 블록들을 정의한다.
4. 마지막 Leaf 블록에 인덱스의 키가 되는 데이터와 데이터의 물리 주소(ROWID)를 저장한다.

### 2. B+Tree

B+Tree는 자식 노드가 2개인 B-Tree를 개선시킨 구조로, 모든 노드에 데이터를 저장하는 BTree와 다르게 Leaf 노드에만 인덱스와 데이터를 갖는다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fd78iJ0%2FbtqKRYbLdM9%2FnIvz1M4gffMl4YHS77JSfK%2Fimg.png)  
*@그림 3 : InnoDB에서 사용하는 B+Tree 자료구조 - 망나니개발자*

위의 그림처럼 Leaf 노드를 제외한 나머지 노드들은 데이터를 위한 인덱스만을 갖는다. 모든 Leaf 노드는 LinkedList로 연결되어 있으며, 데이터 노드와 인덱스 노드 간 크기는 항상 동일하지 않아도 된다. 

위에서 언급했던 것 처럼, 인덱스는 기본적으로 부등호를 이용한 순차 검색 연산이 자주 발생한다. 그렇기 때문에 BTree의 리프 노드들을 LinkedList로 연결함으로써, 전체 노드를 순차적으로 검색하기 용이하도록 하였다.

<br>

## 참고자료

- [데이터베이스 인덱스(Index)란 무엇인가? - 코딩팩토리](https://coding-factory.tistory.com/746)
- [인덱스(index)란? - 망나니개발자](https://mangkyu.tistory.com/96)