---
layout: post
title:  "Go 에러 처리, 언제 fmt.Errorf를 쓰고 언제 쓰지 말아야 할까?"
description: "많은 go 개발자가 흔히 저지르는 실수가 있습니다. 바로 모든 에러를 무분별하게 fmt.Errorf로 감싸는 것입니다. 이 글에서는 왜 그것이 '안티 패턴'이 될 수 있는지, 그리고 어떻게 하면 더 견고하고 우아하게 에러를 처리할 수 있는지 실제 코드를 통해 알아봅니다."
categories: dev
# tags: [ethereum, solidity, smartcontract]
keywords: go, error, fmt.Errorf, error handling, error wrapping
comments: true
---

## 요약

1. 모든 에러를 무조건 `fmt.Errorf`로 감싸는 것은 좋지 않습니다.
2. 에러를 처리하는 라이브러리와의 '약속'을 이해하고, 원본 에러를 보존해야 할 때와 컨텍스트를 추가해야 할 때를 구분해야 합니다.
3. 함수의 역할을 명확히 나누고, 각 계층에 맞는 책임만 부여하는 것이 견고한 설계 과정에 필요합니다.

## fmt.Errorf를 우아하게 사용하는 방법

모든 서버 개발자는 외부 API 호출과 같은 불안정한 작업을 다뤄야 합니다. 일시적인 네트워크 오류는 언제든 발생할 수 있고, 가장 기본적인 해결책은 '재시도'입니다. Go에서는 `cenk/backoff` 같은 훌륭한 라이브러리를 사용해 재시도 로직을 쉽게 구현할 수 있죠.

하지만 재시도 로직을 구현할 때, 많은 개발자가 흔히 저지르는 실수가 있습니다. 바로 모든 에러를 무분별하게 `fmt.Errorf`로 감싸는 것입니다. 이 글에서는 왜 그것이 '안티 패턴'이 될 수 있는지, 그리고 어떻게 하면 더 견고하고 우아하게 에러를 처리할 수 있는지 실제 코드를 통해 알아보겠습니다.

```go
func doRetry(ctx context.Context, c *Client, req *http.Request) ([]byte, int, error) {
    // ...
	if err := backoff.Retry(func() error {
		var err error
		bs, st, err = do(ctx, c, req)
		return err // <-- 왜 여기서는 fmt.Errorf를 쓰지 않을까?
	}, ...); err != nil {
        // <-- 왜 여기서는 fmt.Errorf를 사용할까?
		return nil, 0, fmt.Errorf("failed after retries %w", err)
	}
	return bs, st, nil
}
```

### 1. 역할을 분리하자: '실무자'와 '매니저'

훌륭한 에러 처리의 첫걸음은 함수의 역할을 명확하게 나누는 것입니다. 위 코드에는 두 명의 핵심 플레이어가 등장합니다.

- 실무자 (`do` 함수): 이 함수는 단 하나의 임무, 즉 HTTP 요청을 딱 한 번 보내고 그 결과를 가공하지 않고 정직하게 보고하는 역할을 합니다. 성공했는지, 실패했는지, 실패했다면 원인이 무엇인지(원본 에러)를 그대로 반환합니다.
- 매니저 (`doRetry` 함수): 실무자에게 일을 시키고, 그 보고를 받아 정책적인 결정을 내립니다. "보고 내용이 '일시적인 오류'라면 재시도를 시키고, '영구적인 오류'라면 즉시 중단하자. 모든 재시도가 실패하면, 그때 최종 실패 보고를 올리자" 와 같은 결정을 합니다.

### 2. 비서에게 원본을 그대로 전달하자.

`backoff.Retry` 라이브러리는 매니저의 비서와 같습니다. 이 비서는 실무자가 제출한 보고서(원본 error)를 보고 재시도 여부를 결정합니다. 만약 보고서에 `backoff.PermanentError` 라는 도장이 찍혀 있다면, "아, 이건 재시도해도 소용없는 일이군요"라며 즉시 작업을 중단시킵니다.

만약 실무자가 보고하는 과정에서 원본 에러를 `fmt.Errorf("do failed: %w", err)`와 같이 자신만의 봉투에 담아 버리면 어떻게 될까요? 비서는 봉투 겉면만 볼 수 있을 뿐, 그 안에 담긴 중요한 'PermanentError' 도장을 보지 못하게 됩니다. 결국 재시도하면 안 되는 일에 불필요한 노력을 쏟는 셈이죠. 

이것이 바로 `backoff.Retry`에 전달하는 함수 안에서 `return err`를 통해 원본 에러를 그대로 반환해야 하는 이유입니다. 라이브러리와의 약속(Contract)을 지키는 것입니다.

### 3. 매니저가 최종적으로 확인한 내용에 대해 컨텍스트 추가하자.

그렇다면 에러에 "재시도 끝에 실패했다"와 같은 구체적인 맥락을 추가하는 작업은 언제 해야 할까요?

바로 매니저가 모든 정책적인 판단을 끝낸 시점입니다. `doRetry` 함수는 `backoff.Retry`가 가능한 모든 재시도 끝에 최종 적으로 실패를 알렸을 때, 비로소 `fmt.Errorf("failed after retries %w", err)`를 통해 더욱 자세한 컨텍스트를 담은 최종 에러를 생성하여 상위 호출자에게 반환합니다.

에러가 발생한 가장 낮은 수준(`do` 함수)에서는 원본을 유지하고, 계층을 따라 올라오며 각 계층의 역할에 맞는 컨텍스트를 추가하는 것이 중요합니다. 이것이 바로 Go가 추구하는 에러 처리의 핵심 철학입니다.

### 4. `defer`를 사용할 때에는 더욱 주의하자.

`do` 함수를 자세히 보면 한 가지 더 재미있는 패턴을 발견할 수 있습니다.

```go
func do(...) (bs []byte, st int, err error) { // <-- 명명된 반환 값(err)
    // ...
    resp, err = c.HttpClient.Do(...)
    // ...
    defer func() {
        if closeErr := resp.Body.Close(); err == nil {
            err = closeErr // <-- 반환될 err 변수에 직접 할당
        }
    }()
    // ...
    return // return 뒤에 변수가 없음
}
```

`resp.Body.Close()`와 같이 최종적으로 사용된 리소스를 정리하는 과정에서도 에러는 발생할 수 있습니다. '명명된 반환 값(err)'과 defer를 함께 사용하면, 함수 본문이 성공적으로 실행되었더라도 마지막 정리 과정에서 발생한 에러까지 놓치지 않고 안전하게 최종 반환 값에 포함시킬 수 있습니다. 이것은 매우 실용적이고 견고한 Go의 표준 패턴(idiomatic Go)입니다.

#### "왜 err가 nil일 때만 closeErr를 할당하는가?"

그 이유는 **더 중요한 원인 에러를 덮어쓰지 않기 위해서**입니다. `defer` 함수가 실행되는 시점은 `do` 함수가 거의 모든 임무를 마치고 반환하기 직전입니다. 

이때 두 가지 시나리오가 있을 수 있습니다.

**시나리오 1: 모든 것이 순조롭게 진행되었을 때**

1. `HttpClient.Do`가 성공하고, `io.ReadAll`도 성공적으로 응답을 다 읽었습니다. 아무런 문제가 없었다면, 이때까지 `err` 변수는 계속 nil입니다.
2. 함수가 종료되기 전 `defer`가 실행됩니다.
3. `resp.Body.Close()`를 호출해서 뒷정리를 하는데, 이때 갑자기 에러(`closeErr`)가 발생합니다.
4. `if err == nil` 조건을 확인하면, 이전에 발생했던 에러가 없기 때문에 true가 됩니다. 즉 `err == nil`을 만족하기 때문에, `err = closeErr`가 실행됩니다.
5. 그 결과 `do` 함수는 이 뒷정리 과정에서 발생한 `closeErr`를 최종 에러로 반환합니다.

**시나리오 2: 중간에 이미 문제가 발생했을 때 (더 중요!)**

1. `Http1Client.Do`는 성공했지만, `io.ReadAll`이 응답을 읽는 도중 네트워크 연결이 끊겨 에러가 발생했습니다. 이 시점에서 `err` 변수에는 "네트워크 연결 끊김" 이라는 매우 중요한 원인 에러가 이미 할당되어 있습니다.
2. 함수가 종료되기 전 `defer`가 실행됩니다.
3. `resp.Body.Close()`를 호출합니다. 이미 오류(연결이 끊김)가 발생했으니 추가적인 에러(`closeErr`)가 발생할 수도 있습니다.
4. `if err == nil` 조건을 확인하면, 이전에 발생한 에러(네트워크 끊김)가 있기 때문에 false가 됩니다. 즉 `err == nil`을 만족하지 않기 때문에, `err = closeErr`가 실행되지 않습니다.
5. 그 결과 `do` 함수는 원래 발생했던 **더 중요한 원인 에러("네트워크 연결 끊김")**를 그대로 가지고 반환됩니다.

만약 `if err == nil` 조건이 없다면 어떻게 될까요? 덜 중요한 `closeErr`가 더 중요한 원인 에러를 덮어쓰게 되고, 우리는 진짜 문제가 무엇이었는지 알 수 없게 됩니다.

Go에서는 **"함수가 실패했다면, 그 최초의 원인을 보존하라"** 는 에러 처리 철학을 가지고 있으며, 위의 예시는 그에 대한 패턴을 잘 보여주고 있습니다.
