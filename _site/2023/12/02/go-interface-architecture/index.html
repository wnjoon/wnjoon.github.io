<!DOCTYPE html>
<html lang="ko"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Importance of using interface while construct program and example of using go | blog.wonjoon</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Importance of using interface while construct program and example of using go" />
<meta name="author" content="wonjoon" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="By designing software around interfaces, we minimize dependencies, improve collaboration, and build scalable, maintainable systems." />
<meta property="og:description" content="By designing software around interfaces, we minimize dependencies, improve collaboration, and build scalable, maintainable systems." />
<link rel="canonical" href="http://localhost:4000/2023/12/02/go-interface-architecture/" />
<meta property="og:url" content="http://localhost:4000/2023/12/02/go-interface-architecture/" />
<meta property="og:site_name" content="blog.wonjoon" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-12-02T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Importance of using interface while construct program and example of using go" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"wonjoon"},"dateModified":"2023-12-02T00:00:00+09:00","datePublished":"2023-12-02T00:00:00+09:00","description":"By designing software around interfaces, we minimize dependencies, improve collaboration, and build scalable, maintainable systems.","headline":"Importance of using interface while construct program and example of using go","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/12/02/go-interface-architecture/"},"url":"http://localhost:4000/2023/12/02/go-interface-architecture/"}</script>
<!-- End Jekyll SEO tag -->

  <meta name="theme-color" content="#eeeeee">
  <meta name="font-color" content="#222222">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="apple-touch-icon" href="/logo.png">
  <link rel="icon" type="image/png" href="/logo.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/logo.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/logo.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/logo.png" sizes="16x16">
  
  
    <link rel="alternate" type="application/atom+xml" title="blog.wonjoon" href="http://localhost:4000/feed.xml" />
  
</head><body a="white">
    <div style="position: fixed; top: 1rem; right: 1.5rem; z-index: 100;">
      <button id="theme-toggle" style="background: none; border: none; cursor: pointer; padding: 0; color: black;"></button>
    </div>
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/"><-home</a><article>
  <p class="post-meta">
    <time datetime="2023-12-02 00:00:00 +0900">2023-12-02</time>
  </p>
  
  <h1>Importance of using interface while construct program and example of using go</h1>

  <h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#why-should-we-design-applications-based-on-interfaces">Why Should We Design Applications Based on Interfaces?</a></li>
  <li><a href="#how-interface-based-design-improves-the-development-process">How Interface-Based Design Improves the Development Process</a></li>
  <li><a href="#challenges-of-interface-based-design">Challenges of Interface-Based Design</a></li>
  <li><a href="#how-go-supports-interface-based-design">How Go Supports Interface-Based Design</a></li>
  <li><a href="#example-designing-an-ethereum-transaction-sender-interface">Example: Designing an Ethereum Transaction Sender Interface</a></li>
  <li><a href="#advantages-of-interface-based-design">Advantages of Interface-Based Design</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="why-should-we-design-applications-based-on-interfaces">Why Should We Design Applications Based on Interfaces?</h2>

<p>Modern software applications are composed of multiple modules that interact with each other. To ensure scalability, maintainability, and flexibility, interface-based design is widely recommended.</p>

<p>Let’s take Netflix as an example. Netflix is not just a video streaming service; it includes user management, subscription payments, recommendations, advertising, and many other services. Each team within Netflix works on different components, often following their own schedules and priorities. Without a well-defined interface-based approach, collaboration and integration would become extremely complex.</p>

<p>The best way to address this challenge is to design and develop applications based on interfaces.</p>

<h2 id="how-interface-based-design-improves-the-development-process">How Interface-Based Design Improves the Development Process</h2>

<p>Let’s assume we’re developing an app that enables users to purchase subscriptions.</p>

<p>Scenario</p>

<ol>
  <li>Team A is responsible for user management, and Team B is developing the payment system.</li>
  <li>Team A needs to implement subscription purchases, which depend on Team B’s payment gateway (PG) integration.</li>
  <li>Team B is busy with other tasks and cannot immediately implement the PG integration. However, Team A cannot wait indefinitely for them to complete it.</li>
  <li>Team B provides an interface that defines the PG integration structure. Even though the actual implementation is not ready, the interface specifies what the final implementation will look like.</li>
  <li>Team A develops a mock implementation based on the provided interface and proceeds with subscription feature development.</li>
  <li>Once Team B completes the real PG integration, Team A replaces the mock implementation with the actual implementation.</li>
</ol>

<p>By adopting interface-based design, modules remain decoupled and can be developed independently without waiting for other teams.</p>

<h2 id="challenges-of-interface-based-design">Challenges of Interface-Based Design</h2>

<p>Despite its benefits, interface-based design is challenging when business logic is not well-defined.</p>

<ul>
  <li>Business requirements must be well-analyzed before development to determine what interfaces will be needed.</li>
  <li>Some Agile methodologies misinterpret speed as skipping planning. Fast development should not mean skipping clear business requirements and interface design.</li>
  <li>If Team A starts development without a clear understanding of what Team B will deliver, frequent changes to the interface can result in wasted effort.</li>
  <li>A well-defined interface can reduce development time, not increase it.</li>
</ul>

<p>To prevent unnecessary changes, a clear interface design should be agreed upon before development begins.</p>

<h2 id="how-go-supports-interface-based-design">How Go Supports Interface-Based Design</h2>

<p>Go encourages interface-based design and provides a simple yet powerful way to implement it.</p>

<p>Key Differences from Java and Other Languages</p>

<ul>
  <li>No need for explicit interface declarations in implementing structs.</li>
  <li>No separate interface files are required.</li>
  <li>If a struct implements all the methods of an interface, it automatically satisfies that interface.</li>
</ul>

<h3 id="best-practices-for-defining-interfaces-in-go">Best Practices for Defining Interfaces in Go</h3>

<ul>
  <li>Use meaningful names ending in -er to describe the action performed.</li>
  <li>Example:
    <ul>
      <li>Printer: Prints output</li>
      <li>Writer: Writes to a file</li>
    </ul>
  </li>
</ul>

<h2 id="example-designing-an-ethereum-transaction-sender-interface">Example: Designing an Ethereum Transaction Sender Interface</h2>

<p>Let’s define an interface for sending signed Ethereum transactions.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Sender</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">SendTransaction</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">from</span> <span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">to</span> <span class="o">*</span><span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">value</span> <span class="o">*</span><span class="n">big</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="transaction-sending-approaches">Transaction Sending Approaches</h3>

<p>Ethereum transactions can be sent in two ways:</p>

<ul>
  <li>Synchronous (Sync): Waits until the transaction is mined before returning a response.</li>
  <li>Asynchronous (Async): Sends the transaction without waiting for confirmation.</li>
</ul>

<p>Since both approaches use the same parameters, we can define a single <code class="language-plaintext highlighter-rouge">Sender</code> interface.</p>

<h3 id="using-dependency-injection-for-flexibility">Using Dependency Injection for Flexibility</h3>

<p>We create a <code class="language-plaintext highlighter-rouge">TxManager</code> struct that depends on a <code class="language-plaintext highlighter-rouge">Sender</code> interface rather than a specific implementation.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">TxManager</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">sender</span> <span class="n">Sender</span>
<span class="p">}</span>

<span class="c">// Injects an implementation of Sender into TxManager</span>
<span class="k">func</span> <span class="n">NewTxManager</span><span class="p">(</span><span class="n">sender</span> <span class="n">Sender</span><span class="p">)</span> <span class="o">*</span><span class="n">TxManager</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">TxManager</span><span class="p">{</span>
        <span class="n">sender</span><span class="o">:</span> <span class="n">sender</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="different-implementations-of-the-sender-interface">Different Implementations of the Sender Interface</h3>

<p>We now create two different implementations:</p>

<ul>
  <li>SyncSender: Implements synchronous transactions.</li>
  <li>AsyncSender: Implements asynchronous transactions.</li>
  <li>Both implementations satisfy the <code class="language-plaintext highlighter-rouge">Sender</code> interface because they define the required method.</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// SyncSender</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">SyncSender</span><span class="p">)</span> <span class="n">NewSyncSender</span><span class="p">()</span> <span class="o">*</span><span class="n">SyncSender</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">SyncSender</span><span class="p">)</span> <span class="n">SendTransaction</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">from</span> <span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">to</span> <span class="o">*</span><span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">value</span> <span class="o">*</span><span class="n">big</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>

<span class="c">// AsyncSender</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">AsyncSender</span><span class="p">)</span> <span class="n">NewAsyncSender</span><span class="p">()</span> <span class="o">*</span><span class="n">AsyncSender</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">AsyncSender</span><span class="p">)</span> <span class="n">SendTransaction</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">from</span> <span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">to</span> <span class="o">*</span><span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">value</span> <span class="o">*</span><span class="n">big</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></div></div>

<h3 id="injecting-the-implementations">Injecting the Implementations</h3>

<p>We can now inject either <code class="language-plaintext highlighter-rouge">SyncSender</code> or <code class="language-plaintext highlighter-rouge">AsyncSender</code> into the TxManager dynamically.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">syncSender</span> <span class="o">:=</span> <span class="n">NewSyncSender</span><span class="p">()</span>
    <span class="n">asyncSender</span> <span class="o">:=</span> <span class="n">NewAsyncSender</span><span class="p">()</span>

    <span class="c">// Use synchronous transaction processing</span>
    <span class="n">txm</span> <span class="o">:=</span> <span class="n">NewTxManager</span><span class="p">(</span><span class="n">syncSender</span><span class="p">)</span>

    <span class="c">// Use asynchronous transaction processing</span>
    <span class="n">txm</span> <span class="o">=</span> <span class="n">NewTxManager</span><span class="p">(</span><span class="n">asyncSender</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="advantages-of-interface-based-design">Advantages of Interface-Based Design</h2>

<h3 id="decouples-modules">Decouples Modules</h3>

<ul>
  <li>Teams can develop independently without waiting for other teams.</li>
  <li>Reduces dependencies between different components.</li>
</ul>

<h3 id="enables-dependency-injection">Enables Dependency Injection</h3>

<ul>
  <li>Implementations can be easily replaced or modified without changing business logic.</li>
  <li>Useful for mock testing and swapping different implementations.</li>
</ul>

<h3 id="enhances-maintainability--scalability">Enhances Maintainability &amp; Scalability</h3>

<ul>
  <li>Clear separation of concerns makes code easier to maintain.</li>
  <li>New features can be added without modifying existing components.</li>
</ul>

<h3 id="encourages-reusability">Encourages Reusability</h3>

<ul>
  <li>The same interface can have multiple implementations, making it reusable across different scenarios.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Why should we use interface-based design:</p>

<ul>
  <li>Modularization – Develop and maintain different parts of a system independently.</li>
  <li>Flexibility – Swap implementations without changing business logic.</li>
  <li>Scalability – Extend and modify software without breaking existing functionality.</li>
  <li>Testing – Use mock implementations for unit tests.</li>
</ul>

</article>
      </div>
    </main>
  <script type="text/javascript" src="/assets/js/theme_switch.js"></script>
  </body>
</html>