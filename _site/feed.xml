<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-03-17T07:42:26+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">//TODO: Write Blog</title><subtitle>A (nearly) no-CSS, fast, minimalist Jekyll theme.
</subtitle><author><name>Wonjoon</name></author><entry><title type="html">Using sync.Cond for Goroutine Synchronization in Go</title><link href="http://localhost:4000/2025/03/13/go-sync-cond/" rel="alternate" type="text/html" title="Using sync.Cond for Goroutine Synchronization in Go" /><published>2025-03-13T00:00:00+09:00</published><updated>2025-03-13T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/13/go-sync-cond</id><content type="html" xml:base="http://localhost:4000/2025/03/13/go-sync-cond/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#what-is-synccond">What is <code class="language-plaintext highlighter-rouge">sync.Cond</code>?</a></li>
  <li><a href="#how-synccond-works">How <code class="language-plaintext highlighter-rouge">sync.Cond</code> Works</a></li>
  <li><a href="#example-donation-goal-tracker-using-synccond">Example: Donation Goal Tracker Using <code class="language-plaintext highlighter-rouge">sync.Cond</code></a></li>
  <li><a href="#comparison-signal-vs-broadcast">Comparison: <code class="language-plaintext highlighter-rouge">Signal()</code> vs. <code class="language-plaintext highlighter-rouge">Broadcast()</code></a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="what-is-synccond">What is sync.Cond?</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> is a condition variable that helps synchronize multiple goroutines.</li>
  <li>It is typically used when one or more goroutines must wait until a shared resource reaches a specific state.</li>
  <li>One goroutine waits (<code class="language-plaintext highlighter-rouge">Wait()</code>) until a condition is satisfied, and another goroutine notifies (<code class="language-plaintext highlighter-rouge">Signal()</code> or <code class="language-plaintext highlighter-rouge">Broadcast()</code>) the waiting goroutines when the condition is met.</li>
</ul>

<h2 id="how-synccond-works">How sync.Cond Works</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Wait()</code></td>
      <td>Makes a goroutine wait until a condition is met (automatically unlocks the mutex)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Signal()</code></td>
      <td>Wakes only one waiting goroutine (even if multiple goroutines are waiting)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Broadcast()</code></td>
      <td>Wakes all waiting goroutines</td>
    </tr>
  </tbody>
</table>

<h2 id="example-donation-goal-tracker-using-synccond">Example: Donation Goal Tracker Using sync.Cond</h2>

<p>The following example demonstrates how <code class="language-plaintext highlighter-rouge">sync.Cond</code> can be used to coordinate multiple goroutines that monitor a donation goal.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Donation</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">cond</span>    <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span> <span class="c">// Condition variable</span>
    <span class="n">balance</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">donation</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Donation</span><span class="p">{</span>
        <span class="n">cond</span><span class="o">:</span> <span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{}),</span> <span class="c">// Create a condition variable with a mutex</span>
    <span class="p">}</span>

    <span class="c">// Listener goroutine (checks if goal is reached)</span>
    <span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">// Acquire mutex lock</span>
        <span class="k">for</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="n">goal</span> <span class="p">{</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait until balance &gt;= goal</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="p">)</span>
        <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">// Release mutex lock</span>
    <span class="p">}</span>

    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">15</span><span class="p">)</span>

    <span class="c">// Updater goroutine (increments balance)</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="o">++</span> <span class="c">// Increase balance</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span> <span class="c">// Wake all waiting goroutines</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">20</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Keep program running</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="step-1-creating-a-synccond-object">Step 1: Creating a sync.Cond Object</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Donation</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">cond</span>    <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span>  
    <span class="n">balance</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="n">donation</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Donation</span><span class="p">{</span>
    <span class="n">cond</span><span class="o">:</span> <span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{}),</span> 
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">cond</code>: A condition variable based on <code class="language-plaintext highlighter-rouge">sync.Mutex</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> provides synchronization between multiple goroutines using <code class="language-plaintext highlighter-rouge">Wait()</code>, <code class="language-plaintext highlighter-rouge">Signal()</code>, and <code class="language-plaintext highlighter-rouge">Broadcast()</code>.</li>
</ul>

<h3 id="step-2-listener-goroutine-fgoal-int">Step 2: Listener Goroutine (<code class="language-plaintext highlighter-rouge">f(goal int)</code>)</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>  
    <span class="k">for</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="n">goal</span> <span class="p">{</span>
        <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait until condition is met</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="p">)</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>How It Works:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">donation.cond.L.Lock()</code>: Acquires mutex lock before checking <code class="language-plaintext highlighter-rouge">donation.balance</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">for donation.balance &lt; goal</code>: Checks if goal is reached.</li>
  <li><code class="language-plaintext highlighter-rouge">donation.cond.Wait()</code>:
    <ul>
      <li>Pauses execution until another goroutine calls <code class="language-plaintext highlighter-rouge">Signal()</code> or <code class="language-plaintext highlighter-rouge">Broadcast()</code>.</li>
      <li>Automatically releases the mutex lock while waiting.</li>
    </ul>
  </li>
  <li>Once woken up, the goroutine resumes execution, prints the message, and releases the lock (<code class="language-plaintext highlighter-rouge">L.Unlock()</code>).</li>
</ol>

<h3 id="step-3-updater-goroutine">Step 3: Updater Goroutine</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">{</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="o">++</span>      
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>How It Works:</p>

<ol>
  <li>Acquires the lock (<code class="language-plaintext highlighter-rouge">donation.cond.L.Lock()</code>).</li>
  <li>Increments the balance every second (<code class="language-plaintext highlighter-rouge">donation.balance++</code>).</li>
  <li>Releases the lock (<code class="language-plaintext highlighter-rouge">donation.cond.L.Unlock()</code>).</li>
  <li>Calls <code class="language-plaintext highlighter-rouge">donation.cond.Broadcast()</code>:
    <ul>
      <li>Wakes up all waiting goroutines.</li>
      <li>Each waiting goroutine checks if its goal is met and either continues waiting or exits.</li>
    </ul>
  </li>
</ol>

<h3 id="overall-execution-flow">Overall Execution Flow</h3>

<table>
  <thead>
    <tr>
      <th><strong>Step</strong></th>
      <th><strong>Active Goroutine(s)</strong></th>
      <th><strong>Balance</strong></th>
      <th><strong>After Broadcast()</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>f(10), f(15) (waiting)</td>
      <td>0</td>
      <td>Still waiting</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Updater goroutine</td>
      <td>1 -&gt; 9</td>
      <td>Still waiting</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Updater goroutine</td>
      <td>10</td>
      <td>f(10) wakes up and exits</td>
    </tr>
    <tr>
      <td>4</td>
      <td>f(15) (still waiting)</td>
      <td>11 -&gt; 14</td>
      <td>Still waiting</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Updater goroutine</td>
      <td>15</td>
      <td>f(15) wakes up and exits</td>
    </tr>
  </tbody>
</table>

<p>Key Observations:</p>

<ul>
  <li>Each time balance increases, <code class="language-plaintext highlighter-rouge">Broadcast()</code> wakes all waiting goroutines.</li>
  <li>If a goroutine’s goal is not met, it goes back to <code class="language-plaintext highlighter-rouge">Wait()</code>.</li>
  <li>If a goroutine’s goal is met, it exits after printing the result.</li>
  <li>Once all goals are reached, no goroutines are waiting, so <code class="language-plaintext highlighter-rouge">Broadcast()</code> no longer has any effect.</li>
</ul>

<h2 id="comparison-signal-vs-broadcast">Comparison: Signal() vs. Broadcast()</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Behavior</strong></th>
      <th><strong>Use Case</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Wait()</code></td>
      <td>Makes a goroutine wait until a condition is met (automatically unlocks the mutex)</td>
      <td>Used when waiting for a condition</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Signal()</code></td>
      <td>Wakes only one waiting goroutine (even if multiple goroutines are waiting)</td>
      <td>Use when a single goroutine should proceed</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Broadcast()</code></td>
      <td>Wakes all waiting goroutines</td>
      <td>Use when all goroutines should be notified</td>
    </tr>
  </tbody>
</table>

<p>When to Use <code class="language-plaintext highlighter-rouge">Signal()</code> vs. <code class="language-plaintext highlighter-rouge">Broadcast()</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Signal()</code>: Use when only one goroutine needs to proceed.</li>
  <li><code class="language-plaintext highlighter-rouge">Broadcast()</code>: Use when all waiting goroutines should be notified (e.g., donation.balance updates).</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> helps synchronize multiple goroutines by allowing them to wait for a condition to be met.</li>
  <li><code class="language-plaintext highlighter-rouge">Wait()</code> makes goroutines wait, while <code class="language-plaintext highlighter-rouge">Signal()</code> and <code class="language-plaintext highlighter-rouge">Broadcast()</code> notify them.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">Broadcast()</code> when all waiting goroutines should proceed, and use <code class="language-plaintext highlighter-rouge">Signal()</code> when only one goroutine should continue.</li>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> is useful for implementing event-based synchronization, such as resource availability or state changes.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[In Go, sync.Cond is a synchronization primitive that allows goroutines to efficiently wait until a certain condition is met. It helps coordinate multiple goroutines by providing a mechanism to wait (Wait()) and notify (Signal() or Broadcast()) when conditions change.]]></summary></entry><entry><title type="html">Understanding GasKVStore in Cosmos SDK</title><link href="http://localhost:4000/2025/03/12/cosmos-sdk-gaskvstore/" rel="alternate" type="text/html" title="Understanding GasKVStore in Cosmos SDK" /><published>2025-03-12T00:00:00+09:00</published><updated>2025-03-12T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/12/cosmos-sdk-gaskvstore</id><content type="html" xml:base="http://localhost:4000/2025/03/12/cosmos-sdk-gaskvstore/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#overview-of-gaskvstore">Overview of GasKVStore</a></li>
  <li><a href="#core-methods-of-gaskvstore">Core Methods of GasKVStore</a></li>
  <li><a href="#gas-consumption-based-on-key-and-value-size">Gas Consumption Based on Key and Value Size</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="overview-of-gaskvstore">Overview of GasKVStore</h2>

<p>GasKVStore measures gas usage in real-time as internal field values change during transaction execution.
Each read, write, and delete operation is designed to consume gas, ensuring that gas limits are properly enforced.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Store applies gas tracking to an underlying KVStore. It implements the KVStore interface.</span>
<span class="k">type</span> <span class="n">Store</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">gasMeter</span>  <span class="n">types</span><span class="o">.</span><span class="n">GasMeter</span>   <span class="c">// GasMeter that tracks gas usage during transactions</span>
    <span class="n">gasConfig</span> <span class="n">types</span><span class="o">.</span><span class="n">GasConfig</span>  <span class="c">// Configuration for gas costs of read/write/delete operations</span>
    <span class="n">parent</span>    <span class="n">types</span><span class="o">.</span><span class="n">KVStore</span>    <span class="c">// The underlying KVStore that stores actual data</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="core-methods-of-gaskvstore">Core Methods of GasKVStore</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Functionality</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Get(key)</td>
      <td>Reads the value of a given key and consumes gas proportional to the key size</td>
    </tr>
    <tr>
      <td>Set(key, value)</td>
      <td>Stores a value for a given key and consumes gas based on both key and value size</td>
    </tr>
    <tr>
      <td>Delete(key)</td>
      <td>Deletes a key-value pair and consumes a fixed amount of gas</td>
    </tr>
  </tbody>
</table>

<h3 id="1-getkey---read-operation">1. Get(key) - Read Operation</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">GasKVStore</span><span class="p">)</span> <span class="n">Get</span><span class="p">(</span><span class="n">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="n">g</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">ConsumeGas</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">gasConfig</span><span class="o">.</span><span class="n">ReadCostPerByte</span> <span class="o">*</span> <span class="kt">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)),</span> <span class="s">"Read"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This function retrieves the value associated with a key.</li>
  <li>It is similar to searching for a word in a book.</li>
  <li>The function fetches and returns the data stored in the parent KVStore.</li>
</ul>

<h3 id="2-setkey-value---write-operation">2. Set(key, value) - Write Operation</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">GasKVStore</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gasToConsume</span> <span class="o">:=</span> <span class="n">g</span><span class="o">.</span><span class="n">gasConfig</span><span class="o">.</span><span class="n">WriteCostPerByte</span> <span class="o">*</span> <span class="kt">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
    <span class="n">g</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">ConsumeGas</span><span class="p">(</span><span class="n">gasToConsume</span><span class="p">,</span> <span class="s">"Write"</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This function stores a new value for a given key.</li>
  <li>It works like adding new content to a book.</li>
  <li>The function records or updates data in the parent KVStore.</li>
</ul>

<h3 id="3-deletekey---delete-operation">3. Delete(key) - Delete Operation</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">GasKVStore</span><span class="p">)</span> <span class="n">Delete</span><span class="p">(</span><span class="n">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">ConsumeGas</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">gasConfig</span><span class="o">.</span><span class="n">DeleteCost</span><span class="p">,</span> <span class="s">"Delete"</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This function removes the data associated with a given key.</li>
  <li>It is similar to erasing a word from a book.</li>
  <li>The function deletes data stored in the parent KVStore.</li>
</ul>

<h2 id="gas-consumption-based-on-key-and-value-size">Gas Consumption Based on Key and Value Size</h2>

<p>Some methods in GasKVStore consume gas in proportion to the size of the key and value.
While gas in blockchain systems is often associated with CPU execution costs, the Cosmos SDK includes storage access costs as well.
Thus, the size of the key affects gas consumption.</p>

<h3 id="what-is-a-key">What is a Key?</h3>

<p>A key is an address that identifies a specific state in the blockchain.
It serves as an identifier for a specific data entry managed by a module.</p>

<p>Here are some examples:</p>

<h4 id="1-bank-module-storing-account-balances">1. Bank module storing account balances</h4>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="s">"balances/&lt;account_address&gt;"</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"&lt;account_balance&gt;"</span>
</code></pre></div></div>

<h4 id="2-staking-module-storing-validator-information">2. Staking module storing validator information</h4>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="s">"validators/&lt;validator_address&gt;"</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"&lt;validator_info&gt;"</span>
</code></pre></div></div>

<h4 id="3-ibc-module-storing-channel-information">3. IBC module storing channel information</h4>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="s">"ibc/ports/&lt;port_id&gt;/channels/&lt;channel_id&gt;"</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"&lt;channel_info&gt;"</span>
</code></pre></div></div>

<h3 id="why-key-size-affects-gas-consumption">Why Key Size Affects Gas Consumption?</h3>

<ul>
  <li>In the Cosmos SDK, gas is not only used for computation but also for storage access.</li>
  <li>Since accessing a key-value store (KVStore) consumes gas, larger keys and values require more gas.</li>
  <li>The longer the key, the more resources are needed to retrieve and store it, resulting in higher gas costs.</li>
</ul>

<h3 id="gas-consumption-per-method">Gas Consumption per Method</h3>

<table>
  <thead>
    <tr>
      <th><strong>Operation</strong></th>
      <th><strong>Function</strong></th>
      <th><strong>Gas Consumption Criteria</strong></th>
      <th><strong>Gas Consumption Amount</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Get(key)</td>
      <td>Reads the value of a key</td>
      <td>Proportional to key size</td>
      <td>Low</td>
    </tr>
    <tr>
      <td>Set(key, value)</td>
      <td>Stores a new value for a key</td>
      <td>Proportional to key + value size</td>
      <td>High</td>
    </tr>
    <tr>
      <td>Delete(key)</td>
      <td>Deletes a key-value pair</td>
      <td>Fixed cost (DeleteCost)</td>
      <td>Medium</td>
    </tr>
  </tbody>
</table>

<h4 id="1-getkey---gas-consumption-for-reads">1. Get(key) - Gas Consumption for Reads</h4>

<p>Gas is consumed in proportion to the key size since retrieving a value requires locating the key in storage.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Example: Retrieving an account balance from the bank module</span>
<span class="n">store</span> <span class="o">:=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">KVStore</span><span class="p">(</span><span class="n">bankStoreKey</span><span class="p">)</span>
<span class="n">balanceKey</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"balances/cosmos1xyz..."</span><span class="p">)</span>  <span class="c">// Using account address as key</span>
<span class="n">balance</span> <span class="o">:=</span> <span class="n">store</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">balanceKey</span><span class="p">)</span>  <span class="c">// Gas is consumed here</span>
</code></pre></div></div>

<h4 id="2-setkey-value---gas-consumption-for-writes">2. Set(key, value) - Gas Consumption for Writes</h4>

<p>Gas is consumed in proportion to the sum of key and value sizes since writing new data requires additional storage resources.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Example: Storing validator information</span>
<span class="n">store</span> <span class="o">:=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">KVStore</span><span class="p">(</span><span class="n">stakingStoreKey</span><span class="p">)</span>
<span class="n">validatorKey</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"validators/valoper1abc..."</span><span class="p">)</span>  
<span class="n">validatorInfo</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"{status: active, power: 1000}"</span><span class="p">)</span>  
<span class="n">store</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">validatorKey</span><span class="p">,</span> <span class="n">validatorInfo</span><span class="p">)</span>  <span class="c">// Gas is consumed here</span>
</code></pre></div></div>

<p>Steps:</p>

<ol>
  <li>Locate the key “validators/valoper1abc…” in storage (or create a new entry if it does not exist).</li>
  <li>Store the value “{status: active, power: 1000}”.</li>
  <li>Consume gas proportional to the size of both the key and value.</li>
</ol>

<h4 id="3-deletekey---gas-consumption-for-deletes">3. Delete(key) - Gas Consumption for Deletes</h4>

<p>Gas consumption is fixed (DeleteCost), independent of key size.</p>

<p><em>Why is deletion a fixed-cost operation?</em></p>

<ul>
  <li>Deleting is a simple operation
    <ul>
      <li>Writing new data (Set) modifies storage, while deleting data (Delete) simply marks it as removed.</li>
    </ul>
  </li>
  <li>Deletion can be faster than retrieval
    <ul>
      <li>Get(key) requires searching for a key, meaning longer keys take longer to process.</li>
      <li>Delete(key) usually marks data as deleted, which is computationally simpler.</li>
    </ul>
  </li>
  <li>Merkle Tree Structure
    <ul>
      <li>The Cosmos SDK uses a Merkle Tree-based IAVL Store, where deletions primarily mark nodes as invalid rather than requiring extensive modifications.</li>
      <li>As a result, gas does not need to scale with key size.</li>
    </ul>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>GasKVStore ensures real-time tracking of gas consumption during transaction execution, preventing gas limit violations.</li>
  <li>Gas is consumed not only for CPU operations but also for accessing and modifying storage (KVStore).</li>
  <li>Optimizing key and value sizes can help reduce unnecessary gas costs.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[GasKVStore is a core component of the Cosmos SDK that tracks gas consumption in real-time during transaction execution. It ensures that every read, write, and delete operation consumes gas, helping to prevent transactions from exceeding their gas limits.]]></summary></entry><entry><title type="html">Understanding Channel Iteration in Go: for range vs. select vs. switch</title><link href="http://localhost:4000/2025/03/09/go-channel-iteration/" rel="alternate" type="text/html" title="Understanding Channel Iteration in Go: for range vs. select vs. switch" /><published>2025-03-09T00:00:00+09:00</published><updated>2025-03-09T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/09/go-channel-iteration</id><content type="html" xml:base="http://localhost:4000/2025/03/09/go-channel-iteration/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#code-example-donation-goal-tracker">Code Example: Donation Goal Tracker</a></li>
  <li><a href="#using-for-range-to-read-from-a-channel">Using for range to Read from a Channel</a></li>
  <li><a href="#using-select-to-listen-for-channel-data">Using select to Listen for Channel Data</a></li>
  <li><a href="#comparison-table-for-range-vs-select-vs-switch">Comparison Table: <code class="language-plaintext highlighter-rouge">for range</code> vs. <code class="language-plaintext highlighter-rouge">select</code> vs. <code class="language-plaintext highlighter-rouge">switch</code></a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="code-example-donation-goal-tracker">Code Example: Donation Goal Tracker</h2>

<p>Below is a Go program that tracks donations using channels. Two goroutines (<code class="language-plaintext highlighter-rouge">f(10)</code> and <code class="language-plaintext highlighter-rouge">f(15)</code>) listen for updates on the donation balance, and another goroutine increments the balance every second.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Donation</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">balance</span> <span class="kt">int</span>
    <span class="n">ch</span>      <span class="k">chan</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">donation</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Donation</span><span class="p">{</span><span class="n">ch</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)}</span>

    <span class="c">// Listener Goroutine (Checks if goal amount is reached)</span>
    <span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">balance</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">donation</span><span class="o">.</span><span class="n">ch</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">goal</span> <span class="p">{</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">15</span><span class="p">)</span>

    <span class="c">// Updater Goroutine (Increases balance)</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="o">++</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">25</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Keep the program running</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="using-for-range-to-read-from-a-channel">Using for range to Read from a Channel</h2>

<p>This is same as the previous example, but written in a more concise way.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">balance</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">donation</span><span class="o">.</span><span class="n">ch</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">goal</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="how-for-range-works">How for range Works</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">range donation.ch</code>: Iterates over incoming values from the channel.</li>
  <li>Each time a new value is sent to <code class="language-plaintext highlighter-rouge">donation.ch</code>, it is immediately read and assigned to <code class="language-plaintext highlighter-rouge">balance</code>.</li>
  <li>The loop continues waiting for new values until the channel is closed.</li>
</ul>

<h3 id="key-characteristics-of-for-range">Key Characteristics of for range</h3>

<ul>
  <li>Automatically waits for new values.</li>
  <li>Stops when the channel is closed.</li>
  <li>Simple and efficient for single-channel reading.</li>
</ul>

<h2 id="using-select-to-listen-for-channel-data">Using select to Listen for Channel Data</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">balance</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">donation</span><span class="o">.</span><span class="n">ch</span><span class="o">:</span> <span class="c">// Process incoming value</span>
            <span class="k">if</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">goal</span> <span class="p">{</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="how-select-works">How select Works</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">case balance := &lt;-donation.ch</code>: Reads from the channel only when data is available.</li>
  <li>Useful when monitoring multiple channels simultaneously.</li>
  <li>Requires an explicit return or break to exit the loop.</li>
</ul>

<h3 id="key-characteristics-of-select">Key Characteristics of select</h3>

<ul>
  <li>Can handle multiple channels.</li>
  <li>Only executes when a channel has data.</li>
  <li>Requires an explicit exit condition.</li>
</ul>

<h2 id="why-switch-is-not-used">Why switch is Not Used</h2>

<p>A switch statement is not suitable for continuously reading from a channel.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">{</span>
    <span class="n">balance</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">donation</span><span class="o">.</span><span class="n">ch</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">goal</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">default</span><span class="o">:</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problems-with-using-switch">Problems with Using switch</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">balance := &lt;-donation.ch</code>: Directly blocks waiting for a value (inefficient).</li>
  <li><code class="language-plaintext highlighter-rouge">default</code>: Executes unconditionally when no case matches, which prevents proper subscription behavior.</li>
</ul>

<h3 id="key-characteristics-of-switch">Key Characteristics of switch</h3>

<ul>
  <li>Cannot wait for channel updates.</li>
  <li>Inefficient because it forces direct value retrieval.</li>
  <li><code class="language-plaintext highlighter-rouge">default</code> runs even when there’s no new data.</li>
</ul>

<h2 id="comparison-table-for-range-vs-select-vs-switch">Comparison Table: for range vs. select vs. switch</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>How It Works</strong></th>
      <th><strong>Can Monitor Channels?</strong></th>
      <th><strong>Exit Condition</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">for range</code></td>
      <td>Iterates when new values arrive</td>
      <td>Yes</td>
      <td>Automatically stops when the channel is closed</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">select</code></td>
      <td>Handles multiple channels</td>
      <td>Yes</td>
      <td>Requires explicit break or return</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">switch</code></td>
      <td>Simple conditional statement</td>
      <td>No</td>
      <td>Must manually read values</td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>Use <code class="language-plaintext highlighter-rouge">for range</code> when working with a single channel that continuously receives values.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">select</code> when handling multiple channels or managing timeouts.</li>
  <li>Avoid <code class="language-plaintext highlighter-rouge">switch</code> for channel reading, as it lacks proper subscription behavior.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[In Go, channels are commonly used for communication between goroutines. This post explores different ways to read from channels and handle incoming values efficiently.]]></summary></entry><entry><title type="html">The Power of Daily Plan</title><link href="http://localhost:4000/2025/03/06/power-of-daily-plan/" rel="alternate" type="text/html" title="The Power of Daily Plan" /><published>2025-03-06T00:00:00+09:00</published><updated>2025-03-06T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/06/power-of-daily-plan</id><content type="html" xml:base="http://localhost:4000/2025/03/06/power-of-daily-plan/"><![CDATA[<h3 id="there-is-a-p-in-my-mbti-result">There is a P in my MBTI result</h3>

<p>In other words, I find it difficult to set clear plans, and I am more accustomed to handling things spontaneously. The reason I use the words “difficult” and “accustomed” is not because I dislike planning or prefer working on impulse.</p>

<p>I don’t know about others with a P-type personality, but at least for me, I want to be more like a J.</p>

<p>Especially in my profession as a developer, having a well-structured plan is often essential for getting work done effectively.</p>

<h3 id="why-planning-matters">Why Planning Matters</h3>

<p>People who have achieved great success in life all have one thing in common: they plan their day before they start.</p>

<p>They don’t do this because they have too much or too little time. Instead, they take a sacred moment to determine the priorities for the day.</p>

<p>I describe it as “sacred” because it is a moment where we acknowledge the natural limitations of time that we, as humans, cannot escape.</p>

<h3 id="the-challenges-of-planning">The Challenges of Planning</h3>

<p>But planning isn’t easy.</p>

<ul>
  <li>Should I be conservative with my plans to avoid failure?</li>
  <li>Or should I set goals based on my ambition to complete everything I want?</li>
  <li>What should I do when unexpected events force me to adjust my plans?</li>
</ul>

<p>Even though I am a P-type, I don’t start my day without any plans at all.
However, I struggle to create detailed plans.
I leave multiple possibilities open for tasks that may change, so it’s hard for me to set a clear, measurable goal for what I will complete.</p>

<h3 id="learning-from-the-best">Learning from the Best</h3>

<p>So, how do highly skilled people approach this?</p>

<p>Someone I deeply admire follows a simple rule:
They plan their day based on the maximum number of hours they can fully focus on work.</p>

<p>Within that time, they prioritize the most important tasks instead of simply listing everything they need to do.</p>

<p>Even though their to-do list was short, they carefully considered the importance and urgency of each task.
This approach made them a smart, efficient, and highly capable worker.</p>

<h3 id="the-importance-of-planning-in-workplaces">The Importance of Planning in Workplaces</h3>

<p>Many IT companies require employees to plan their daily tasks and share them with the team.
However, not all workplaces have such systems in place.</p>

<p>I believe that creating a daily work plan is the single most important task, even if your company doesn’t require it.</p>

<p>This habit offers more than just team alignment and problem-solving efficiency.</p>

<p>More importantly, it helps you understand your own workload and set priorities to maximize productivity within your available time.</p>

<h3 id="if-you-havent-been-planning-start-now">If You Haven’t Been Planning, Start Now</h3>

<p>Regardless of experience level, if you are still starting your day without a plan, I strongly encourage you to make a change immediately.</p>

<p>At first, I also thought, “Why waste time planning? I should just get to work.”
Because of this mindset, I missed multiple opportunities to build a solid planning habit.</p>

<p>But as my workload grew and I needed to prioritize,
I realized that changing my deeply ingrained habit of not planning was incredibly difficult.</p>

<p>Even now, I am still working on improving,
and I am writing this to keep myself motivated.</p>

<h3 id="if-you-dont-know-where-to-start">If You Don’t Know Where to Start</h3>

<p>That’s okay. Planning is never easy.</p>

<p>No one is good at it from the beginning.
But with time and practice, you will get better at it.</p>

<p>One important thing: don’t be too ambitious.
If you plan too many tasks, you will only end up feeling overwhelmed.</p>

<p>Instead, prioritize what truly matters within your time constraints,
and have the courage to delay or eliminate tasks that don’t fit into your schedule.</p>

<h3 id="we-cannot-do-everything">We cannot do everything</h3>

<p>Even the exceptional people we look up to don’t do everything.
The difference is that they distinguish between what is important and what is not.</p>

<p>They don’t try to do it all.
Instead, they focus on their priorities with a sense of humility
— knowing that time is limited, and they must make the most of it.</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[Even the most exceptional people can’t do everything—they simply prioritize what truly matters, recognizing their limits and making the most of their time with humility.]]></summary></entry><entry><title type="html">Understanding Slice Initialization and Capacity in Go</title><link href="http://localhost:4000/2025/03/02/go-slice-initialization/" rel="alternate" type="text/html" title="Understanding Slice Initialization and Capacity in Go" /><published>2025-03-02T00:00:00+09:00</published><updated>2025-03-02T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/02/go-slice-initialization</id><content type="html" xml:base="http://localhost:4000/2025/03/02/go-slice-initialization/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#summary">Summary</a></li>
  <li><a href="#how-to-initialize-a-slice">How to Initialize a Slice</a></li>
  <li><a href="#advantages-of-preallocating-capacity">Advantages of Preallocating Capacity</a></li>
  <li><a href="#creating-a-slice-with-an-initial-length">Creating a Slice with an Initial Length</a></li>
</ul>

<h2 id="summary">Summary</h2>

<ol>
  <li>Preallocating capacity improves performance by reducing the number of reallocations when appending elements.</li>
  <li>If a slice is initialized with a non-zero length, it is pre-filled with zero values.</li>
  <li>Appending elements can trigger capacity expansion, usually doubling the size of the underlying array.</li>
</ol>

<h2 id="how-to-initialize-a-slice">How to Initialize a Slice</h2>

<p>In Go, the following code snippet creates a slice with length 0 and capacity 1:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Create a slice with length 0 and capacity 1</span>
<span class="n">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Length(len)</code>: The number of elements currently stored in the slice. This represents the number of initialized elements.</li>
  <li><code class="language-plaintext highlighter-rouge">Capacity(cap)</code>: The total allocated size of the underlying array, which determines how many elements can be stored before reallocation is required.</li>
</ul>

<h2 id="advantages-of-preallocating-capacity">Advantages of Preallocating Capacity</h2>

<p>In Go, when a slice reaches its capacity, the underlying array doubles in size upon expansion.
If you expect a slice to grow significantly, preallocating capacity can improve performance by reducing memory reallocations.</p>

<p>Here is an example of capacity expansion in slices:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c">// Initial capacity of 1</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="c">// Output: 0 1</span>

<span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span> <span class="c">// Fits within current capacity (1)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="c">// Output: 1 1</span>

<span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">20</span><span class="p">)</span> <span class="c">// Exceeds capacity → reallocates (new capacity: 2)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="c">// Output: 2 2</span>

<span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span> <span class="c">// Exceeds capacity again → reallocates (new capacity: 4)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="c">// Output: 3 4</span>
</code></pre></div></div>

<ul>
  <li>When <code class="language-plaintext highlighter-rouge">append</code> is called, if the slice exceeds its current capacity, a new array is allocated with double the previous capacity.</li>
  <li>This reduces the number of reallocations when appending elements, optimizing performance.</li>
</ul>

<h2 id="creating-a-slice-with-an-initial-length">Creating a Slice with an Initial Length</h2>

<p>You can also specify the length when initializing a slice:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c">// Length 0, Capacity 1</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c">// Length 1, Capacity 1</span>

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="c">// Output: []</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="c">// Output: [0]</span>
</code></pre></div></div>

<h3 id="effect-of-initializing-a-slice-with-a-non-zero-length">Effect of Initializing a Slice with a Non-Zero Length</h3>

<p>If you specify a non-zero length, the slice will be pre-filled with zero values.
This affects how append operations work:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s1</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> 
<span class="n">s2</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> 

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c">// Output: [1] 1</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span> <span class="c">// Output: [0,1] 2</span>
</code></pre></div></div>

<h3 id="why-does-s2-expand-its-capacity">Why Does s2 Expand Its Capacity?</h3>

<ul>
  <li>s2 was initialized with a length of 1, so it already contains a zero ([0]).</li>
  <li>When appending a new element (1), it exceeds the initial capacity of 1, causing Go to double the capacity to 2.</li>
  <li>On the other hand, s1 starts with length 0, so appending a single element does not exceed its initial capacity.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Understanding slice capacity behavior is essential for writing efficient Go programs, especially when dealing with large or dynamic data structures.]]></summary></entry><entry><title type="html">DOG: A New Gossip Protocol for CometBFT</title><link href="http://localhost:4000/2024/12/26/dog-gossip-protocol/" rel="alternate" type="text/html" title="DOG: A New Gossip Protocol for CometBFT" /><published>2024-12-26T00:00:00+09:00</published><updated>2024-12-26T00:00:00+09:00</updated><id>http://localhost:4000/2024/12/26/dog-gossip-protocol</id><content type="html" xml:base="http://localhost:4000/2024/12/26/dog-gossip-protocol/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#for-the-busy-modern-soul">For the busy modern soul</a></li>
  <li><a href="#the-usefulness-of-dog-in-the-persistent-peering-network">The usefulness of DOG in the persistent peering network</a></li>
  <li><a href="#comparison-flood-gossip-protocol">Comparison: Flood gossip protocol</a></li>
</ul>

<h2 id="for-the-busy-modern-soul">For the busy modern soul</h2>

<p>DOG optimizes the path for transmitting transactions to each node.</p>

<ul>
  <li>When the sent transaction is returned (cycle), it closes the path by sending a <code class="language-plaintext highlighter-rouge">HaveTx</code> message to the peer that sent the transaction.</li>
  <li><code class="language-plaintext highlighter-rouge">HaveTx</code> message only carries the transaction hash, so there is little network overhead.</li>
  <li>Gradually remove unnecessary paths to minimize duplicate transactions.
    <ul>
      <li>In the paper, It is called a <em>Closed-loop redundancy controller</em> which is a mechanism for the system to monitor the current network status and dynamically adjust the level of redundant propagation.</li>
    </ul>
  </li>
  <li>Finally, a <code class="language-plaintext highlighter-rouge">superposition of directed spanning tree</code> structure is created with each node as the root.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/44f98095-8a47-442e-9e26-62c02569e8fb" alt="Initially all routes are open" /></p>

<p><em>@Initially all routes are open</em></p>

<p><img src="https://github.com/user-attachments/assets/19b8b63c-00aa-4b00-92b4-24e2a72c4d7a" alt="The result of directed spanning trees" /></p>

<p><em>@The result: Directed spanning trees, where each node has a single, optimal path to reach every other node.</em></p>

<p>Redundancy Controller is used to set the transaction duplication tolerance range per node.</p>

<ul>
  <li>Redundancy Level
    <ul>
      <li>
        <p>The percentage of redundancy allowed in the overall transaction flow</p>

        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Redundancy Level <span class="o">=</span> 1 / Allowable redundancy ratio
</code></pre></div>        </div>
      </li>
      <li>The lower the Redundancy Level, the lower the tolerance for duplicate transactions</li>
      <li>f.e. <code class="language-plaintext highlighter-rouge">Redundancy Level = 0.5</code> means when 100 different transactions come in, up to 50 duplicate transactions can be received</li>
      <li>If duplicate transactions are lower than the allowable range, a <code class="language-plaintext highlighter-rouge">ResetRoute</code> message is sent to the peer to reactivate the closed route</li>
    </ul>
  </li>
</ul>

<p>Test Results</p>

<ul>
  <li>
    <p>In the test, transactions were transmitted at a speed of 500tx/s for 15 minutes from 200 nodes</p>
  </li>
  <li>
    <p>Mempool: As the path is built, the mempool size and cache hit count gradually decrease</p>
  </li>
  <li>Consensus
    <ul>
      <li>More stable block production</li>
      <li>Less additional consensus rounds for the validator is needed</li>
      <li>8 times less missing validators during voting</li>
      <li>About 2.7 times less missed blocks</li>
      <li>Additional 10% reduction in network traffic generated by <code class="language-plaintext highlighter-rouge">BlockPart</code> messages</li>
    </ul>
  </li>
  <li>Resource usage and latency
    <ul>
      <li>CPU usage reduced by 43%</li>
      <li>Memory usage reduced by 10%</li>
      <li>Total transaction verification time (checkTx) reduced by 10%</li>
      <li>Average latency: Flood (3.63s), DOG (3.14s)</li>
    </ul>
  </li>
</ul>

<h2 id="the-usefulness-of-dog-in-the-persistent-peering-network">The usefulness of DOG in the persistent peering network</h2>

<p>Persistent peering network is a network where nodes are connected to each other in a persistent way, meaning that nodes are always connected to each other. All validators are connected to each other, and since there are no multi-hops in the network, all transactions can be propagated directly to all nodes in one hop.</p>

<p>As you may have guessed, DOG is not an advantage in this environment. In a single-hop architecture, where a transaction from A to B does not need to go through C, no duplicate transactions occur. The biggest advantage of DOG is that it optimizes the overall network path by gradually reducing the paths where duplicate transactions can occur, so its use is unnecessary in this environment.</p>

<p>However, this does not mean that DOG is completely unnecessary.</p>

<p>Since it is not guaranteed that all nodes will always maintain connectivity, DOG can maintain network propagation by dynamically reconfiguring the path when a specific network connection becomes unstable.</p>

<p>In addition, even in a direct peering environment, network bandwidth can be further reduced through duplicate transaction filtering. In particular, when unnecessary redundant data is propagated in communication between nodes, DOG can detect and minimize this.</p>

<p>Finally, when the number of network nodes is greatly expanded, it may be realistically difficult to maintain persistent peering, but DOG can maintain efficient propagation even in large-scale networks by optimizing the transaction propagation path.</p>

<h2 id="comparison-flood-gossip-protocol">Comparison: Flood gossip protocol</h2>

<p><code class="language-plaintext highlighter-rouge">Flood</code> gossip protocol broadcasts a transaction to all peers in the network when the transaction is created.</p>

<p>During this process, the same transaction may be transmitted multiple times.
In a fully connected network, all nodes are directly connected to each other, which increases redundant propagation.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Flood gossip protocol simply broadcast transactions without checking for duplication, which wastes bandwidth.

For example, There are 4 nodes A, B, C, D.

- If node A sends a transaction to nodes B, C, and D, then B, C, and D also send the same transaction back to each other.
- Flood simply propagate without checking for transaction duplication, resulting in wasted bandwidth.
</code></pre></div></div>

<p>As a result, these problems occur:</p>

<ul>
  <li>Network bandwidth wastes
    <ul>
      <li>Duplicate transaction messages are continuously transmitted, which wastes bandwidth unnecessarily.</li>
    </ul>
  </li>
  <li>Performance degradation
    <ul>
      <li>Transaction propagation speed may slow down as the network becomes overloaded.</li>
    </ul>
  </li>
  <li>Scalability issues
    <ul>
      <li>As the number of network nodes increases, the number of duplicate propagated transactions also increases rapidly.</li>
    </ul>
  </li>
</ul>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://informal.systems/blog/a-new-mempool-gossip-protocol-for-cometbft">A New Mempool Gossip Protocol for CometBFT</a></li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[DOG(Dynamic Optimal Graph) is a new gossip protocol for CometBFT, reduces the bandwidth consumption by decreasing the duplicated messages.]]></summary></entry><entry><title type="html">Narwhal: Scalable Blockchain Data Propagation with DAG-Based Design</title><link href="http://localhost:4000/2024/12/17/what-is-narwhal/" rel="alternate" type="text/html" title="Narwhal: Scalable Blockchain Data Propagation with DAG-Based Design" /><published>2024-12-17T00:00:00+09:00</published><updated>2024-12-17T00:00:00+09:00</updated><id>http://localhost:4000/2024/12/17/what-is-narwhal</id><content type="html" xml:base="http://localhost:4000/2024/12/17/what-is-narwhal/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#what-is-narwhal">What is Narwhal?</a></li>
  <li><a href="#worker-and-primary">Worker and Primary</a></li>
  <li><a href="#the-process-of-narwhal">The process of Narwhal</a></li>
  <li><a href="#narwhal-combined-with-consensus-protocol">Narwhal combined with consensus protocol</a></li>
  <li><a href="#limitations">Limitations</a></li>
</ul>

<h2 id="what-is-narwhal">What is Narwhal?</h2>

<p>Every blockchain should share all transactions with nodes, and it directly affects performance, including throughput and latency.</p>

<p>Narwhal was introduced in the paper <a href="https://arxiv.org/abs/2105.11827">“Narwhal and Tusk: A DAG-based Mempool and Efficient BFT Consensus”</a>. Narwhal processes transaction propagation and validation in separate, worker and primary layers to reduce bottlenecks and provide modular-based data availability.</p>

<p>Narwhal uses DAG(Directed Acyclic Graph) to clearly define dependencies between transaction data, thereby maximizing parallelism and scalability. DAG flexibly manages the order of transactions and supports stable data propagation even when the network is massively expanded.</p>

<p><img src="https://github.com/user-attachments/assets/975a0c88-d70b-47c9-b1f8-1f9b0808baf1" alt="The relationship in the process of Narwhal" /></p>

<p><em>@The relationship in the process of Narwhal</em></p>

<h2 id="worker-and-primary">Worker and Primary</h2>

<p>When the client sends a transaction, it goes to the worker located in the node. Transactions are delivered to workers simultaneously, and each worker groups the received transactions into batches.</p>

<p>When transactions accumulate over a certain period or exceed a specified size, the batches created up to that point are transmitted to other nodes.</p>

<p>Nodes validate the received batch and send back a signature of itself to the origin worker. When a worker receives 2f + 1 of the signatures from other nodes, it creates a ‘Mempool block’, including a certificate.</p>

<p><img src="https://github.com/user-attachments/assets/36fc3b5e-1911-4d9d-8b78-8b33c7daa697" alt="The design of the mempool block. r is round, and i is block number" /></p>

<p><em>@The design of the mempool block. r is round, and i is block number</em></p>

<p>The certificate list guarantees that this Mempool block is already validated by 2f + 1 signatures from other nodes is reusable and does not need to re-propagate transactions even though the proposal has failed.</p>

<p>The primary receives Mempool blocks from workers in the same node and creates DAG for managing dependency between transactions. DAG uses authenticated Mempool blocks as nodes, and the relationships (parent-child) between each mempool block as edges connecting the nodes to determine the order of transactions and use them as data for consensus.</p>

<h2 id="the-process-of-narwhal">The process of Narwhal</h2>

<h3 id="1-make-batches-from-transactions-and-broadcast">1. Make batches from transactions and broadcast</h3>

<p>As described above, transactions sent from clients are generated in batches over a certain period or when a certain size is satisfied.</p>

<h3 id="2-get-the-signature-of-thenode">2. Get the signature of the node</h3>

<p>Nodes send back their signature to the origin node worker, not a different worker. When signature data is disseminated randomly, network traffic is increased, and data integrity is difficult to ensure.
Every batch has metadata, including the ID of the batch and worker. A worker who receives batches can send them back to the origin worker due to their containing worker ID.</p>

<h3 id="3-make-the-mempool-block-with-certification">3. Make the mempool block with certification</h3>

<p>When the worker receives more than 2f + 1 signature from other nodes, the worker creates a ‘Mempool block’ including transaction information, signature, etc.</p>

<p>Mempool block has a certification list, not a single certification to reuse when the proposal is failed. It could be a waste of network resources if the Mempool block has to obtain signatures from other nodes in every round, even though they already made certification from signatures of other nodes in previous rounds.</p>

<h3 id="4-send-dag-to-the-leadernode">4. Send DAG to the leader node</h3>

<p>Validator nodes transmit the DAG generated over a certain period to the primary of the leader node. The leader node arranges Mempool blocks from received DAGs into a single DAG and sends it to other nodes for proposal. Non-validators also generate DAG but do not send it to the leader node.</p>

<h3 id="5-when-the-round-isfailed">5. When the round is failed</h3>

<p>A round is a logical unit of time during which transaction data is propagated through the network and consensus is reached. Round failures can occur due to leader failure, network delays, malicious node behavior, etc.</p>

<p>In Narwhal, a round is defined as a process in which a specific leader is designated, and the leader merges DAG data to attempt consensus.</p>

<h4 id="in-worker">In worker</h4>

<ul>
  <li>
    <p>Even though the round failed, a worker maintains the Mempool block and reuses it in the next round.</p>
  </li>
  <li>
    <p>Since the worker continues to collect new transactions from clients regardless of round failure, new transactions are bundled into the next batch, including transactions from the previous batch, and propagated to the network.</p>
  </li>
  <li>
    <p>A batch is converted into a Mempool Block when a worker collects more than 2f+1 signatures from other nodes.</p>
  </li>
</ul>

<h4 id="in-primary">In primary</h4>

<ul>
  <li>Since the previous Mempool block is already allocated in DAG, it can be reused in the next round.</li>
</ul>

<h2 id="narwhal-combined-with-consensus-protocol">Narwhal combined with consensus protocol</h2>

<p>Most consensus algorithms, including PBFT and Hotstuff, operating with strongly coupled data propagation and consensus in the consensus process, can be improved in performance when they use Narwhal.</p>

<p>Narwhal provides increased network performance from completely separated data propagation and consensus.</p>

<h3 id="data-propagation">Data Propagation</h3>

<ul>
  <li>
    <p>In Narwhal, data availability can be ensured by both workers collecting transaction data and primary generating DAG.</p>
  </li>
  <li>
    <p>Since transaction data is propagated independently from the consensus process, the data remains valid even if the consensus fails.</p>
  </li>
</ul>

<h3 id="consensus">Consensus</h3>

<ul>
  <li>Since Narwhal has already completed the data propagation, HotStuff only needs to agree on the DAG state, which is already guaranteed by the worker and primary from Narwhal.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/3107439d-ce19-4e25-bf88-483243ad68ac" alt="Differences between Narwhal-based consensus and standalone" /></p>

<p><em>@Differences between Narwhal-based consensus and standalone</em></p>

<h2 id="limitations">Limitations</h2>

<p>Because of the mesh structure in DAG, the complexity and size would be increased rapidly when the network expands and the number of transactions is increased. To solve this, we need a strategy to periodically clean up old Mempool blocks or limit the depth and size of the DAG.</p>

<p>Also, Narwhal maintains previous DAG data, which the proposal failed, and reuses them in the next round. We also need a policy to efficiently discard old data or merge it with additional data.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://arxiv.org/abs/2105.11827">Narwhal and Tusk: A DAG-based Mempool and Efficient BFT Consensus</a></li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Every blockchain should share all transactions with nodes, and it directly affects performance, including throughput and latency. Narwhal was introduced in the paper “Narwhal and Tusk…"]]></summary></entry><entry><title type="html">인터페이스 기반 설계의 중요성과 go언어를 이용한 구현 방법</title><link href="http://localhost:4000/2023/12/02/go-interface-architecture/" rel="alternate" type="text/html" title="인터페이스 기반 설계의 중요성과 go언어를 이용한 구현 방법" /><published>2023-12-02T00:00:00+09:00</published><updated>2023-12-02T00:00:00+09:00</updated><id>http://localhost:4000/2023/12/02/go-interface-architecture</id><content type="html" xml:base="http://localhost:4000/2023/12/02/go-interface-architecture/"><![CDATA[<p><br /></p>

<h2 id="왜-우리는-인터페이스-기반으로-설계해야-할까">왜 우리는 인터페이스 기반으로 설계해야 할까?</h2>

<p>우리가 사용하고 있는 여러 서비스들을 포함한 일반적인 프로그램은 다양한 모듈로 구성되어 있다. 그리고 이러한 <u>모듈간의 유연한 연결</u>을 위하여 인터페이스 기반의 설계를 권장한다.</p>

<p>넷플릭스를 예로 들어보자. 넷플릭스라는 하나의 서비스안에는 비디오 스트리밍 뿐만 아니라 회원관리, 구독권 결재, 추천, 광고 등 수많은 세부 서비스들이 존재한다.</p>

<p>그리고 당연히, 이 수많은 서비스들을 개발하기 위한 수많은 팀들이 존재한다. 심지어 소규모의 스타트업에서도 (일반적으로는) 각 기능(모듈)을 개발하기 위한 팀, 아니 적어도 사람이 별도로 구성된다.</p>

<blockquote>
  <p>비록 아닌 곳들 또한 많이 있지만, 오늘 하고싶은 이야기의 주제와는 조금 벗어나기 때문에 넘어간다.</p>
</blockquote>

<p>다시 돌아와서 결국 수많은 기능들이 개발됨으로써 넷플릭스라는 하나의 서비스가 사용자에게 제공되는 것인데, 이 과정에서 수많은 팀들이 각자의 계획과 일정에 맞게 개발을 진행하기 때문에 의사소통과 협업에 문제가 발생하기 마련이다.</p>

<p>이를 해결하기 위한 가장 좋은 방법이 인터페이스 기반으로 설계하고 개발하는 것이다. 간단하게 예시로 표현해보면 아래와 같다.</p>

<ol>
  <li>회원관리를 개발하는 A팀과 결제시스템을 개발하는 B팀이 있다. A팀에서 개발하는 기능 중 회원권 구매 기능이 있고, 이 기능은 B팀에서 개발중인 PG 연동 기능을 포함해야 한다.</li>
  <li>B팀에서 개발중인 다른 기능들이 있기 때문에, PG 연동 기능을 바로 개발하기 어렵다. 그렇다고 A팀은 B팀의 업무가 끝날때까지 기다리고만 있을수는 없다.</li>
  <li>B팀은 A팀에게 인터페이스 형태의 PG 연동 기능을 제공한다. 실제 동작하는 부분은 개발하지 않았지만 어떤 형태로 만들어질지에 대한 추상적인 형태는 제공할 수 있다.</li>
  <li>A팀은 B팀으로부터 제공받은 인터페이스를 기반으로 Mock 기반의 구현체를 만들고, 이를 이용하여 회원권 구매 기능 개발을 진행한다.</li>
  <li>추후 B팀에서 PG 연동 기능 개발이 완료되면, 기존의 Mock 기반 구현체를 실제 동작이 포함된 구현체로 교체한다.</li>
</ol>

<blockquote>
  <p>Mock : 실제 구현체와 통신하지 않고 얻을 수 있는 가짜 또는 샘플데이터</p>
</blockquote>

<p>이렇게 인터페이스 기반으로 설계하고 개발하면 <u>각 모듈간 의존성을 최소화시키고 독립적인 개발이 가능</u>하다는 장점이 있다.</p>

<p><br /></p>

<h2 id="인터페이스-기반-설계의-어려움">인터페이스 기반 설계의 어려움</h2>

<p>하지만 인터페이스 기반의 설계는 쉽지 않다. 가장 큰 이유로 인터페이스는 결국 <u>명확한 업무 설계</u>를 기반으로 만들어지기 때문이다. 대부분의 개발자의 경우 머리보다 손이 먼저나가는 경우가 많은데, 이는 업무에 대한 명확한 분석이 먼저가 아니라 개발 과정에서 업무의 분석이 이루어지기 마련이다.</p>

<p>이렇게 되면, 위에서 설명한 A팀과 B팀의 예시로 볼 때, A팀이 B팀에서 제공받은 인터페이스를 기반으로 개발한 내용들이 향후에 변경될 요지가 존재한다는 것이고 이는 인터페이스 기반의 설계와 개발로부터 얻을 수 있는 장점을 완전히 벗어나게 된다. 그러므로 실제 개발을 시작하는 시간은 좀 늦어질지라도, 업무에 대한 많은 고민과 분석을 통해 인터페이스를 먼저 설계하고 이를 기반으로 구현체를 개발하는 것이 무엇보다 중요하다.</p>

<p><br /></p>

<h2 id="go언어를-이용한-인터페이스-설계">Go언어를 이용한 인터페이스 설계</h2>

<p>Go언어는 다른 언어와 비교하여 적극적으로 인터페이스 형태의 설계를 권장하고 있고, 실제로 인터페이스 방식으로 설계하기가 매우 편리하다. 별도의 인터페이스를 위한 파일을 만들 필요도 없으며, 해당 인터페이스를 사용하겠다는 명시적인 선언도 필요없다. 단지 인터페이스의 모든 기능을 모듈 내에 포함시키면 된다.</p>

<p>Go언어에서 인터페이스를 설계할 경우 권장하는 사항이 하나 있는데, 인터페이스 이름을 동작을 수행하는 객체 형태로 짓는 것이다. 예를 들어 어떠한 결과를 출력하기 위한 인터페이스의 경우 Printer, 결과를 파일로 저장하는 경우 Writer와 같이 뒤에 -er 접미사를 붙여서 작성하는 것을 권장한다.</p>

<h3 id="예시">예시</h3>

<p>서명된 이더리움 트랜잭션을 네트워크에 전송하는 인터페이스를 만들어보자.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Sender</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">SendTransaction</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">from</span> <span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">to</span> <span class="o">*</span><span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">value</span> <span class="o">*</span><span class="n">big</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이더리움으로 트랜잭션을 전송하기 위한 두가지 방법이 있다.</p>
<ul>
  <li>이더리움 네트워크로 전송된 트랜잭션이 블록에 마이닝될때까지 기다렸다가 결과를 반환해주는 동기 처리방식</li>
  <li>이더리움 네트워크로 트랜잭션을 전송하고 결과는 반환받지 않는 비동기 처리방식</li>
</ul>

<p>이더리움 네트워크로 트랜잭션을 전송하는 것은 동일하기 때문에, 위에서 선언한 Sender 인터페이스를 사용할 수 있다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">TxManager</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// TxManager라는 구현체가 Sender 인터페이스를 사용할 것이라고 선언했다. </span>
    <span class="n">sender</span> <span class="n">Sender</span> 
    <span class="o">...</span>
<span class="p">}</span>

<span class="c">// Sender 인터페이스를 가진 구현체를 만든다.</span>
<span class="k">func</span> <span class="n">NewTxManager</span><span class="p">(</span><span class="n">sender</span> <span class="n">Sender</span><span class="p">)</span> <span class="o">*</span><span class="n">TxManager</span> <span class="p">{</span>
    <span class="o">&amp;</span><span class="n">TxManager</span><span class="p">{</span>
        <span class="n">sender</span><span class="o">:</span> <span class="n">sender</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>동기 처리 방식을 제공하는 모듈과 비동기 처리 방식을 제공하는 모듈은 각각 아래와 같다. 둘다 Sender 인터페이스에 포함된 기능을 포함하고 있다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// SyncSender</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">SyncSender</span><span class="p">)</span> <span class="n">NewSyncSender</span><span class="p">()</span> <span class="o">*</span><span class="n">SyncSender</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">SyncSender</span><span class="p">)</span> <span class="n">SendTransaction</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">from</span> <span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">to</span> <span class="o">*</span><span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">value</span> <span class="o">*</span><span class="n">big</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>

<span class="c">// AsyncSender</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">AsyncSender</span><span class="p">)</span> <span class="n">NewAsyncSender</span><span class="p">()</span> <span class="o">*</span><span class="n">AsyncSender</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">AsyncSender</span><span class="p">)</span> <span class="n">SendTransaction</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">from</span> <span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">to</span> <span class="o">*</span><span class="n">common</span><span class="o">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">value</span> <span class="o">*</span><span class="n">big</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
<span class="o">...</span>
</code></pre></div></div>

<p>인터페이스를 실제 구현체에 주입할 때는 아래와 같이 진행하면 된다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">syncSender</span> <span class="o">:=</span> <span class="n">NewSyncSender</span><span class="p">()</span>
    <span class="n">asyncSender</span> <span class="o">:=</span> <span class="n">NewAsyncSender</span><span class="p">()</span>
    
    <span class="c">// 동기 방식</span>
    <span class="n">txm</span> <span class="o">:=</span> <span class="n">NewTxManager</span><span class="p">(</span><span class="n">syncSender</span><span class="p">)</span> 
    <span class="c">// 비동기 방식</span>
    <span class="n">txm</span> <span class="o">:=</span> <span class="n">NewTxManager</span><span class="p">(</span><span class="n">asyncSender</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://appmaster.io/blog/interface-implementation-go">Interface in Go - AppMaster</a></li>
</ul>]]></content><author><name>wonjoon</name></author><category term="개발" /><summary type="html"><![CDATA[Importance of using interface while construct program and example of using golang]]></summary></entry><entry><title type="html">가스비 절감의 효과를 갖는 솔리디티의 custom error</title><link href="http://localhost:4000/2023/08/22/blockchain-custom-error-solidity/" rel="alternate" type="text/html" title="가스비 절감의 효과를 갖는 솔리디티의 custom error" /><published>2023-08-22T00:00:00+09:00</published><updated>2023-08-22T00:00:00+09:00</updated><id>http://localhost:4000/2023/08/22/blockchain-custom-error-solidity</id><content type="html" xml:base="http://localhost:4000/2023/08/22/blockchain-custom-error-solidity/"><![CDATA[<p><br /></p>

<h2 id="커스텀-에러">커스텀 에러</h2>

<p><a href="https://github.com/ethereum/solidity/releases/tag/v0.8.4">솔리디티 v0.8.4</a>에서 소개된 방법으로, 기존의 에러 표현 방식에 비해 가스비를 줄이면서 에러 발생의 원인을 설명할 수 있다.<br />
아래는 기존의 방식과 커스텀 에러 방식 각각을 예시로 표현한 내용이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Before
revert("Insufficient funds."); // 사용 (선언 없음)

# Custom errors
error Unauthorized(); // 선언
...
revert Unauthorized(); // 사용
</code></pre></div></div>

<p>가스비는 스마트 컨트랙트의 배포(deploy)에 영향을 주는데, 이 외에도 기존의 방식은 에러에 대한 정보를 동적으로 관리하기 어렵다는 단점이 있었다.<br />
커스텀 에러는 ‘error’ 구문을 사용한다. 그리고 외부(인터페이스 또는 라이브러리)에서 선언한 에러를 스마트 컨트랙트에 불러와서 사용할 수도 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized(); // Custom error

contract VendingMachine {
    address payable owner = payable(msg.sender);

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();  // Using custom error with revert statement

        owner.transfer(address(this).balance);
    }
    // ...
}
</code></pre></div></div>

<p>위의 예시를 보면 <a href="https://docs.soliditylang.org/en/latest/contracts.html?color=dark#events">이벤트(event)</a>와 구문이 비슷한 것을 볼 수 있는데, 차이점은 <a href="https://docs.soliditylang.org/en/latest/control-structures.html?color=dark#revert-statement">revert 구문</a>과 같이 사용해야 한다는 것이다. revert를 사용하면 현재까지 진행되던 상태 변환 프로세스가 모두 중단되고 에러 메시지를 호출자에게 전달한다. <a href="https://github.com/ethereum/solidity/issues/11278">require 구문의 사용은 현재 포스팅 시점(2023.08.23)에는 제공되지 않고 있는데</a>, 아래의 예시를 보면 이해가 쉬울 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This Error message with require statement 
require(condition, "error message")

# Should be translated to
if (!condition) revert CustomError()
</code></pre></div></div>

<p><br /></p>

<h2 id="파라미터를-추가한-커스텀-에러">파라미터를 추가한 커스텀 에러</h2>

<p>커스텀 에러는 파라미터를 추가할 수도 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

/// Insufficient balance for transfer. Needed `required` but only
/// `available` available.
/// @param available balance available.
/// @param required requested amount to transfer.
error InsufficientBalance(uint256 available, uint256 required);

contract TestToken {
    mapping(address =&gt; uint) balance;
    function transfer(address to, uint256 amount) public {
        if (amount &gt; balance[msg.sender])
            // Error call using named parameters. Equivalent to
            // revert InsufficientBalance(balance[msg.sender], amount);
            revert InsufficientBalance({
                available: balance[msg.sender],
                required: amount
            });
        balance[msg.sender] -= amount;
        balance[to] += amount;
    }
    // ...
}
</code></pre></div></div>

<p>위의 예시를 보면 커스텀 에러를 아래와 같이 선언하고,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error InsufficientBalance(uint256 available, uint256 required);
</code></pre></div></div>

<p>아래와 같이 사용한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>revert InsufficientBalance({
    available: balance[msg.sender],
    required: amount
});
</code></pre></div></div>

<p>사용 시점의 에러 데이터는 abi.encodeWithSignature(“InsufficientBalance(uint256,uint256)”, balance[msg.sender], amount)로 ABI 인코딩된다.</p>

<p><br /></p>

<h2 id="실제로-얼마나-스마트-컨트랙트-사이즈가-줄어드는가">실제로 얼마나 스마트 컨트랙트 사이즈가 줄어드는가?</h2>

<p>위에서 예시로 든 VendingMachine 스마트 컨트랙트 기준으로 커스텀 에러 사용 여부에 따른 사이즈를 비교해보았다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized(); // Custom error

contract VendingMachine {
    address payable owner = payable(msg.sender);

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();  // 커스텀 에러 사용 시
            revert("Insufficient funds."); // 커스텀 에러 미사용 시

        owner.transfer(address(this).balance);
    }
    // ...
}
</code></pre></div></div>

<p><a href="https://github.com/IoBuilders/truffle-contract-size">truffle-contract-size</a>를 사용하여 각 상황별로 스마트 컨트랙트 사이즈를 계산한 결과는 아래와 같다.</p>
<ul>
  <li>커스텀 에러 사용 : 0.33 KiB</li>
  <li>커스텀 에러 미사용 : 0.46 KiB</li>
</ul>

<p>단순한 에러라 할지라도 대략 0.13 KiB 정도의 차이가 나는 것을 보면, 복잡한 로직이 들어간 스마트 컨트랙트 일수록 커스텀 에러의 적용이 꽤 유의미한 가치를 가져올 수 있을 것이라고 생각된다.</p>

<p><br /></p>

<h2 id="좀더-깊이-커스텀-에러-들여다보기">좀더 깊이 커스텀 에러 들여다보기</h2>

<p>파라미터를 포함하지 않는 기본적인 커스텀 에러 ‘revert Unauthorized()’를 <a href="https://docs.soliditylang.org/en/latest/yul.html">Yul 코드</a>로 확인해보면 아래와 같다.</p>

<blockquote>
  <p>Yul 코드는 다양한 백엔드에서 바이트코트 형태로 컴파일될 수 있도록 하는 중간 언어(intermediate language)를 의미한다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># revert Unauthorized();
let free_mem_ptr := mload(64)
mstore(free_mem_ptr, 0x82b4290000000000000000000000000000000000000000000000000000000000)
revert(free_mem_ptr, 4)
</code></pre></div></div>

<p>위의 0x82b42900은 Unauthourized() 커스텀 에러의 selector를 의미한다. 그렇다면 커스텀 에러를 사용하지 않고 revert(“Unauthorized”)와 같이 에러 메시지를 그대로 사용하면 어떻게 될까?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># revert("Unauthorized");
let free_mem_ptr := mload(64)
mstore(free_mem_ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
mstore(add(free_mem_ptr, 4), 32)
mstore(add(free_mem_ptr, 36), 12)
mstore(add(free_mem_ptr, 68), "Unauthorized")
revert(free_mem_ptr, 100)
</code></pre></div></div>

<p>0x08c379a0 값은 Error(에러메시지 문자열)의 selector를 의미한다. 단순히 코드만 봐도 커스텀 에러를 사용할 때가 더 적은 가스비를 소모하는 것을 볼 수 있다. 런타임 시점의 가스비는 revert 조건을 만족하는 경우에 대해서만 연관이 있다는 것을 기억하자.</p>

<p><br /></p>

<h2 id="커스텀-에러-확인하기">커스텀 에러 확인하기</h2>

<p>그렇다면 커스텀 에러는 어떻게 확인할 수 있을까? 가장 최근 버전의 ethers.js를 사용하면 커스텀 에러 메시지를 디코딩한 값을 확인할 수 있다.<br />
아래 예시는 위의 InsufficientBalance 커스텀 에러를 확인하는 경우를 나타낸다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { ethers } from 'ethers'

// As a workaround, we have a function with the
// same name and parameters as the error in the abi.
const abi = [
  'function InsufficientBalance(uint256 available, uint256 required)',
]

const interface = new ethers.utils.Interface(abi)
const error_data =
  '0xcf479181000000000000000000000000000000000000' +
  '0000000000000000000000000100000000000000000000' +
  '0000000000000000000000000000000000000100000000'

const decoded = interface.decodeFunctionData(
  interface.functions['InsufficientBalance(uint256,uint256)'],
  error_data
)
// Contents of decoded:
// [
//   BigNumber { _hex: '0x0100', _isBigNumber: true },
//   BigNumber { _hex: '0x0100000000', _isBigNumber: true },
//   available: BigNumber { _hex: '0x0100', _isBigNumber: true },
//   required: BigNumber { _hex: '0x0100000000', _isBigNumber: true }
// ]
console.log(
  'Insufficient balance for transfer. ' +
    `Needed ${decoded.required.toString()} but only ` +
    `${decoded.available.toString()} available.`
)
// Insufficient balance for transfer. Needed 4294967296 but only 256 available.
</code></pre></div></div>

<p><br /></p>

<h2 id="주의점">주의점</h2>

<p>스마트 컨트랙트를 컴파일해서 ABI 형태의 JSON 파일로 만드는 과정에서, 컴파일러는 해당 스마트 컨트랙트가 나타낼 수 있는(emit) 모든 에러를 해당 파일에 포함시킨다. 여기서 중요한 것은 이 과정에 <u>external call로 호출되는 에러 메시지들은 포함되지 않는다</u>는 것이다. 
이러한 이유로 개발자들은 에러 마다 <a href="https://docs.soliditylang.org/en/latest/natspec-format.html?color=dark">NatSpec</a> 형식을 준수하는 설명을 달아놓기도 한다. NatSpec은 개발자와 사용자가 추가 비용없이 에러 메시지에 대해 서로 이해할 수 있도록 하는 좋은 방법 중 하나이다.</p>

<p>어쨋든 에러 메시지의 출처를 추적할 수 없기 때문에, 에러 데이터는 신중하게 사용해야 한다. external call 호출 횟수가 계속 늘어날수록, 발생하는 에러 메시지가 어디서부터 온 것인지 추적하기 점점 어려워진다는 것을 의미한다. 게다가 실제 에러가 아님에도 불구하고 에러메시지(처럼 보이는 문구)를 호출하도록 악의적으로 스마트 컨트랙트를 작성할 수도 있다.</p>

<p><br />
<br /></p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://soliditylang.org/blog/2021/04/21/custom-errors/">Custom Errors in Solidity - Soliditylang.org</a></li>
</ul>]]></content><author><name>wonjoon</name></author><category term="개발" /><summary type="html"><![CDATA[How to Use custom error in solditiy for reducing smart contract size and gas price.]]></summary></entry><entry><title type="html">스마트 컨트랙트의 사이즈를 줄이는 방법</title><link href="http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size/" rel="alternate" type="text/html" title="스마트 컨트랙트의 사이즈를 줄이는 방법" /><published>2023-08-21T00:00:00+09:00</published><updated>2023-08-21T00:00:00+09:00</updated><id>http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size</id><content type="html" xml:base="http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size/"><![CDATA[<p><br /></p>

<h2 id="eip-170">EIP-170</h2>

<p><a href="https://eips.ethereum.org/EIPS/eip-170">EIP-170</a>은 2016년 11월 22일에 발생한 하드포크 <a href="https://blog.ethereum.org/2016/11/18/hard-fork-no-4-spurious-dragon">‘Suprious Dragon’</a> 시기에 공개되었으며, DoS(Denial of Service) 공격으로부터 이더리움 네트워크를 보호하기 위해 스마트 컨트랙트의 사이즈를 24,576kb로 제한하는 규칙을 제안한 내용이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If block.number &gt;= FORK_BLKNUM, then if contract creation initialization returns data with length of more than MAX_CODE_SIZE bytes, contract creation fails with an out of gas error.

- MAX_CODE_SIZE: 0x6000 (2**14 + 2**13)
- FORK_BLKNUM: 2,675,000
- CHAIN_ID: 1 (Mainnet)
</code></pre></div></div>

<p>이더리움 네트워크에서는 잠재적으로 최소 2번의 O(n) 만큼 가스가 사용될 수 있다.</p>
<ol>
  <li>디스크에서 읽어온 스마트 컨트랙트에 대한 코드를 VM 환경에서 실행하기 위해 전처리하는 과정에서 O(n)</li>
  <li>블록의 유효성 증명을 위해 데이터를 머클 증명에 추가하는 과정의 O(n)</li>
</ol>

<p>이를 이더리움에서는 2차 취약점(Quadratic Vulnerability) 이라고 언급하는데, 결국 스마트 컨트랙트 자체의 크기로 인하여 트랜잭션 처리 성능에 영향을 주는 경우가 발생하게 된다.<br />
그리고 꼭 DoS가 아니더라도 굉장히 간단한 기능만을 사용하려는 사용자의 경우 단순히 <u>스마트 컨트랙트가 길다</u>는 이유만으로 많은 가스비와 시간을 소비해야 할 수도 있게 된다.</p>

<p><br /></p>

<h2 id="스마트-컨트랙트의-사이즈를-확인하는-방법">스마트 컨트랙트의 사이즈를 확인하는 방법</h2>

<p>스마트 컨트랙트 바이트코드의 크기를 확인하려면 <a href="https://github.com/IoBuilders/truffle-contract-size">truffle-contract-size</a>를 사용하면 된다.</p>

<p><br /></p>

<h2 id="단계별로-스마트-컨트랙트의-사이즈를-줄이는-방법">단계별로 스마트 컨트랙트의 사이즈를 줄이는 방법</h2>

<p>본문에서는 3단계로 스마트 컨트랙트의 사이즈를 줄이는 방법을 제시한다.<br />
1단계가 가장 큰 효과를 줄 수 있는(Big impact) 방법이고, 단계가 올라갈수록 소소하게 효과를 줄 수 있는 방법으로 보면 된다.</p>

<h3 id="1-big-impact">1. Big impact</h3>

<h4 id="11-스마트-컨트랙트-분리하기">1.1. 스마트 컨트랙트 분리하기</h4>

<p>스마트 컨트랙트 분리의 첫걸음은 좋은 구조(Good Architecture)로부터 시작한다. 스마트 컨트랙트가 작아질수록 가독성은 높아진다.</p>

<p>스마트 컨트랙트 분리 시 생각해보아야 하는 점들은 아래와 같다.</p>
<ul>
  <li>함께 동작하는 기능들은 모아두는 것이 좋다.</li>
  <li>상태(state)값을 확인 또는 변경하지 않는 기능은 분리해도 좋다.</li>
  <li>스토리지(storage)에 접근하지 않는다면 분리해도 좋다.</li>
</ul>

<h4 id="12-라이브러리-사용하기">1.2. 라이브러리 사용하기</h4>

<p>라이브러리를 사용하면 효율적으로 특정 기능들을 별도의 스마트 컨트랙트로 분리할 수 있다. 라이브러리는 다른 스마트 컨트랙트에서 컴파일 과정에 추가되어 사용되기 때문에 internal로 선언되어서는 안된다.<br />
라이브러리를 사용할 때에는 <a href="https://solidity.readthedocs.io/en/v0.6.10/contracts.html#using-for">using for</a>을 사용한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pragma solidity &gt;=0.6.0 &lt;0.7.0;

struct Data { mapping(uint =&gt; bool) flags; }

library Set {
    function insert(Data storage self, uint value)
        public
        returns (bool)
    {
        if (self.flags[value])
            return false; // already there
        self.flags[value] = true;
        return true;
    }
    ...
}

contract C {
    using Set for Data; // this is the crucial change
    Data knownValues;

    function register(uint value) public {
        require(knownValues.insert(value));
    }
}
</code></pre></div></div>

<blockquote>
  <p>만약 public 함수로 외부에서 직접 사용할 수 있도록 선언하고자 한다면, 별도의 스마트 컨트랙트로 배포하는 것이 옳다.</p>
</blockquote>

<h4 id="13-프록시-적용하기">1.3. 프록시 적용하기</h4>

<p>본문에서는 프록시를 가장 진보한(advanced) 방법이라고 표현하는데, 다른 스마트 컨트랙트의 기능을 통해 본래 스마트 컨트랙트의 상태를 변경하는 delegatecall 호출 방식을 사용한다.<br />
프록시 방법의 대표적인 예가 <a href="https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2">upgradable한 스마트 컨트랙트</a>인데, 단점은 그만큼 코드가 복잡해진다는 것이다.<br />
만약 단순히 스마트 컨트랙트의 사이즈만 줄이기 위해서는 사용을 권장하지 않는다고 한다.</p>

<h3 id="2-medium-impact">2. Medium impact</h3>

<h4 id="21-함수-개수-줄이기">2.1. 함수 개수 줄이기</h4>

<ul>
  <li>External : 편리한 사용성을 위해 우리는 view 함수를 자주 작성하곤 한다. 스마트 컨트랙트 제한 크기 이하라면 전혀 상관이 없다만, 아니라면 가장 필요로하는 한개만 남긴다는 생각으로 함수를 줄이는 것이 좋다.</li>
  <li>Internal : 단발성으로 호출되는 internal 또는 private 함수를 줄이고, 이를 사용하는 함수 내부에 인라인 코드로 작성하자.</li>
</ul>

<h4 id="22-새로운-변수-선언-줄이기">2.2. 새로운 변수 선언 줄이기</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Before
function get(uint id) returns (address,address) {
    MyStruct memory myStruct = myStructs[id];
    return (myStruct.addr1, myStruct.addr2);
}

# After
function get(uint id) returns (address,address) {
    return (myStructs[id].addr1, myStructs[id].addr2);
}
</code></pre></div></div>

<p>별도의 변수를 선언하지 않았을 때, 무려(?) 0.28kb의 크기를 감소시킬 수 있다. 꼭 별도로 선언해야 하는 변수가 아니라면, 선언되어 있는 변수를 재활용하자.</p>

<h4 id="23-짧은-에러메시지">2.3. 짧은 에러메시지</h4>

<p>에러메시지의 길이 또한 스마트 컨트랙트의 크기를 변화시키는 요인이 된다. 에러 상황을 나타낼 때 메시지 보다는 코드를 사용할 것을 권장한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Before
require(msg.sender == owner, "Only the owner of this contract can call this function");

# After
require(msg.sender == owner, "OW1");
</code></pre></div></div>

<h4 id="24-커스텀-에러-사용하기">2.4. 커스텀 에러 사용하기</h4>

<p><a href="https://soliditylang.org/blog/2021/04/21/custom-errors/">솔리디티 0.8.4에서 소개된 커스텀 에러 방식</a>은 스마트 컨트랙트의 사이즈를 줄일 수 있는 꽤나 효과적인 방법이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error Unauthorized();

if (msg.sender != owner) {
    revert Unauthorized();
}
</code></pre></div></div>

<p>위의 방식이 커스텀 에러인데, 이처럼 선언하게 되면 해당 에러가 selector 형식으로 ABI 인코딩된다. 커스텀 에러 안에서도 다양한 방식이 있는데, 추후 포스팅하겠다.</p>

<h4 id="25-optimizer-수정하기">2.5. Optimizer 수정하기</h4>

<p>기본값 200은 것은 함수가 200번 호출될 경우를 대비한 바이트코드의 최적화를 의미한다. 만약 값을 1로 한다면 단일 호출인 경우에 대한 바이트코드 최적화를 의미하게 되는데, 다른 의미로 배포(deployment)를 나타내게 된다.<br />
Optimizer에 사용되는 값이 증가할수록 가스비가 증가하므로, 배포된 이후 해당 컨트랙트를 직접 호출하는 경우가 없다면 값을 최소화하여 적용하는 방안을 고려하는 것을 권장한다.</p>

<h3 id="3-small-impact">3. Small impact</h3>

<h4 id="31-함수-파라미터로-구조체-전달하지-않기">3.1. 함수 파라미터로 구조체 전달하지 않기</h4>

<p>ABIEncoderV2에서는 함수의 파라미터로 구조체를 전달할 수 있다. 편의성은 올라갈 수 있지만 스마트 컨트랙트의 사이즈는 증가한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Passing struct
function get(uint id) returns (address,address) {
    return _get(myStruct);
}

function _get(MyStruct memory myStruct) private view returns(address,address) {
    return (myStruct.addr1, myStruct.addr2);
}

# Passing variables
function get(uint id) returns(address,address) {
    return _get(myStructs[id].addr1, myStructs[id].addr2);
}

function _get(address addr1, address addr2) private view returns(address,address) {
    return (addr1, addr2);
}
</code></pre></div></div>

<p>구조체가 아닌 파라미터를 전달할 경우, 0.1kb의 크기가 차이난다.</p>

<h4 id="32-기능에-맞는-visibility-적용하기">3.2. 기능에 맞는 visibility 적용하기</h4>

<ul>
  <li>함수가 무조건 외부에서만 호출되는 경우 : public</li>
  <li>함수가 다른 스마트 컨트랙트를 통해서만 호출되는 경우 : private 또는 internal</li>
</ul>

<h4 id="33-modifier-삭제하기">3.3. Modifier 삭제하기</h4>

<p>Modifier는 스마트 컨트랙트 사이즈에 큰 영향을 준다. 차라리 함수를 사용할 것을 권장한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Use modifier
modifier checkStuff() {}
function doSomething() checkStuff {}

# Use only functions
function checkStuff() private {}
function doSomething() { checkStuff(); }
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://ethereum.org/en/developers/tutorials/downsizing-contracts-to-fight-the-contract-size-limit/">DOWNSIZING CONTRACTS TO FIGHT THE CONTRACT SIZE LIMIT - ethereum.org</a></li>
</ul>]]></content><author><name>wonjoon</name></author><category term="개발" /><summary type="html"><![CDATA[Introduce post from ethereum official blog about how to reduce smart contract size by serveral ways.]]></summary></entry></feed>