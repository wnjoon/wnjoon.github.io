<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-03-19T19:15:15+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">//TODO: Write Blog</title><subtitle>A (nearly) no-CSS, fast, minimalist Jekyll theme.
</subtitle><author><name>Wonjoon</name></author><entry><title type="html">How macros in Rust work and comparison with C language</title><link href="http://localhost:4000/2025/03/17/rust-macro-compare-c/" rel="alternate" type="text/html" title="How macros in Rust work and comparison with C language" /><published>2025-03-17T00:00:00+09:00</published><updated>2025-03-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/17/rust-macro-compare-c</id><content type="html" xml:base="http://localhost:4000/2025/03/17/rust-macro-compare-c/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#what-are-macros-in-rust">What Are Macros in Rust?</a></li>
  <li><a href="#macros-vs-functions-in-rust">Macros vs. Functions in Rust</a></li>
  <li><a href="#compile-time-vs-runtime-execution">Compile-Time vs. Runtime Execution</a></li>
  <li><a href="#when-should-you-use-macros">When Should You Use Macros?</a></li>
  <li><a href="#when-should-you-use-functions">When Should You Use Functions?</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="what-are-macros-in-rust">What Are Macros in Rust?</h2>

<p>Macros in Rust allow code to be expanded at compile time and included in the final executable.</p>

<p><strong>Rust documentation commonly refers to macros as “expanded” at compile time.</strong></p>

<ul>
  <li>However, this term can be <strong>misleading</strong>.</li>
  <li>The term “expanded” may suggest that the code dynamically changes at runtime. However, Rust macros operate entirely at compile time and do not modify execution at runtime.</li>
  <li>Instead of just being “expanded,” macros generate code, which is then compiled into the final executable.</li>
</ul>

<p>A more precise way to explain macros:</p>

<ul>
  <li>Macros generate code at compile time and include it in the final program.</li>
  <li>Once the executable is compiled, the macro-generated code is “fixed” and cannot change at runtime.</li>
</ul>

<h2 id="macros-vs-functions-in-rust">Macros vs. Functions in Rust</h2>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Macros (macro_rules!)</th>
      <th>Functions (fn)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Code Generation at Compile Time</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Variable Number of Arguments</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Supports Multiple Types</td>
      <td>Yes (via code generation)</td>
      <td>Yes (via generics)</td>
    </tr>
    <tr>
      <td>Performance Optimization</td>
      <td>Yes (no loops, direct code expansion)</td>
      <td>No (loops execute at runtime)</td>
    </tr>
    <tr>
      <td>Readability &amp; Debugging</td>
      <td>Hard to debug</td>
      <td>Easy to debug</td>
    </tr>
  </tbody>
</table>

<h3 id="when-should-you-use-macros">When Should You Use Macros?</h3>

<ul>
  <li>You need compile-time code generation to optimize performance.</li>
  <li>You need to support multiple types dynamically.</li>
  <li>You need variable-length arguments (e.g., <code class="language-plaintext highlighter-rouge">println!</code>).</li>
</ul>

<h3 id="when-should-you-use-functions">When Should You Use Functions?</h3>

<ul>
  <li>You need standard logic implementation.</li>
  <li>You need easier debugging.</li>
  <li>You have repetitive logic that doesn’t require compile-time expansion.</li>
</ul>

<h3 id="macros-are-not-just-about-avoiding-code-repetition">Macros are not just about avoiding code repetition</h3>

<ul>
  <li>If simple repetition is needed, functions are usually a better choice.</li>
  <li>Use macros when you need compile-time optimizations, dynamic argument handling, or complex code generation.</li>
</ul>

<h2 id="compile-time-vs-runtime-execution">Compile-Time vs. Runtime Execution</h2>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Compile Time (Macro Expansion)</th>
      <th>Runtime (Function Execution)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Macros (macro_rules!)</td>
      <td>Code is expanded at compile time</td>
      <td>Never executed directly</td>
    </tr>
    <tr>
      <td>Functions (fn)</td>
      <td>No expansion at compile time</td>
      <td>Executed during runtime</td>
    </tr>
    <tr>
      <td>Error Detection</td>
      <td>Errors occur at compile time</td>
      <td>Errors occur at runtime</td>
    </tr>
  </tbody>
</table>

<h3 id="using-macros-macro_rules">Using Macros (macro_rules!)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">repeat</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$msg:expr</span><span class="p">,</span> <span class="nv">$count:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nv">$msg</span><span class="p">);</span> <span class="p">)</span><span class="o">*</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">repeat!</span><span class="p">(</span><span class="s">"Hello, Rust!"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    
    <span class="c1">// The macro expands into:</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Hello, Rust!"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Hello, Rust!"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Hello, Rust!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The macro expands the <code class="language-plaintext highlighter-rouge">println!</code> calls at compile time, rather than looping at runtime.</li>
  <li>When compiled, the executable already contains three <code class="language-plaintext highlighter-rouge">println!</code> statements, eliminating any need for iteration at runtime.</li>
</ul>

<h3 id="using-functions-fn">Using Functions (fn)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">count</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">repeat</span><span class="p">(</span><span class="s">"Rust is awesome!"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The function executes a loop at runtime instead of unrolling at compile time.</li>
  <li>The compiled binary contains a loop, which adds execution overhead compared to macros.</li>
</ul>

<h2 id="advantages-of-using-macros">Advantages of Using Macros</h2>

<p>Macros expand code at compile time, reducing runtime overhead.</p>

<ul>
  <li>Functions require stack management and runtime execution.</li>
  <li>Macros allow code to be directly inserted into the final program, avoiding function calls.</li>
  <li>For example, match statements inside macros can be expanded into static branching logic, improving performance.</li>
</ul>

<h2 id="why-macros-are-hard-to-debug">Why Macros Are Hard to Debug</h2>

<h3 id="macros-expand-into-new-code-before-compiling">Macros Expand Into New Code Before Compiling</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">bad_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$val</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"True"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"False"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">bad_macro!</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>  <span class="c1">// error</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The macro expands before compilation, replacing <code class="language-plaintext highlighter-rouge">bad_macro!(42)</code>; with:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="mi">42</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"True"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"False"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But if 42 is not valid in Rust -&gt; this causes a type mismatch.</p>

<p>Rust’s error message points to the expanded code, not the macro definition:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0308]: mismatched types
 <span class="nt">--</span><span class="o">&gt;</span> src/main.rs:9:5
  |
9 |     bad_macro!<span class="o">(</span>42<span class="o">)</span><span class="p">;</span>
  |     ^^^^^^^^^^^^^ expected <span class="sb">`</span>bool<span class="sb">`</span>, found integer
  |
  <span class="o">=</span> note: expected <span class="nb">type</span> <span class="sb">`</span>bool<span class="sb">`</span>
             found <span class="nb">type</span> <span class="sb">`</span><span class="o">{</span>integer<span class="o">}</span><span class="sb">`</span>
</code></pre></div></div>

<p>Rust does not indicate that the error originated inside <code class="language-plaintext highlighter-rouge">bad_macro!</code>.
Instead, it shows an error where the macro was expanded, making debugging more difficult.</p>

<h3 id="debugging-logs-are-limited">Debugging Logs Are Limited</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">debug_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nv">$val</span> <span class="o">/</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Runtime error</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">debug_macro!</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This macro expands before compilation, meaning <code class="language-plaintext highlighter-rouge">let result = 10 / 0;</code> is inserted directly.</li>
  <li>Rust won’t warn about division by zero at compile time, but it crashes at runtime.</li>
  <li>Debugging is difficult because Rust does not pinpoint where inside the macro the issue originated.</li>
</ul>

<h3 id="how-to-debug-macros">How to Debug Macros?</h3>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo <span class="nb">install </span>cargo-expand
cargo <span class="nb">expand</span>
</code></pre></div></div>

<ul>
  <li>Use <code class="language-plaintext highlighter-rouge">cargo expand</code> to view the expanded macro output</li>
</ul>

<h2 id="comparison-with-c-macros">Comparison with C Macros</h2>

<p>Although C and Rust are both compiled languages, Rust macros provide safer and more structured compile-time code generation.</p>

<h3 id="define">#define</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define SQUARE(x) (x * x)
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">SQUARE</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// Expands to: (5 * 5)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>C macros are text replacements, not structured code transformations.</li>
  <li>They lack type checking and can introduce subtle bugs.</li>
  <li>Rust macros, in contrast, operate within the compiler and ensure type safety.</li>
</ul>

<h3 id="inline-functions">inline Functions</h3>

<h4 id="comparison-with-rust-macros">Comparison with Rust Macros</h4>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>C inline Function</th>
      <th>Rust Macro (macro_rules!)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Compile-Time Expansion</td>
      <td>Compiler decides whether to inline</td>
      <td>Always expands at compile time</td>
    </tr>
    <tr>
      <td>Guaranteed Optimization</td>
      <td>Not always inlined</td>
      <td>Always replaces code directly</td>
    </tr>
    <tr>
      <td>Code Size Consideration</td>
      <td>Large functions may not be inlined</td>
      <td>Can increase code size</td>
    </tr>
    <tr>
      <td>Flexibility</td>
      <td>Works with fixed types</td>
      <td>Works with multiple types and patterns</td>
    </tr>
  </tbody>
</table>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Compilers may choose not to inline functions for performance reasons.</li>
  <li>Large or recursive functions will not be inlined.</li>
  <li>Rust macros, in contrast, always expand before compilation.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p><strong>When to Use Rust Macros?</strong></p>

<ul>
  <li>You need compile-time code generation for performance.</li>
  <li>You need flexible, generic behavior across multiple types.</li>
  <li>You need variadic arguments (e.g., <code class="language-plaintext highlighter-rouge">println!</code>).</li>
</ul>

<p><strong>When to Avoid Rust Macros?</strong></p>

<ul>
  <li>You need easier debugging -&gt; Functions are better.</li>
  <li>You don’t need compile-time code transformation -&gt; Functions work fine.</li>
  <li>Your macro logic is too complex -&gt; Hard to maintain.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="rust" /><summary type="html"><![CDATA[Macros in Rust allow code to be expanded at compile time and included in the final executable.]]></summary></entry><entry><title type="html">Understanding inline Functions in C: When and How They Work</title><link href="http://localhost:4000/2025/03/17/inline-function-c/" rel="alternate" type="text/html" title="Understanding inline Functions in C: When and How They Work" /><published>2025-03-17T00:00:00+09:00</published><updated>2025-03-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/17/inline-function-c</id><content type="html" xml:base="http://localhost:4000/2025/03/17/inline-function-c/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#what-is-an-inline-function-in-c">What Is an inline Function in C?</a></li>
  <li><a href="#why-use-inline-functions">Why Use inline Functions?</a></li>
  <li><a href="#when-does-the-compiler-ignore-inline">When Does the Compiler Ignore inline?</a></li>
  <li><a href="#forcing-the-compiler-to-inline-a-function">Forcing the Compiler to Inline a Function</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="what-is-an-inline-function-in-c">What Is an inline Function in C?</h2>

<p>An <code class="language-plaintext highlighter-rouge">inline</code> function is a special function in C that suggests the compiler replace the function call with its actual code to optimize performance.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// Expands to: int result = (5 * 5);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>When the compiler processes <code class="language-plaintext highlighter-rouge">square(5)</code>, it replaces the function call with its definition: <code class="language-plaintext highlighter-rouge">int result = (5 * 5);</code></li>
  <li>This eliminates the overhead of function calls, potentially improving performance.</li>
</ul>

<h2 id="why-use-inline-functions">Why Use inline Functions?</h2>

<ul>
  <li>Performance Optimization – Reduces function call overhead.</li>
  <li>Encapsulation – Keeps function logic organized while avoiding extra calls.</li>
  <li>Reduced Stack Usage – No need to store function call metadata in the stack.</li>
</ul>

<h2 id="when-does-the-compiler-ignore-inline">When Does the Compiler Ignore inline?</h2>

<p>However, unlike Rust macros, inline in C is just a hint to the compiler—it does not guarantee inlining. The compiler decides whether to actually inline the function based on various optimization criteria.</p>

<p>Despite marking a function as inline, the compiler might not inline it in the following cases:</p>

<h3 id="1️-the-function-is-too-large">1️. The Function Is Too Large</h3>

<p>If a function contains too many instructions, inlining it could increase code size unnecessarily.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">big_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Large loop</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Expanding this function in multiple places increases binary size.</li>
  <li>Too much code duplication can harm performance rather than improve it.</li>
  <li>The compiler might keep it as a regular function instead.</li>
</ul>

<h3 id="2-recursive-functions">2. Recursive Functions</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Recursive call</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Inlining a recursive function is impossible in most cases because the function keeps calling itself.</li>
  <li>The compiler would need to unroll the recursion into a loop, which is not always feasible.</li>
  <li>If recursion depth is small and known in advance, consider manual loop unrolling instead.</li>
</ul>

<h3 id="3-function-pointers-prevent-inlining">3. Function Pointers Prevent Inlining</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span> <span class="c1">// Assign function to pointer</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">func_ptr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>     <span class="c1">// Compiler does not know function at compile time</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>When using function pointers, the actual function call is determined at runtime, not at compile time.</li>
  <li>The compiler cannot replace function calls with direct code expansion because the target function is unknown during compilation.</li>
  <li>Use direct function calls instead of function pointers when inlining is critical.</li>
</ul>

<h2 id="forcing-the-compiler-to-inline-a-function">Forcing the Compiler to Inline a Function</h2>

<p>If the compiler ignores inline, you can explicitly force inlining using compiler-specific attributes.</p>

<h3 id="1-gcc--clang-attributealways_inline">1. GCC &amp; Clang: <strong>attribute</strong>((always_inline))</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">))</span> <span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Ensures the function will always be inlined, even if it’s large.</li>
  <li>Only works if optimizations are enabled (-O2 or higher).</li>
  <li>Forcing inlining on a large function can increase binary size and reduce cache efficiency.</li>
</ul>

<h3 id="2-msvc-microsoft-compiler-__forceinline">2. MSVC (Microsoft Compiler): __forceinline</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__forceinline</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Forces the function to be inlined in Microsoft compilers (MSVC).</li>
  <li>Ensures consistent inlining behavior across different builds.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Use inline for:</p>

<ul>
  <li>Small, frequently used functions.</li>
  <li>Performance-sensitive calculations (e.g., mathematical operations).</li>
  <li>Functions that replace macros for better type safety.</li>
</ul>

<p>Avoid inline for:</p>

<ul>
  <li>Large functions (can increase binary size).</li>
  <li>Recursive functions.</li>
  <li>Functions used with pointers or virtual functions (C++).</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="c" /><summary type="html"><![CDATA[inline functions in C allow code to be expanded at compile time and included in the final executable.]]></summary></entry><entry><title type="html">defer in Go Doesn’t Always Reflect the Latest Value</title><link href="http://localhost:4000/2025/03/14/go-defer-value/" rel="alternate" type="text/html" title="defer in Go Doesn’t Always Reflect the Latest Value" /><published>2025-03-14T00:00:00+09:00</published><updated>2025-03-14T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/14/go-defer-value</id><content type="html" xml:base="http://localhost:4000/2025/03/14/go-defer-value/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#the-problem">The Problem</a></li>
  <li><a href="#the-reason-why-status-is-not-updated">The Reason why status is not updated</a></li>
  <li><a href="#how-to-fix-it">How to Fix It?</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="the-problem">The Problem</h2>

<p>Consider the following Go function:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">status</span> <span class="kt">string</span>  <span class="c">// Initialized as an empty string</span>
    <span class="k">defer</span> <span class="n">notify</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">foo</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s">"error"</span>  <span class="c">// Status changes here, but defer does not reflect this change</span>
        <span class="k">return</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">status</span> <span class="o">=</span> <span class="s">"success"</span>
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We might expect notify(status) to reflect the latest value of status.
However, in reality, it always receives an empty string (<code class="language-plaintext highlighter-rouge">""</code>), regardless of how status is updated later.</p>

<h2 id="the-reason-why-status-is-not-updated">The Reason why status is not updated</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">status</span> <span class="kt">string</span> <span class="c">// ""</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">status</code> is initialized as an empty string</li>
  <li><code class="language-plaintext highlighter-rouge">defer</code> evaluates its arguments immediately when declared.
    <ul>
      <li>When <code class="language-plaintext highlighter-rouge">defer notify(status)</code> is called, <code class="language-plaintext highlighter-rouge">status</code> is still an empty string.</li>
      <li>Thus, <code class="language-plaintext highlighter-rouge">defer</code> captures the empty string(<code class="language-plaintext highlighter-rouge">""</code>) at this moment and never updates, even if <code class="language-plaintext highlighter-rouge">status</code> changes later.</li>
    </ul>
  </li>
  <li>Even though <code class="language-plaintext highlighter-rouge">status</code> is modified in the function, the deferred function call was already bound to the original value of <code class="language-plaintext highlighter-rouge">status</code> (empty string).</li>
  <li>In Go, when a function is deferred, its arguments are evaluated and stored immediately—not when the function actually executes.</li>
</ul>

<h2 id="how-to-fix-it">How to Fix It?</h2>

<p>To ensure that notify(status) receives the latest value of status, we can use two different approaches.</p>

<h3 id="1-using-a-closure-anonymous-function">1. Using a Closure (Anonymous Function)</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">notify</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">}()</span>
</code></pre></div></div>

<ul>
  <li>Instead of immediately passing <code class="language-plaintext highlighter-rouge">status</code> to <code class="language-plaintext highlighter-rouge">notify</code>, we defer an anonymous function.</li>
  <li>This function captures <code class="language-plaintext highlighter-rouge">status</code> at the moment <code class="language-plaintext highlighter-rouge">defer</code> executes, ensuring it reflects the latest value.</li>
  <li>When <code class="language-plaintext highlighter-rouge">notify(status)</code> is finally called, it uses the updated value of <code class="language-plaintext highlighter-rouge">status</code>.</li>
</ul>

<h3 id="2-passing-a-pointer">2. Passing a Pointer</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defer</span> <span class="n">notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Instead of passing the value of <code class="language-plaintext highlighter-rouge">status</code>, we pass its memory address (<code class="language-plaintext highlighter-rouge">&amp;status</code>).</li>
  <li>Since <code class="language-plaintext highlighter-rouge">defer</code> captures the pointer, any changes to <code class="language-plaintext highlighter-rouge">status</code> are reflected at execution time.</li>
  <li>However, this requires modifying <code class="language-plaintext highlighter-rouge">notify</code> to accept a pointer parameter.</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// If using a pointer, notify must be updated:</span>
<span class="c">// Dereference the pointer to get the latest value</span>
<span class="k">func</span> <span class="n">notify</span><span class="p">(</span><span class="n">status</span> <span class="o">*</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">)</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3-comparison-of-solutions">3. Comparison of Solutions</h3>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th>How it Works</th>
      <th>Requires Function Signature Change?</th>
      <th>Best Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Closure (Anonymous Function)</td>
      <td>Captures <code class="language-plaintext highlighter-rouge">status</code> at execution time</td>
      <td>No</td>
      <td>Works for most cases</td>
    </tr>
    <tr>
      <td>Pointer Passing (&amp;status)</td>
      <td>Passes a pointer, reflects latest value</td>
      <td>Yes</td>
      <td>When working with functions that support pointers</td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>Deferred functions capture arguments immediately, not when they actually run.</li>
  <li>If the deferred function needs the latest value, use:
    <ul>
      <li>Closures (Anonymous Functions): Recommended, as they don’t require modifying function signatures.</li>
      <li>Pointers (&amp;status): Useful when modifying function behavior explicitly.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="go" /><summary type="html"><![CDATA[In Go, Deferred functions capture arguments immediately, not when they actually run.]]></summary></entry><entry><title type="html">Using sync.Cond for Goroutine Synchronization in Go</title><link href="http://localhost:4000/2025/03/13/go-sync-cond/" rel="alternate" type="text/html" title="Using sync.Cond for Goroutine Synchronization in Go" /><published>2025-03-13T00:00:00+09:00</published><updated>2025-03-13T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/13/go-sync-cond</id><content type="html" xml:base="http://localhost:4000/2025/03/13/go-sync-cond/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#what-is-synccond">What is <code class="language-plaintext highlighter-rouge">sync.Cond</code>?</a></li>
  <li><a href="#how-synccond-works">How <code class="language-plaintext highlighter-rouge">sync.Cond</code> Works</a></li>
  <li><a href="#example-donation-goal-tracker-using-synccond">Example: Donation Goal Tracker Using <code class="language-plaintext highlighter-rouge">sync.Cond</code></a></li>
  <li><a href="#comparison-signal-vs-broadcast">Comparison: <code class="language-plaintext highlighter-rouge">Signal()</code> vs. <code class="language-plaintext highlighter-rouge">Broadcast()</code></a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="what-is-synccond">What is sync.Cond?</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> is a condition variable that helps synchronize multiple goroutines.</li>
  <li>It is typically used when one or more goroutines must wait until a shared resource reaches a specific state.</li>
  <li>One goroutine waits (<code class="language-plaintext highlighter-rouge">Wait()</code>) until a condition is satisfied, and another goroutine notifies (<code class="language-plaintext highlighter-rouge">Signal()</code> or <code class="language-plaintext highlighter-rouge">Broadcast()</code>) the waiting goroutines when the condition is met.</li>
</ul>

<h2 id="how-synccond-works">How sync.Cond Works</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Wait()</code></td>
      <td>Makes a goroutine wait until a condition is met (automatically unlocks the mutex)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Signal()</code></td>
      <td>Wakes only one waiting goroutine (even if multiple goroutines are waiting)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Broadcast()</code></td>
      <td>Wakes all waiting goroutines</td>
    </tr>
  </tbody>
</table>

<h2 id="example-donation-goal-tracker-using-synccond">Example: Donation Goal Tracker Using sync.Cond</h2>

<p>The following example demonstrates how <code class="language-plaintext highlighter-rouge">sync.Cond</code> can be used to coordinate multiple goroutines that monitor a donation goal.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Donation</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">cond</span>    <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span> <span class="c">// Condition variable</span>
    <span class="n">balance</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">donation</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Donation</span><span class="p">{</span>
        <span class="n">cond</span><span class="o">:</span> <span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{}),</span> <span class="c">// Create a condition variable with a mutex</span>
    <span class="p">}</span>

    <span class="c">// Listener goroutine (checks if goal is reached)</span>
    <span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">// Acquire mutex lock</span>
        <span class="k">for</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="n">goal</span> <span class="p">{</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait until balance &gt;= goal</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="p">)</span>
        <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">// Release mutex lock</span>
    <span class="p">}</span>

    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">15</span><span class="p">)</span>

    <span class="c">// Updater goroutine (increments balance)</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="o">++</span> <span class="c">// Increase balance</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span> <span class="c">// Wake all waiting goroutines</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">20</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Keep program running</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="step-1-creating-a-synccond-object">Step 1: Creating a sync.Cond Object</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Donation</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">cond</span>    <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span>  
    <span class="n">balance</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="n">donation</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Donation</span><span class="p">{</span>
    <span class="n">cond</span><span class="o">:</span> <span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{}),</span> 
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">cond</code>: A condition variable based on <code class="language-plaintext highlighter-rouge">sync.Mutex</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> provides synchronization between multiple goroutines using <code class="language-plaintext highlighter-rouge">Wait()</code>, <code class="language-plaintext highlighter-rouge">Signal()</code>, and <code class="language-plaintext highlighter-rouge">Broadcast()</code>.</li>
</ul>

<h3 id="step-2-listener-goroutine-fgoal-int">Step 2: Listener Goroutine (<code class="language-plaintext highlighter-rouge">f(goal int)</code>)</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>  
    <span class="k">for</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="n">goal</span> <span class="p">{</span>
        <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait until condition is met</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="p">)</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>How It Works:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">donation.cond.L.Lock()</code>: Acquires mutex lock before checking <code class="language-plaintext highlighter-rouge">donation.balance</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">for donation.balance &lt; goal</code>: Checks if goal is reached.</li>
  <li><code class="language-plaintext highlighter-rouge">donation.cond.Wait()</code>:
    <ul>
      <li>Pauses execution until another goroutine calls <code class="language-plaintext highlighter-rouge">Signal()</code> or <code class="language-plaintext highlighter-rouge">Broadcast()</code>.</li>
      <li>Automatically releases the mutex lock while waiting.</li>
    </ul>
  </li>
  <li>Once woken up, the goroutine resumes execution, prints the message, and releases the lock (<code class="language-plaintext highlighter-rouge">L.Unlock()</code>).</li>
</ol>

<h3 id="step-3-updater-goroutine">Step 3: Updater Goroutine</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">{</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="o">++</span>      
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>How It Works:</p>

<ol>
  <li>Acquires the lock (<code class="language-plaintext highlighter-rouge">donation.cond.L.Lock()</code>).</li>
  <li>Increments the balance every second (<code class="language-plaintext highlighter-rouge">donation.balance++</code>).</li>
  <li>Releases the lock (<code class="language-plaintext highlighter-rouge">donation.cond.L.Unlock()</code>).</li>
  <li>Calls <code class="language-plaintext highlighter-rouge">donation.cond.Broadcast()</code>:
    <ul>
      <li>Wakes up all waiting goroutines.</li>
      <li>Each waiting goroutine checks if its goal is met and either continues waiting or exits.</li>
    </ul>
  </li>
</ol>

<h3 id="overall-execution-flow">Overall Execution Flow</h3>

<table>
  <thead>
    <tr>
      <th><strong>Step</strong></th>
      <th><strong>Active Goroutine(s)</strong></th>
      <th><strong>Balance</strong></th>
      <th><strong>After Broadcast()</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>f(10), f(15) (waiting)</td>
      <td>0</td>
      <td>Still waiting</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Updater goroutine</td>
      <td>1 -&gt; 9</td>
      <td>Still waiting</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Updater goroutine</td>
      <td>10</td>
      <td>f(10) wakes up and exits</td>
    </tr>
    <tr>
      <td>4</td>
      <td>f(15) (still waiting)</td>
      <td>11 -&gt; 14</td>
      <td>Still waiting</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Updater goroutine</td>
      <td>15</td>
      <td>f(15) wakes up and exits</td>
    </tr>
  </tbody>
</table>

<p>Key Observations:</p>

<ul>
  <li>Each time balance increases, <code class="language-plaintext highlighter-rouge">Broadcast()</code> wakes all waiting goroutines.</li>
  <li>If a goroutine’s goal is not met, it goes back to <code class="language-plaintext highlighter-rouge">Wait()</code>.</li>
  <li>If a goroutine’s goal is met, it exits after printing the result.</li>
  <li>Once all goals are reached, no goroutines are waiting, so <code class="language-plaintext highlighter-rouge">Broadcast()</code> no longer has any effect.</li>
</ul>

<h2 id="comparison-signal-vs-broadcast">Comparison: Signal() vs. Broadcast()</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Behavior</strong></th>
      <th><strong>Use Case</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Wait()</code></td>
      <td>Makes a goroutine wait until a condition is met (automatically unlocks the mutex)</td>
      <td>Used when waiting for a condition</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Signal()</code></td>
      <td>Wakes only one waiting goroutine (even if multiple goroutines are waiting)</td>
      <td>Use when a single goroutine should proceed</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Broadcast()</code></td>
      <td>Wakes all waiting goroutines</td>
      <td>Use when all goroutines should be notified</td>
    </tr>
  </tbody>
</table>

<p>When to Use <code class="language-plaintext highlighter-rouge">Signal()</code> vs. <code class="language-plaintext highlighter-rouge">Broadcast()</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Signal()</code>: Use when only one goroutine needs to proceed.</li>
  <li><code class="language-plaintext highlighter-rouge">Broadcast()</code>: Use when all waiting goroutines should be notified (e.g., donation.balance updates).</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> helps synchronize multiple goroutines by allowing them to wait for a condition to be met.</li>
  <li><code class="language-plaintext highlighter-rouge">Wait()</code> makes goroutines wait, while <code class="language-plaintext highlighter-rouge">Signal()</code> and <code class="language-plaintext highlighter-rouge">Broadcast()</code> notify them.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">Broadcast()</code> when all waiting goroutines should proceed, and use <code class="language-plaintext highlighter-rouge">Signal()</code> when only one goroutine should continue.</li>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> is useful for implementing event-based synchronization, such as resource availability or state changes.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="go" /><summary type="html"><![CDATA[In Go, sync.Cond is a synchronization primitive that allows goroutines to efficiently wait until a certain condition is met. It helps coordinate multiple goroutines by providing a mechanism to wait (Wait()) and notify (Signal() or Broadcast()) when conditions change.]]></summary></entry><entry><title type="html">Understanding GasKVStore in Cosmos SDK</title><link href="http://localhost:4000/2025/03/12/cosmos-sdk-gaskvstore/" rel="alternate" type="text/html" title="Understanding GasKVStore in Cosmos SDK" /><published>2025-03-12T00:00:00+09:00</published><updated>2025-03-12T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/12/cosmos-sdk-gaskvstore</id><content type="html" xml:base="http://localhost:4000/2025/03/12/cosmos-sdk-gaskvstore/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#overview-of-gaskvstore">Overview of GasKVStore</a></li>
  <li><a href="#core-methods-of-gaskvstore">Core Methods of GasKVStore</a></li>
  <li><a href="#gas-consumption-based-on-key-and-value-size">Gas Consumption Based on Key and Value Size</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="overview-of-gaskvstore">Overview of GasKVStore</h2>

<p>GasKVStore measures gas usage in real-time as internal field values change during transaction execution.
Each read, write, and delete operation is designed to consume gas, ensuring that gas limits are properly enforced.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Store applies gas tracking to an underlying KVStore. It implements the KVStore interface.</span>
<span class="k">type</span> <span class="n">Store</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">gasMeter</span>  <span class="n">types</span><span class="o">.</span><span class="n">GasMeter</span>   <span class="c">// GasMeter that tracks gas usage during transactions</span>
    <span class="n">gasConfig</span> <span class="n">types</span><span class="o">.</span><span class="n">GasConfig</span>  <span class="c">// Configuration for gas costs of read/write/delete operations</span>
    <span class="n">parent</span>    <span class="n">types</span><span class="o">.</span><span class="n">KVStore</span>    <span class="c">// The underlying KVStore that stores actual data</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="core-methods-of-gaskvstore">Core Methods of GasKVStore</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Functionality</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Get(key)</td>
      <td>Reads the value of a given key and consumes gas proportional to the key size</td>
    </tr>
    <tr>
      <td>Set(key, value)</td>
      <td>Stores a value for a given key and consumes gas based on both key and value size</td>
    </tr>
    <tr>
      <td>Delete(key)</td>
      <td>Deletes a key-value pair and consumes a fixed amount of gas</td>
    </tr>
  </tbody>
</table>

<h3 id="1-getkey---read-operation">1. Get(key) - Read Operation</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">GasKVStore</span><span class="p">)</span> <span class="n">Get</span><span class="p">(</span><span class="n">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="n">g</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">ConsumeGas</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">gasConfig</span><span class="o">.</span><span class="n">ReadCostPerByte</span> <span class="o">*</span> <span class="kt">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)),</span> <span class="s">"Read"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This function retrieves the value associated with a key.</li>
  <li>It is similar to searching for a word in a book.</li>
  <li>The function fetches and returns the data stored in the parent KVStore.</li>
</ul>

<h3 id="2-setkey-value---write-operation">2. Set(key, value) - Write Operation</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">GasKVStore</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gasToConsume</span> <span class="o">:=</span> <span class="n">g</span><span class="o">.</span><span class="n">gasConfig</span><span class="o">.</span><span class="n">WriteCostPerByte</span> <span class="o">*</span> <span class="kt">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
    <span class="n">g</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">ConsumeGas</span><span class="p">(</span><span class="n">gasToConsume</span><span class="p">,</span> <span class="s">"Write"</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This function stores a new value for a given key.</li>
  <li>It works like adding new content to a book.</li>
  <li>The function records or updates data in the parent KVStore.</li>
</ul>

<h3 id="3-deletekey---delete-operation">3. Delete(key) - Delete Operation</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">GasKVStore</span><span class="p">)</span> <span class="n">Delete</span><span class="p">(</span><span class="n">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">ConsumeGas</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">gasConfig</span><span class="o">.</span><span class="n">DeleteCost</span><span class="p">,</span> <span class="s">"Delete"</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This function removes the data associated with a given key.</li>
  <li>It is similar to erasing a word from a book.</li>
  <li>The function deletes data stored in the parent KVStore.</li>
</ul>

<h2 id="gas-consumption-based-on-key-and-value-size">Gas Consumption Based on Key and Value Size</h2>

<p>Some methods in GasKVStore consume gas in proportion to the size of the key and value.
While gas in blockchain systems is often associated with CPU execution costs, the Cosmos SDK includes storage access costs as well.
Thus, the size of the key affects gas consumption.</p>

<h3 id="what-is-a-key">What is a Key?</h3>

<p>A key is an address that identifies a specific state in the blockchain.
It serves as an identifier for a specific data entry managed by a module.</p>

<p>Here are some examples:</p>

<h4 id="1-bank-module-storing-account-balances">1. Bank module storing account balances</h4>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="s">"balances/&lt;account_address&gt;"</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"&lt;account_balance&gt;"</span>
</code></pre></div></div>

<h4 id="2-staking-module-storing-validator-information">2. Staking module storing validator information</h4>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="s">"validators/&lt;validator_address&gt;"</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"&lt;validator_info&gt;"</span>
</code></pre></div></div>

<h4 id="3-ibc-module-storing-channel-information">3. IBC module storing channel information</h4>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="s">"ibc/ports/&lt;port_id&gt;/channels/&lt;channel_id&gt;"</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"&lt;channel_info&gt;"</span>
</code></pre></div></div>

<h3 id="why-key-size-affects-gas-consumption">Why Key Size Affects Gas Consumption?</h3>

<ul>
  <li>In the Cosmos SDK, gas is not only used for computation but also for storage access.</li>
  <li>Since accessing a key-value store (KVStore) consumes gas, larger keys and values require more gas.</li>
  <li>The longer the key, the more resources are needed to retrieve and store it, resulting in higher gas costs.</li>
</ul>

<h3 id="gas-consumption-per-method">Gas Consumption per Method</h3>

<table>
  <thead>
    <tr>
      <th><strong>Operation</strong></th>
      <th><strong>Function</strong></th>
      <th><strong>Gas Consumption Criteria</strong></th>
      <th><strong>Gas Consumption Amount</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Get(key)</td>
      <td>Reads the value of a key</td>
      <td>Proportional to key size</td>
      <td>Low</td>
    </tr>
    <tr>
      <td>Set(key, value)</td>
      <td>Stores a new value for a key</td>
      <td>Proportional to key + value size</td>
      <td>High</td>
    </tr>
    <tr>
      <td>Delete(key)</td>
      <td>Deletes a key-value pair</td>
      <td>Fixed cost (DeleteCost)</td>
      <td>Medium</td>
    </tr>
  </tbody>
</table>

<h4 id="1-getkey---gas-consumption-for-reads">1. Get(key) - Gas Consumption for Reads</h4>

<p>Gas is consumed in proportion to the key size since retrieving a value requires locating the key in storage.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Example: Retrieving an account balance from the bank module</span>
<span class="n">store</span> <span class="o">:=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">KVStore</span><span class="p">(</span><span class="n">bankStoreKey</span><span class="p">)</span>
<span class="n">balanceKey</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"balances/cosmos1xyz..."</span><span class="p">)</span>  <span class="c">// Using account address as key</span>
<span class="n">balance</span> <span class="o">:=</span> <span class="n">store</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">balanceKey</span><span class="p">)</span>  <span class="c">// Gas is consumed here</span>
</code></pre></div></div>

<h4 id="2-setkey-value---gas-consumption-for-writes">2. Set(key, value) - Gas Consumption for Writes</h4>

<p>Gas is consumed in proportion to the sum of key and value sizes since writing new data requires additional storage resources.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Example: Storing validator information</span>
<span class="n">store</span> <span class="o">:=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">KVStore</span><span class="p">(</span><span class="n">stakingStoreKey</span><span class="p">)</span>
<span class="n">validatorKey</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"validators/valoper1abc..."</span><span class="p">)</span>  
<span class="n">validatorInfo</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"{status: active, power: 1000}"</span><span class="p">)</span>  
<span class="n">store</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">validatorKey</span><span class="p">,</span> <span class="n">validatorInfo</span><span class="p">)</span>  <span class="c">// Gas is consumed here</span>
</code></pre></div></div>

<p>Steps:</p>

<ol>
  <li>Locate the key “validators/valoper1abc…” in storage (or create a new entry if it does not exist).</li>
  <li>Store the value “{status: active, power: 1000}”.</li>
  <li>Consume gas proportional to the size of both the key and value.</li>
</ol>

<h4 id="3-deletekey---gas-consumption-for-deletes">3. Delete(key) - Gas Consumption for Deletes</h4>

<p>Gas consumption is fixed (DeleteCost), independent of key size.</p>

<p><em>Why is deletion a fixed-cost operation?</em></p>

<ul>
  <li>Deleting is a simple operation
    <ul>
      <li>Writing new data (Set) modifies storage, while deleting data (Delete) simply marks it as removed.</li>
    </ul>
  </li>
  <li>Deletion can be faster than retrieval
    <ul>
      <li>Get(key) requires searching for a key, meaning longer keys take longer to process.</li>
      <li>Delete(key) usually marks data as deleted, which is computationally simpler.</li>
    </ul>
  </li>
  <li>Merkle Tree Structure
    <ul>
      <li>The Cosmos SDK uses a Merkle Tree-based IAVL Store, where deletions primarily mark nodes as invalid rather than requiring extensive modifications.</li>
      <li>As a result, gas does not need to scale with key size.</li>
    </ul>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>GasKVStore ensures real-time tracking of gas consumption during transaction execution, preventing gas limit violations.</li>
  <li>Gas is consumed not only for CPU operations but also for accessing and modifying storage (KVStore).</li>
  <li>Optimizing key and value sizes can help reduce unnecessary gas costs.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="cosmos-sdk" /><summary type="html"><![CDATA[GasKVStore is a core component of the Cosmos SDK that tracks gas consumption in real-time during transaction execution. It ensures that every read, write, and delete operation consumes gas, helping to prevent transactions from exceeding their gas limits.]]></summary></entry><entry><title type="html">Understanding Channel Iteration in Go: for range vs. select vs. switch</title><link href="http://localhost:4000/2025/03/09/go-channel-iteration/" rel="alternate" type="text/html" title="Understanding Channel Iteration in Go: for range vs. select vs. switch" /><published>2025-03-09T00:00:00+09:00</published><updated>2025-03-09T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/09/go-channel-iteration</id><content type="html" xml:base="http://localhost:4000/2025/03/09/go-channel-iteration/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#code-example-donation-goal-tracker">Code Example: Donation Goal Tracker</a></li>
  <li><a href="#using-for-range-to-read-from-a-channel">Using for range to Read from a Channel</a></li>
  <li><a href="#using-select-to-listen-for-channel-data">Using select to Listen for Channel Data</a></li>
  <li><a href="#comparison-table-for-range-vs-select-vs-switch">Comparison Table: <code class="language-plaintext highlighter-rouge">for range</code> vs. <code class="language-plaintext highlighter-rouge">select</code> vs. <code class="language-plaintext highlighter-rouge">switch</code></a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="code-example-donation-goal-tracker">Code Example: Donation Goal Tracker</h2>

<p>Below is a Go program that tracks donations using channels. Two goroutines (<code class="language-plaintext highlighter-rouge">f(10)</code> and <code class="language-plaintext highlighter-rouge">f(15)</code>) listen for updates on the donation balance, and another goroutine increments the balance every second.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Donation</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">balance</span> <span class="kt">int</span>
    <span class="n">ch</span>      <span class="k">chan</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">donation</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Donation</span><span class="p">{</span><span class="n">ch</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)}</span>

    <span class="c">// Listener Goroutine (Checks if goal amount is reached)</span>
    <span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">balance</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">donation</span><span class="o">.</span><span class="n">ch</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">goal</span> <span class="p">{</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">15</span><span class="p">)</span>

    <span class="c">// Updater Goroutine (Increases balance)</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="o">++</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">25</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Keep the program running</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="using-for-range-to-read-from-a-channel">Using for range to Read from a Channel</h2>

<p>This is same as the previous example, but written in a more concise way.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">balance</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">donation</span><span class="o">.</span><span class="n">ch</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">goal</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="how-for-range-works">How for range Works</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">range donation.ch</code>: Iterates over incoming values from the channel.</li>
  <li>Each time a new value is sent to <code class="language-plaintext highlighter-rouge">donation.ch</code>, it is immediately read and assigned to <code class="language-plaintext highlighter-rouge">balance</code>.</li>
  <li>The loop continues waiting for new values until the channel is closed.</li>
</ul>

<h3 id="key-characteristics-of-for-range">Key Characteristics of for range</h3>

<ul>
  <li>Automatically waits for new values.</li>
  <li>Stops when the channel is closed.</li>
  <li>Simple and efficient for single-channel reading.</li>
</ul>

<h2 id="using-select-to-listen-for-channel-data">Using select to Listen for Channel Data</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">balance</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">donation</span><span class="o">.</span><span class="n">ch</span><span class="o">:</span> <span class="c">// Process incoming value</span>
            <span class="k">if</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">goal</span> <span class="p">{</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="how-select-works">How select Works</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">case balance := &lt;-donation.ch</code>: Reads from the channel only when data is available.</li>
  <li>Useful when monitoring multiple channels simultaneously.</li>
  <li>Requires an explicit return or break to exit the loop.</li>
</ul>

<h3 id="key-characteristics-of-select">Key Characteristics of select</h3>

<ul>
  <li>Can handle multiple channels.</li>
  <li>Only executes when a channel has data.</li>
  <li>Requires an explicit exit condition.</li>
</ul>

<h2 id="why-switch-is-not-used">Why switch is Not Used</h2>

<p>A switch statement is not suitable for continuously reading from a channel.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">{</span>
    <span class="n">balance</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">donation</span><span class="o">.</span><span class="n">ch</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">goal</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">default</span><span class="o">:</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problems-with-using-switch">Problems with Using switch</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">balance := &lt;-donation.ch</code>: Directly blocks waiting for a value (inefficient).</li>
  <li><code class="language-plaintext highlighter-rouge">default</code>: Executes unconditionally when no case matches, which prevents proper subscription behavior.</li>
</ul>

<h3 id="key-characteristics-of-switch">Key Characteristics of switch</h3>

<ul>
  <li>Cannot wait for channel updates.</li>
  <li>Inefficient because it forces direct value retrieval.</li>
  <li><code class="language-plaintext highlighter-rouge">default</code> runs even when there’s no new data.</li>
</ul>

<h2 id="comparison-table-for-range-vs-select-vs-switch">Comparison Table: for range vs. select vs. switch</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>How It Works</strong></th>
      <th><strong>Can Monitor Channels?</strong></th>
      <th><strong>Exit Condition</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">for range</code></td>
      <td>Iterates when new values arrive</td>
      <td>Yes</td>
      <td>Automatically stops when the channel is closed</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">select</code></td>
      <td>Handles multiple channels</td>
      <td>Yes</td>
      <td>Requires explicit break or return</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">switch</code></td>
      <td>Simple conditional statement</td>
      <td>No</td>
      <td>Must manually read values</td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>Use <code class="language-plaintext highlighter-rouge">for range</code> when working with a single channel that continuously receives values.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">select</code> when handling multiple channels or managing timeouts.</li>
  <li>Avoid <code class="language-plaintext highlighter-rouge">switch</code> for channel reading, as it lacks proper subscription behavior.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="go" /><summary type="html"><![CDATA[In Go, channels are commonly used for communication between goroutines. This post explores different ways to read from channels and handle incoming values efficiently.]]></summary></entry><entry><title type="html">The Power of Daily Plan</title><link href="http://localhost:4000/2025/03/06/power-of-daily-plan/" rel="alternate" type="text/html" title="The Power of Daily Plan" /><published>2025-03-06T00:00:00+09:00</published><updated>2025-03-06T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/06/power-of-daily-plan</id><content type="html" xml:base="http://localhost:4000/2025/03/06/power-of-daily-plan/"><![CDATA[<h3 id="there-is-a-p-in-my-mbti-result">There is a P in my MBTI result</h3>

<p>In other words, I find it difficult to set clear plans, and I am more accustomed to handling things spontaneously. The reason I use the words “difficult” and “accustomed” is not because I dislike planning or prefer working on impulse.</p>

<p>I don’t know about others with a P-type personality, but at least for me, I want to be more like a J.</p>

<p>Especially in my profession as a developer, having a well-structured plan is often essential for getting work done effectively.</p>

<h3 id="why-planning-matters">Why Planning Matters</h3>

<p>People who have achieved great success in life all have one thing in common: they plan their day before they start.</p>

<p>They don’t do this because they have too much or too little time. Instead, they take a sacred moment to determine the priorities for the day.</p>

<p>I describe it as “sacred” because it is a moment where we acknowledge the natural limitations of time that we, as humans, cannot escape.</p>

<h3 id="the-challenges-of-planning">The Challenges of Planning</h3>

<p>But planning isn’t easy.</p>

<ul>
  <li>Should I be conservative with my plans to avoid failure?</li>
  <li>Or should I set goals based on my ambition to complete everything I want?</li>
  <li>What should I do when unexpected events force me to adjust my plans?</li>
</ul>

<p>Even though I am a P-type, I don’t start my day without any plans at all.
However, I struggle to create detailed plans.
I leave multiple possibilities open for tasks that may change, so it’s hard for me to set a clear, measurable goal for what I will complete.</p>

<h3 id="learning-from-the-best">Learning from the Best</h3>

<p>So, how do highly skilled people approach this?</p>

<p>Someone I deeply admire follows a simple rule:
They plan their day based on the maximum number of hours they can fully focus on work.</p>

<p>Within that time, they prioritize the most important tasks instead of simply listing everything they need to do.</p>

<p>Even though their to-do list was short, they carefully considered the importance and urgency of each task.
This approach made them a smart, efficient, and highly capable worker.</p>

<h3 id="the-importance-of-planning-in-workplaces">The Importance of Planning in Workplaces</h3>

<p>Many IT companies require employees to plan their daily tasks and share them with the team.
However, not all workplaces have such systems in place.</p>

<p>I believe that creating a daily work plan is the single most important task, even if your company doesn’t require it.</p>

<p>This habit offers more than just team alignment and problem-solving efficiency.</p>

<p>More importantly, it helps you understand your own workload and set priorities to maximize productivity within your available time.</p>

<h3 id="if-you-havent-been-planning-start-now">If You Haven’t Been Planning, Start Now</h3>

<p>Regardless of experience level, if you are still starting your day without a plan, I strongly encourage you to make a change immediately.</p>

<p>At first, I also thought, “Why waste time planning? I should just get to work.”
Because of this mindset, I missed multiple opportunities to build a solid planning habit.</p>

<p>But as my workload grew and I needed to prioritize,
I realized that changing my deeply ingrained habit of not planning was incredibly difficult.</p>

<p>Even now, I am still working on improving,
and I am writing this to keep myself motivated.</p>

<h3 id="if-you-dont-know-where-to-start">If You Don’t Know Where to Start</h3>

<p>That’s okay. Planning is never easy.</p>

<p>No one is good at it from the beginning.
But with time and practice, you will get better at it.</p>

<p>One important thing: don’t be too ambitious.
If you plan too many tasks, you will only end up feeling overwhelmed.</p>

<p>Instead, prioritize what truly matters within your time constraints,
and have the courage to delay or eliminate tasks that don’t fit into your schedule.</p>

<h3 id="we-cannot-do-everything">We cannot do everything</h3>

<p>Even the exceptional people we look up to don’t do everything.
The difference is that they distinguish between what is important and what is not.</p>

<p>They don’t try to do it all.
Instead, they focus on their priorities with a sense of humility
— knowing that time is limited, and they must make the most of it.</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[Even the most exceptional people can’t do everything—they simply prioritize what truly matters, recognizing their limits and making the most of their time with humility.]]></summary></entry><entry><title type="html">Understanding Slice Initialization and Capacity in Go</title><link href="http://localhost:4000/2025/03/02/go-slice-initialization/" rel="alternate" type="text/html" title="Understanding Slice Initialization and Capacity in Go" /><published>2025-03-02T00:00:00+09:00</published><updated>2025-03-02T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/02/go-slice-initialization</id><content type="html" xml:base="http://localhost:4000/2025/03/02/go-slice-initialization/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#summary">Summary</a></li>
  <li><a href="#how-to-initialize-a-slice">How to Initialize a Slice</a></li>
  <li><a href="#advantages-of-preallocating-capacity">Advantages of Preallocating Capacity</a></li>
  <li><a href="#creating-a-slice-with-an-initial-length">Creating a Slice with an Initial Length</a></li>
</ul>

<h2 id="summary">Summary</h2>

<ol>
  <li>Preallocating capacity improves performance by reducing the number of reallocations when appending elements.</li>
  <li>If a slice is initialized with a non-zero length, it is pre-filled with zero values.</li>
  <li>Appending elements can trigger capacity expansion, usually doubling the size of the underlying array.</li>
</ol>

<h2 id="how-to-initialize-a-slice">How to Initialize a Slice</h2>

<p>In Go, the following code snippet creates a slice with length 0 and capacity 1:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Create a slice with length 0 and capacity 1</span>
<span class="n">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Length(len)</code>: The number of elements currently stored in the slice. This represents the number of initialized elements.</li>
  <li><code class="language-plaintext highlighter-rouge">Capacity(cap)</code>: The total allocated size of the underlying array, which determines how many elements can be stored before reallocation is required.</li>
</ul>

<h2 id="advantages-of-preallocating-capacity">Advantages of Preallocating Capacity</h2>

<p>In Go, when a slice reaches its capacity, the underlying array doubles in size upon expansion.
If you expect a slice to grow significantly, preallocating capacity can improve performance by reducing memory reallocations.</p>

<p>Here is an example of capacity expansion in slices:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c">// Initial capacity of 1</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="c">// Output: 0 1</span>

<span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span> <span class="c">// Fits within current capacity (1)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="c">// Output: 1 1</span>

<span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">20</span><span class="p">)</span> <span class="c">// Exceeds capacity → reallocates (new capacity: 2)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="c">// Output: 2 2</span>

<span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">30</span><span class="p">)</span> <span class="c">// Exceeds capacity again → reallocates (new capacity: 4)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="c">// Output: 3 4</span>
</code></pre></div></div>

<ul>
  <li>When <code class="language-plaintext highlighter-rouge">append</code> is called, if the slice exceeds its current capacity, a new array is allocated with double the previous capacity.</li>
  <li>This reduces the number of reallocations when appending elements, optimizing performance.</li>
</ul>

<h2 id="creating-a-slice-with-an-initial-length">Creating a Slice with an Initial Length</h2>

<p>You can also specify the length when initializing a slice:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c">// Length 0, Capacity 1</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c">// Length 1, Capacity 1</span>

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="c">// Output: []</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="c">// Output: [0]</span>
</code></pre></div></div>

<h3 id="effect-of-initializing-a-slice-with-a-non-zero-length">Effect of Initializing a Slice with a Non-Zero Length</h3>

<p>If you specify a non-zero length, the slice will be pre-filled with zero values.
This affects how append operations work:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s1</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> 
<span class="n">s2</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> 

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c">// Output: [1] 1</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span> <span class="c">// Output: [0,1] 2</span>
</code></pre></div></div>

<h3 id="why-does-s2-expand-its-capacity">Why Does s2 Expand Its Capacity?</h3>

<ul>
  <li>s2 was initialized with a length of 1, so it already contains a zero ([0]).</li>
  <li>When appending a new element (1), it exceeds the initial capacity of 1, causing Go to double the capacity to 2.</li>
  <li>On the other hand, s1 starts with length 0, so appending a single element does not exceed its initial capacity.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="go" /><summary type="html"><![CDATA[Understanding slice capacity behavior is essential for writing efficient Go programs, especially when dealing with large or dynamic data structures.]]></summary></entry><entry><title type="html">DOG: A New Gossip Protocol for CometBFT</title><link href="http://localhost:4000/2024/12/26/dog-gossip-protocol/" rel="alternate" type="text/html" title="DOG: A New Gossip Protocol for CometBFT" /><published>2024-12-26T00:00:00+09:00</published><updated>2024-12-26T00:00:00+09:00</updated><id>http://localhost:4000/2024/12/26/dog-gossip-protocol</id><content type="html" xml:base="http://localhost:4000/2024/12/26/dog-gossip-protocol/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#for-the-busy-modern-soul">For the busy modern soul</a></li>
  <li><a href="#the-usefulness-of-dog-in-the-persistent-peering-network">The usefulness of DOG in the persistent peering network</a></li>
  <li><a href="#comparison-flood-gossip-protocol">Comparison: Flood gossip protocol</a></li>
</ul>

<h2 id="for-the-busy-modern-soul">For the busy modern soul</h2>

<p>DOG optimizes the path for transmitting transactions to each node.</p>

<ul>
  <li>When the sent transaction is returned (cycle), it closes the path by sending a <code class="language-plaintext highlighter-rouge">HaveTx</code> message to the peer that sent the transaction.</li>
  <li><code class="language-plaintext highlighter-rouge">HaveTx</code> message only carries the transaction hash, so there is little network overhead.</li>
  <li>Gradually remove unnecessary paths to minimize duplicate transactions.
    <ul>
      <li>In the paper, It is called a <em>Closed-loop redundancy controller</em> which is a mechanism for the system to monitor the current network status and dynamically adjust the level of redundant propagation.</li>
    </ul>
  </li>
  <li>Finally, a <code class="language-plaintext highlighter-rouge">superposition of directed spanning tree</code> structure is created with each node as the root.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/44f98095-8a47-442e-9e26-62c02569e8fb" alt="Initially all routes are open" /></p>

<p><em>@Initially all routes are open</em></p>

<p><img src="https://github.com/user-attachments/assets/19b8b63c-00aa-4b00-92b4-24e2a72c4d7a" alt="The result of directed spanning trees" /></p>

<p><em>@The result: Directed spanning trees, where each node has a single, optimal path to reach every other node.</em></p>

<p>Redundancy Controller is used to set the transaction duplication tolerance range per node.</p>

<ul>
  <li>Redundancy Level
    <ul>
      <li>
        <p>The percentage of redundancy allowed in the overall transaction flow</p>

        <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Redundancy Level <span class="o">=</span> 1 / Allowable redundancy ratio
</code></pre></div>        </div>
      </li>
      <li>The lower the Redundancy Level, the lower the tolerance for duplicate transactions</li>
      <li>f.e. <code class="language-plaintext highlighter-rouge">Redundancy Level = 0.5</code> means when 100 different transactions come in, up to 50 duplicate transactions can be received</li>
      <li>If duplicate transactions are lower than the allowable range, a <code class="language-plaintext highlighter-rouge">ResetRoute</code> message is sent to the peer to reactivate the closed route</li>
    </ul>
  </li>
</ul>

<p>Test Results</p>

<ul>
  <li>
    <p>In the test, transactions were transmitted at a speed of 500tx/s for 15 minutes from 200 nodes</p>
  </li>
  <li>
    <p>Mempool: As the path is built, the mempool size and cache hit count gradually decrease</p>
  </li>
  <li>Consensus
    <ul>
      <li>More stable block production</li>
      <li>Less additional consensus rounds for the validator is needed</li>
      <li>8 times less missing validators during voting</li>
      <li>About 2.7 times less missed blocks</li>
      <li>Additional 10% reduction in network traffic generated by <code class="language-plaintext highlighter-rouge">BlockPart</code> messages</li>
    </ul>
  </li>
  <li>Resource usage and latency
    <ul>
      <li>CPU usage reduced by 43%</li>
      <li>Memory usage reduced by 10%</li>
      <li>Total transaction verification time (checkTx) reduced by 10%</li>
      <li>Average latency: Flood (3.63s), DOG (3.14s)</li>
    </ul>
  </li>
</ul>

<h2 id="the-usefulness-of-dog-in-the-persistent-peering-network">The usefulness of DOG in the persistent peering network</h2>

<p>Persistent peering network is a network where nodes are connected to each other in a persistent way, meaning that nodes are always connected to each other. All validators are connected to each other, and since there are no multi-hops in the network, all transactions can be propagated directly to all nodes in one hop.</p>

<p>As you may have guessed, DOG is not an advantage in this environment. In a single-hop architecture, where a transaction from A to B does not need to go through C, no duplicate transactions occur. The biggest advantage of DOG is that it optimizes the overall network path by gradually reducing the paths where duplicate transactions can occur, so its use is unnecessary in this environment.</p>

<p>However, this does not mean that DOG is completely unnecessary.</p>

<p>Since it is not guaranteed that all nodes will always maintain connectivity, DOG can maintain network propagation by dynamically reconfiguring the path when a specific network connection becomes unstable.</p>

<p>In addition, even in a direct peering environment, network bandwidth can be further reduced through duplicate transaction filtering. In particular, when unnecessary redundant data is propagated in communication between nodes, DOG can detect and minimize this.</p>

<p>Finally, when the number of network nodes is greatly expanded, it may be realistically difficult to maintain persistent peering, but DOG can maintain efficient propagation even in large-scale networks by optimizing the transaction propagation path.</p>

<h2 id="comparison-flood-gossip-protocol">Comparison: Flood gossip protocol</h2>

<p><code class="language-plaintext highlighter-rouge">Flood</code> gossip protocol broadcasts a transaction to all peers in the network when the transaction is created.</p>

<p>During this process, the same transaction may be transmitted multiple times.
In a fully connected network, all nodes are directly connected to each other, which increases redundant propagation.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Flood gossip protocol simply broadcast transactions without checking for duplication, which wastes bandwidth.

For example, There are 4 nodes A, B, C, D.

- If node A sends a transaction to nodes B, C, and D, then B, C, and D also send the same transaction back to each other.
- Flood simply propagate without checking for transaction duplication, resulting in wasted bandwidth.
</code></pre></div></div>

<p>As a result, these problems occur:</p>

<ul>
  <li>Network bandwidth wastes
    <ul>
      <li>Duplicate transaction messages are continuously transmitted, which wastes bandwidth unnecessarily.</li>
    </ul>
  </li>
  <li>Performance degradation
    <ul>
      <li>Transaction propagation speed may slow down as the network becomes overloaded.</li>
    </ul>
  </li>
  <li>Scalability issues
    <ul>
      <li>As the number of network nodes increases, the number of duplicate propagated transactions also increases rapidly.</li>
    </ul>
  </li>
</ul>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://informal.systems/blog/a-new-mempool-gossip-protocol-for-cometbft">A New Mempool Gossip Protocol for CometBFT</a></li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="blockchain" /><summary type="html"><![CDATA[DOG(Dynamic Optimal Graph) is a new gossip protocol for CometBFT, reduces the bandwidth consumption by decreasing the duplicated messages.]]></summary></entry><entry><title type="html">Narwhal: Scalable Blockchain Data Propagation with DAG-Based Design</title><link href="http://localhost:4000/2024/12/17/what-is-narwhal/" rel="alternate" type="text/html" title="Narwhal: Scalable Blockchain Data Propagation with DAG-Based Design" /><published>2024-12-17T00:00:00+09:00</published><updated>2024-12-17T00:00:00+09:00</updated><id>http://localhost:4000/2024/12/17/what-is-narwhal</id><content type="html" xml:base="http://localhost:4000/2024/12/17/what-is-narwhal/"><![CDATA[<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#what-is-narwhal">What is Narwhal?</a></li>
  <li><a href="#worker-and-primary">Worker and Primary</a></li>
  <li><a href="#the-process-of-narwhal">The process of Narwhal</a></li>
  <li><a href="#narwhal-combined-with-consensus-protocol">Narwhal combined with consensus protocol</a></li>
  <li><a href="#limitations">Limitations</a></li>
</ul>

<h2 id="what-is-narwhal">What is Narwhal?</h2>

<p>Every blockchain should share all transactions with nodes, and it directly affects performance, including throughput and latency.</p>

<p>Narwhal was introduced in the paper <a href="https://arxiv.org/abs/2105.11827">“Narwhal and Tusk: A DAG-based Mempool and Efficient BFT Consensus”</a>. Narwhal processes transaction propagation and validation in separate, worker and primary layers to reduce bottlenecks and provide modular-based data availability.</p>

<p>Narwhal uses DAG(Directed Acyclic Graph) to clearly define dependencies between transaction data, thereby maximizing parallelism and scalability. DAG flexibly manages the order of transactions and supports stable data propagation even when the network is massively expanded.</p>

<p><img src="https://github.com/user-attachments/assets/975a0c88-d70b-47c9-b1f8-1f9b0808baf1" alt="The relationship in the process of Narwhal" /></p>

<p><em>@The relationship in the process of Narwhal</em></p>

<h2 id="worker-and-primary">Worker and Primary</h2>

<p>When the client sends a transaction, it goes to the worker located in the node. Transactions are delivered to workers simultaneously, and each worker groups the received transactions into batches.</p>

<p>When transactions accumulate over a certain period or exceed a specified size, the batches created up to that point are transmitted to other nodes.</p>

<p>Nodes validate the received batch and send back a signature of itself to the origin worker. When a worker receives 2f + 1 of the signatures from other nodes, it creates a ‘Mempool block’, including a certificate.</p>

<p><img src="https://github.com/user-attachments/assets/36fc3b5e-1911-4d9d-8b78-8b33c7daa697" alt="The design of the mempool block. r is round, and i is block number" /></p>

<p><em>@The design of the mempool block. r is round, and i is block number</em></p>

<p>The certificate list guarantees that this Mempool block is already validated by 2f + 1 signatures from other nodes is reusable and does not need to re-propagate transactions even though the proposal has failed.</p>

<p>The primary receives Mempool blocks from workers in the same node and creates DAG for managing dependency between transactions. DAG uses authenticated Mempool blocks as nodes, and the relationships (parent-child) between each mempool block as edges connecting the nodes to determine the order of transactions and use them as data for consensus.</p>

<h2 id="the-process-of-narwhal">The process of Narwhal</h2>

<h3 id="1-make-batches-from-transactions-and-broadcast">1. Make batches from transactions and broadcast</h3>

<p>As described above, transactions sent from clients are generated in batches over a certain period or when a certain size is satisfied.</p>

<h3 id="2-get-the-signature-of-thenode">2. Get the signature of the node</h3>

<p>Nodes send back their signature to the origin node worker, not a different worker. When signature data is disseminated randomly, network traffic is increased, and data integrity is difficult to ensure.
Every batch has metadata, including the ID of the batch and worker. A worker who receives batches can send them back to the origin worker due to their containing worker ID.</p>

<h3 id="3-make-the-mempool-block-with-certification">3. Make the mempool block with certification</h3>

<p>When the worker receives more than 2f + 1 signature from other nodes, the worker creates a ‘Mempool block’ including transaction information, signature, etc.</p>

<p>Mempool block has a certification list, not a single certification to reuse when the proposal is failed. It could be a waste of network resources if the Mempool block has to obtain signatures from other nodes in every round, even though they already made certification from signatures of other nodes in previous rounds.</p>

<h3 id="4-send-dag-to-the-leadernode">4. Send DAG to the leader node</h3>

<p>Validator nodes transmit the DAG generated over a certain period to the primary of the leader node. The leader node arranges Mempool blocks from received DAGs into a single DAG and sends it to other nodes for proposal. Non-validators also generate DAG but do not send it to the leader node.</p>

<h3 id="5-when-the-round-isfailed">5. When the round is failed</h3>

<p>A round is a logical unit of time during which transaction data is propagated through the network and consensus is reached. Round failures can occur due to leader failure, network delays, malicious node behavior, etc.</p>

<p>In Narwhal, a round is defined as a process in which a specific leader is designated, and the leader merges DAG data to attempt consensus.</p>

<h4 id="in-worker">In worker</h4>

<ul>
  <li>
    <p>Even though the round failed, a worker maintains the Mempool block and reuses it in the next round.</p>
  </li>
  <li>
    <p>Since the worker continues to collect new transactions from clients regardless of round failure, new transactions are bundled into the next batch, including transactions from the previous batch, and propagated to the network.</p>
  </li>
  <li>
    <p>A batch is converted into a Mempool Block when a worker collects more than 2f+1 signatures from other nodes.</p>
  </li>
</ul>

<h4 id="in-primary">In primary</h4>

<ul>
  <li>Since the previous Mempool block is already allocated in DAG, it can be reused in the next round.</li>
</ul>

<h2 id="narwhal-combined-with-consensus-protocol">Narwhal combined with consensus protocol</h2>

<p>Most consensus algorithms, including PBFT and Hotstuff, operating with strongly coupled data propagation and consensus in the consensus process, can be improved in performance when they use Narwhal.</p>

<p>Narwhal provides increased network performance from completely separated data propagation and consensus.</p>

<h3 id="data-propagation">Data Propagation</h3>

<ul>
  <li>
    <p>In Narwhal, data availability can be ensured by both workers collecting transaction data and primary generating DAG.</p>
  </li>
  <li>
    <p>Since transaction data is propagated independently from the consensus process, the data remains valid even if the consensus fails.</p>
  </li>
</ul>

<h3 id="consensus">Consensus</h3>

<ul>
  <li>Since Narwhal has already completed the data propagation, HotStuff only needs to agree on the DAG state, which is already guaranteed by the worker and primary from Narwhal.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/3107439d-ce19-4e25-bf88-483243ad68ac" alt="Differences between Narwhal-based consensus and standalone" /></p>

<p><em>@Differences between Narwhal-based consensus and standalone</em></p>

<h2 id="limitations">Limitations</h2>

<p>Because of the mesh structure in DAG, the complexity and size would be increased rapidly when the network expands and the number of transactions is increased. To solve this, we need a strategy to periodically clean up old Mempool blocks or limit the depth and size of the DAG.</p>

<p>Also, Narwhal maintains previous DAG data, which the proposal failed, and reuses them in the next round. We also need a policy to efficiently discard old data or merge it with additional data.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://arxiv.org/abs/2105.11827">Narwhal and Tusk: A DAG-based Mempool and Efficient BFT Consensus</a></li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="blockchain" /><summary type="html"><![CDATA[Every blockchain should share all transactions with nodes, and it directly affects performance, including throughput and latency. Narwhal was introduced in the paper “Narwhal and Tusk…"]]></summary></entry></feed>