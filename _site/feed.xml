<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-12-17T09:38:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">blog.wonjoon</title><subtitle>A blog about software engineering, blockchain, and other development topics.
</subtitle><author><name>Wonjoon</name></author><entry xml:lang="ko"><title type="html">AI를 이용하여 하루만에 감사 일기 웹사이트 만들기</title><link href="http://localhost:4000/2025/12/16/gratitude-website/" rel="alternate" type="text/html" title="AI를 이용하여 하루만에 감사 일기 웹사이트 만들기" /><published>2025-12-16T00:00:00+09:00</published><updated>2025-12-16T00:00:00+09:00</updated><id>http://localhost:4000/2025/12/16/gratitude-website</id><content type="html" xml:base="http://localhost:4000/2025/12/16/gratitude-website/"><![CDATA[<h2 id="우리는-얼마나-주어진-삶에-감사하는가">우리는 얼마나 주어진 삶에 감사하는가?</h2>

<p>저는 얼마전부터 뉴스를 보지 않습니다. 집에 TV가 있지만 1년에 사용하는 횟수가 손가락에 꼽을만큼 거의 켜지도 않습니다. 사실 유튜브처럼 굳이 TV가 없어도 다양한 소식을 접할 수 있는 방법이 있어서이기도 하지만, 가장 큰 이유는 불편하고 안좋은 소식을 더 많이 접하는게 싫어서이기도 합니다.</p>

<p>사실 TV를 보지 않는다고 해서 원치않는 소식과 멀어지는건 아닙니다. 오히려 유튜브, 인스타그램 등 다양한 곳에서 훨씬 더 많은 자극적이고 불편한 소식들을 접하게 됩니다. 특히 SNS에서 말하는 내용들의 진위를 파악할 틈도 없이, 여러 갈등의 원인을 온몸으로 맞다보니 현재 살아가고 있는 삶에서 즐거움이 아닌 불안함과 걱정, 그리고 분노만 쌓여가는 것 같습니다.</p>

<p>성경에는 “항상 기뻐하라 쉬지 말고 기도하라 범사에 감사하라”는 구절이 있습니다. 실제로 감사는 꽤 많은 이익을 가져다 준다고 합니다. 꽤 많은 성공한 사람들은 하루 일과의 마지막에 감사 일기를 작성하는 시간을 갖습니다. 일상 속 감사한 일들을 기록함으로써, 긍정적인 마음과 행복감을 증진시켜주고, 이를 꾸준히 할때 자존감이 향상되고 스트레스가 감소되는 등 삶에 좋은 변화들을 많이 가져올 수 있다고 합니다.</p>

<p>하지만 저도 그럤듯이, 꾸준히 하는 것은 둘째 치고, 감사 일기를 한줄이라도 작성하는 것 조차 쉽지 않습니다. 오늘 하루 내가 무엇에 감사했는지 한참 생각해봐도 딱히 감사한 일이 떠오르지 않습니다. 감사 일기를 통해 나를 회복하는 시간을 가지려고 했지만, 정작 하루동안 감사한일이 없다는 생각에 우울해질 때도 있었습니다. 억지로 적어내려간 감사 내용도 항상 똑같았구요.</p>

<p>게다가 요즘 너무 오랫동안 펜을 잡지 않아서일까요, 일기는 노트에 적는게 가장 좋다는 이야기를 많이 들어서 비싼 노트도 구매해서 도전해봤지만 반대로 노트를 열고 책상에 앉는 과정도 새로운 도전같이 느껴졌습니다. 그래서 일기장 앱을 설치해서 작성도 해봤는데, 핸드폰에서 일기 앱을 켜고 끝까지 집중해서 작성한 적도 손에 꼽더라구요.</p>

<h2 id="내가-직접-만들어보자">내가 직접 만들어보자.</h2>

<p>그래서 제가 한번 만들어보자는 생각이 들었습니다. 이전에 <a href="https://wnjoon.github.io/2025/09/15/miniamm-dapp-with-ai/">AI를 통해 허접하지만 프론트엔드 개발도 해봤던 터라</a>, 평소에 고민하고 있던 내용을 설계 문서로 정리해서 AI가 개발하도록 시켜보기로 했습니다.</p>

<p>우선 앱이 아닌 반응형 웹사이트로 개발하기로 했습니다. 뭐 사실 이유는 간단합니다. 저는 앱개발은 해본적이 없거든요. 그리고 약간 핑계를 대자면, 핸드폰이 아닌 적어도 ‘컴퓨터(또는 노트북)’에서 작성하는 것이 훨씬 좋을 것 같다는 생각이 들었습니다. 적어도 제 기준에선 누워서 작성하지는 않을 것 같았거든요.</p>

<p>그리고 가장 중요한 ‘모두가 자신이 적은 감사한 내용을 공유하는 웹사이트’를 만들고 싶었습니다. 익명으로 작성된 수많은 감사들을 보면서, 긍정적인 마음과 용기가 사용자들 사이에 전달되었으면 했습니다. 물론 절대 실명을 사용하지 않습니다. 실명을 사용하면 부끄럽잖아요.</p>

<h2 id="계획서-만들기">계획서 만들기</h2>

<h3 id="gemini와-함께-v1-계획서를-v2로-개선하기">Gemini와 함께 v1 계획서를 v2로 개선하기</h3>

<p>그래서 먼저 <a href="https://github.com/wnjoon/gratitude-grove/blob/main/docs/PRD_v1.md">초기 개발 계획서</a>를 만들었습니다. Gemini가 계획서 하나는 기가막히게 만든다고 들어서, 제가 계획서를 약 80%정도 작성하고 이걸 Gemini에게 전달했습니다. 그리고 Claude Code에게 개발을 맡길건데, 그 전에 어떤 부분이 잘못된 것 같은지 혹은 미리 정의해야할 모호한 부분은 없는지 확인해서 알려달라고 부탁했습니다. <code class="language-plaintext highlighter-rouge">Gemini-3-pro</code>를 사용했는데, Gemini는 저의 계획서를 하나씩 읽어보면서 다양한 수정 방안을 제시했습니다. 특히 supabase 뿐만 아니라 react, tailwind 등 익숙하지 않은 도구들을 어떻게 선택하고 개발해야할지 도움을 많이 받았습니다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gu">### AI(클로드)의 관점에서 본 분석 및 제안</span>

AI는 이 문서를 보고 데이터 모델링과 컴포넌트 구조를 즉시 설계할 수 있습니다. 다만, 기술 스택과 관련하여 몇 가지 보완하면 좋은 점이 있습니다.
<span class="p">
-</span> DB 도구 관련: 1단계에서 Local MySQL을 쓰고 2단계에서 Supabase로 옮기겠다고 하셨는데, 처음부터 <span class="gs">**Supabase(PostgreSQL 기반)**</span>를 사용하는 것이 개발 속도와 설정 면에서 훨씬 효율적입니다. 클로드 코드가 Supabase 환경 설정을 한 번에 끝낼 수 있기 때문입니다.
<span class="p">-</span> 배포 도구 추천: React + Tailwind + Supabase 조합이라면 Vercel이나 Netlify를 추천합니다. Cloudflare Pages도 훌륭하지만, React 프로젝트 배포와 관리가 초보자에게는 Vercel이 가장 직관적이고 강력합니다.
<span class="p">-</span> 아이콘 라이브러리: 🌳 버튼이나 휴지통 버튼 등을 위해 lucide-react 같은 라이브러리를 추가하면 디자인 일관성을 높일 수 있습니다.
</code></pre></div></div>

<p>추가로 제가 작성한 계획서의 모호한 점을 확실하게 하기 위해 질문을 이어갔습니다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>작업을 시작하기 전, 제가 궁금하거나 설계상 결정이 필요한 부분들입니다.

Q1. 좋아요(나무 🌳) 버튼의 중복 방지 로직
<span class="p">
-</span> "사용자별 말풍선당 하나만" 제어하려면 별도의 likes 테이블이 필요합니다. (user_id, diary_id)를 유니크 키로 묶어 관리하면 되는데, 비로그인 사용자도 좋아요를 누를 수 있게 할까요? 아니면 로그인 사용자만 가능하게 할까요?
<span class="p">-</span> 나의 답변: 비로그인 사용자는 좋아요를 누를 수 없게 하는게 좋을것 같아.

Q2. 메인 화면의 레이아웃 (말풍선 배치)
<span class="p">
-</span> 가로 3개, 세로 7개의 고정 그리드(Grid) 형태를 원하시나요? 아니면 핀터레스트처럼 내용 길이에 따라 높낮이가 다른 메이슨리(Masonry) 레이아웃을 원하시나요? (설명하신 '말풍선 화살표' 디자인은 메이슨리 스타일일 때 더 자연스러울 수 있습니다.)
<span class="p">-</span> 나의 답변: 메이슨리 레이아웃을 사용하게되면 말풍선 내부의 글을 어떻게 압축하면 좋을까? 각 감사 항목별로 몇글자 이상이 되면 ...을 붙이도록 하는건 어떨까?

Q3. 감사일기 작성 제한
<span class="p">
-</span> "당일 일기만 작성 가능"하게 하려면 서버 시간(Supabase 시간)을 기준으로 할까요, 아니면 사용자의 로컬 브라우저 시간을 기준으로 할까요? (보통은 서버 시간을 권장합니다.)
<span class="p">-</span> 나의 답변: 서버 시간으로 하자.

Q4. 별명 중복 허용 여부
<span class="p">
-</span> 회원가입 시 별명은 중복이 불가능한 '유니크' 값으로 설정할까요?
<span class="p">-</span> 나의 답변: 별명은 중복이 불가능해야해.
</code></pre></div></div>

<p>그리고 Database는 초기부터 Postgres를, 배포에는 Vercel을 사용하기로 했습니다. 아이콘 라이브러리도 개발 과정에 미리 등록해서 쉽게 사용할 수 있도록 하기로 했구요. 이후 말풍선(감사 일기 내용)을 클릭할 때 슬라이드업, 페이드인 중 하나의 애니메이션을 사용할 것을 권장하길래 각각이 무엇인지 질문했고, 최종적으로 말풍선을 클릭하면 가운데에서 팝업처럼 나타나고 뒤의 배경을 흐릿하게 만드는 방식을 사용하자고 말했습니다.</p>

<h3 id="claude-code와-함께-v2-계획서를-v3로-개선하기">Claude Code와 함께 v2 계획서를 v3로 개선하기</h3>

<p><a href="https://github.com/wnjoon/gratitude-grove/blob/main/docs/PRD_v2.md">Gemini를 통해 개선된 문서</a>를 Claude Code에게 전달하고, 이해가 가지 않거나 미리 논의해야할 부분을 확인해서 합의하자고 제안했습니다. 이 때 Claude Code는 <code class="language-plaintext highlighter-rouge">opus-4.5</code>를 사용했습니다. 확실하게 분석하기 위해, Max Plan의 비싼 값어치를 할 수 있도록 ultrathink를 뒤에 붙였습니다. 설계자(Gemini)를 통해 이미 어느정도 정리가 되었다고 생각했는데, 역시 실무자(Claude Code)는 또다른 관점에서 저에게 확인이 필요한 사항들을 말해주었습니다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gu">### 확인이 필요한 사항들</span>
<span class="p">
1.</span> Supabase 프로젝트 설정
<span class="p">
  -</span> Supabase 프로젝트가 이미 생성되어 있나요? 아니면 새로 만들어야 하나요?
<span class="p">  -</span> 생성되어 있다면 API URL과 Anon Key를 환경변수로 제공해주실 수 있나요?
<span class="p">  -</span> 나의 답변: 해당하는 환경변수 값을 정리해서 알려주었음.
<span class="p">
2.</span> 별명(Nickname) 관련
<span class="p">
  -</span> PRD에서 "별명 변경 시 모든 글의 별명이 즉시 변경되어야 함"이라고 했는데, diaries 테이블에는 user_id만 저장하고 JOIN으로 별명을 가져오는 방식이 맞을까요? (이 방식이 자동 동기화에 유리합니다)
<span class="p">  -</span> 나의 답변: diaries 테이블에 user_id만 저장하고 JOIN으로 별명 가져오자.
<span class="p">
3.</span> 일기 내용 저장 형식
<span class="p">
  -</span> PRD에 "구분자(예: <span class="err">*</span>) 혹은 JSON 배열"이라고 되어있는데, JSON 배열 (text[] 또는 jsonb) 방식을 권장드립니다. 파싱이 깔끔하고 각 항목을 독립적으로 다루기 좋습니다.
<span class="p">  -</span> 나의 답변: 둘중에 뭐가 좋을지 잘 모르겠어서, text[], jsonb 중 더 효율적인 방법 선택해달라고 했고 text[] 방식으로 선택되었음.
<span class="p">
4.</span> 무한 스크롤 vs 페이지네이션
<span class="p">
  -</span> 메인 피드: 비로그인 시 21개 제한 후 차단, 로그인 시에는 무한 스크롤인가요?
<span class="p">  -</span> 나의 일기: 9개씩 페이지네이션 (버튼 클릭 방식)이 맞나요?
<span class="p">  -</span> 나의 답변: 비로그인, 로그인 관련 없이 메인에서는 21개만 보여주도록 함 (무한 스크롤을 적용하면 성능에 문제가 생길것으로 보임). 그리고 나의 일기는 9개씩 페이지네이션.
<span class="p">
5.</span> 좋아요 카운트 방식
<span class="p">
  -</span> PRD에 "역정규화 또는 count 쿼리 선택"이라고 되어있는데, 역정규화 방식 (diaries 테이블에 like_count 컬럼 + trigger로 자동 업데이트)을 권장드립니다. 피드 로딩 시 성능이 훨씬 좋습니다.
<span class="p">  -</span> 나의 답변: 역정규화 방식 좋음.
<span class="p">
6.</span> 반응형 디자인
<span class="p">
  -</span> 모바일/태블릿/데스크탑 모두 지원해야 하나요? Masonry 레이아웃의 컬럼 수를 화면 크기에 따라 조정할까요?
<span class="p">  -</span> 나의 답변: 모바일에서는 1개의 컬럼만 사용하고, 모두 아래로 나열하도록 설정.
<span class="p">
7.</span> 이메일 인증
<span class="p">
  -</span> Supabase Auth 사용 시 이메일 인증(confirmation)을 활성화할까요? 아니면 가입 즉시 로그인 가능하게 할까요?
<span class="p">  -</span> 나의 답변: 가입 즉시 로그인. 이후 supabase auth에서 이메일 인증을 하라고 해서 이부분은 우선 제외해달라고 요청.
</code></pre></div></div>

<p>추가로 일기에 대한 수정, 삭제 기능이 누락되어 있다고 말해줘서 그 부분도 구현해달라고 요청했습니다. 그리고 해당 날짜의 감사 일기는 당일에만 작성할 수 있도록 제한했습니다. 지난 날의 감사가 아닌 오늘의 감사를 적는 것이 중요하다고 생각했습니다. 그리고 오늘이 지나면 내일은 그 감사의 마음이 온전히 담기지 않을 것이라고도 생각했거든요.</p>

<h2 id="claude-code의-활약">Claude Code의 활약</h2>

<p>사실 이 다음부터는 딱히 정리할게 없습니다. 제가 화면이 하나씩 만들어질때마다 꼭 저에게 보여주고 검토받은 후 다음 단계로 이동할 것을 요청했습니다. 기능적인 부분도 가끔 있었지만, 대부분은 화면상에 글자가 깨지거나 가독성이 떨어지는 부분 등 마이너한 수정을 요청한게 다였습니다. 물론 프로그램의 범위가 굉장히 간단하고 별로 복잡한 기능이 없어서 AI로 충분히 개발 가능할것이라 생각은 했지만, 이정도로 금방 개발할 수 있을 것이라고는 생각하지 못했습니다. 점점 발전해가는 AI의 속도도 무서웠지만, 이젠 아이디어만 있으면 무엇이든지 정말 만들 수 있겠구나라는 생각도 들었습니다. 배포도 Vercel을 이용하니 굉장히 빠르게 진행했습니다. 저는 그냥 회원가입만 했을 뿐입니다.</p>

<h2 id="결과물-매일-감사-심기">결과물: 매일 감사 심기</h2>

<p><a href="https://gratitude-grove.vercel.app/">매일 감사 심기</a>는 이메일 주소와 비밀번호, 그리고 별명만 입력하면 누구나 참여할 수 있는 감사를 공유하는 공간입니다. 실제로 서비스를 한다기보다는, 우선 저와 제 아내가 하루의 감사한 일들을 같이 적어보고 이를 공유해보고자 만들었습니다. 그리고 누군가의 글을 통해 그 감사함이 흘러서 다른 사람에게도 긍정적인 마음이 전해지고, 그 마음이 다른 사람들에게 계속 전해지길 바라는 마음으로 만들어보았습니다.</p>

<p><br /></p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/d97fa539-97e9-4bdf-ae00-e6017ab2ab17/image.png" alt="" /></p>

<p><br /></p>

<p>그래서 이 웹사이트의 메인화면에는 회원들이 작성한 모든 감사 일기가 공유됩니다. 현재는 최대 21개의 감사 일기가 메인화면에 보이도록 했습니다. 그리고 메인화면에 공유된 감사 일기를 보고 마음이 따뜻해졌다면 좋아요를 누를 수 있게 했습니다.</p>

<p><br /></p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/f630bb68-27ac-4433-a40c-fc5f47c42d8e/image.png" alt="" /></p>

<p><br /></p>

<p>특히 개발자라는 것을 좀 티내보려고, 감사 일기를 작성할때마다 깃헙의 잔디 심기와 같이 초록색이 칠해지도록 했습니다. 그래서 이 웹사이트의 이름이 <strong>‘매일 감사 심기’</strong> 입니다. 꾸준하게 매일 심은 감사들이 우리의 삶을 초록색으로 물들일 수 있을 것이라 생각했습니다. 본인이 작성한 감사 일기는 언제든지 확인할 수 있고, 지난 날짜에 작성한 감사 일기도 필터를 통해 바로 확인할 수 있습니다.</p>

<p>앞으로 시간이 날때마다 하나씩 기능을 추가하거나 개선해가면서 저도 사이드 프로젝트의 즐거움을 좀 더 느껴보려고 합니다. 부족한 부분에 대한 조언이나 의견이 생각나시면 <a href="mailto:wnjoon@gmail.com">이메일</a>로 언제든지 메일 부탁드립니다. 감사합니다.</p>

<ul>
  <li><a href="https://gratitude-grove.vercel.app/">매일 감사 심기: https://gratitude-grove.vercel.app/</a></li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[대혐오의 시대라고 불리죠. 우리는 세상에서 느끼는 불편함과 혐오 때문에 점점 감사하는 삶과 멀어지는 것 같습니다. 세상은 좀더 밝다는 것을 느끼고 싶어서 Claude Code를 이용하여 하루만에 매일 3개의 감사를 작성하고 이를 공유하는 웹사이트를 만들었습니다.]]></summary></entry><entry xml:lang="ko"><title type="html">14년간 구글에서 근무한 개발자의 조언</title><link href="http://localhost:4000/2025/12/16/21-lessons-for-engineer/" rel="alternate" type="text/html" title="14년간 구글에서 근무한 개발자의 조언" /><published>2025-12-16T00:00:00+09:00</published><updated>2025-12-16T00:00:00+09:00</updated><id>http://localhost:4000/2025/12/16/21-lessons-for-engineer</id><content type="html" xml:base="http://localhost:4000/2025/12/16/21-lessons-for-engineer/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/29">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[14년간 구글에서 일한 개발자 Addy Osmani가 작성한 21개의 조언을 번역했습니다.]]></summary></entry><entry xml:lang="ko"><title type="html">소셜미디어. 그리고 개발자.</title><link href="http://localhost:4000/2025/12/12/sns-for-developer/" rel="alternate" type="text/html" title="소셜미디어. 그리고 개발자." /><published>2025-12-12T00:00:00+09:00</published><updated>2025-12-12T00:00:00+09:00</updated><id>http://localhost:4000/2025/12/12/sns-for-developer</id><content type="html" xml:base="http://localhost:4000/2025/12/12/sns-for-developer/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/28">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[링크드인은 개발자에게 필수적인 커리어 브랜딩 도구이지만, 타인의 화려한 성과와 자신을 비교하게 만들어 번아웃을 유발하기도 합니다. SNS 속 '포장된 삶'과 현실을 구분하고, 건강하게 성장하기 위한 개발자의 마음가짐에 대해 이야기합니다.]]></summary></entry><entry xml:lang="en"><title type="html">How Developers Should Use Social Media: A Tool for Growth or a Cause of Burnout?</title><link href="http://localhost:4000/2025/12/12/sns-for-developer-en/" rel="alternate" type="text/html" title="How Developers Should Use Social Media: A Tool for Growth or a Cause of Burnout?" /><published>2025-12-12T00:00:00+09:00</published><updated>2025-12-12T00:00:00+09:00</updated><id>http://localhost:4000/2025/12/12/sns-for-developer-en</id><content type="html" xml:base="http://localhost:4000/2025/12/12/sns-for-developer-en/"><![CDATA[<p>I once wrote a <a href="https://wnjoon.github.io/2025/09/15/tobe-good-developer-en/">post ‘Habits and Mindsets for Sustainable Growth’</a> recommending a book titled “The Battle Hardened Developer - Fiodar Sazanavets”. While there were many excellent quotes, the one that resonated with me the most was this: “Modern people must distance themselves from social media for their mental health. Developers, in particular, need to be even more careful.”</p>

<p>Through social media, we observe the “curated good lives” of others. I, too, have been traveling abroad for about two weeks now, and I am busy uploading photos to social media, driven by the desire to show this side of myself to the world. I don’t post about the difficulties of travel, the moments I argued with my wife, the places that were less impressive than expected, or the food that tasted bad. I simply edit and publish the photos I like the best.</p>

<p>LinkedIn is the representative social media tool that extends this “self-appeal” from life into career. I have used LinkedIn very actively, and indeed, I have received several good job offers through it. The main purpose of LinkedIn is not to show your happiness. It reveals what great work you are doing and what a solid career you are building. Occasionally, people share stories of failure or difficult moments, but even that is often a method to demonstrate growth through the process. I have no intention of criticizing this. In fact, I actively encourage my juniors and colleagues to use LinkedIn. Since so many people are busy packaging and appealing themselves, I believe that criticizing and avoiding this reality only results in remaining a “hidden expert” who fails to advertise themselves. Furthermore, without it, you might not be able to view your own skills objectively.</p>

<p>However, what is more dangerous than not using LinkedIn is judging yourself while reading the countless posts on it. LinkedIn is populated by employees from numerous IT companies, including developers. Developers from millions of companies attach open-source code they’ve worked on or technical analyses they’ve written. Due to the nature of the profession—where individual activities and careers are proven by source code and websites—these achievements are shared in much greater volume compared to other jobs.</p>

<p>Eventually, just as we envy the lives of others looking at Instagram photos, we begin to compare other developers’ posts with our current careers. If this acts as a catalyst encouraging personal growth, it is wonderful. But it should never reach a point where it causes burnout.</p>

<p>Recently, my life felt exactly like that. Watching someone else’s amazing achievements made me feel like I needed to work harder, but at the same time, I felt an indescribable exhaustion. Conversely, I started to question whether I was living well, or if I was doing something wrong. A tool I used to read about things I didn’t know and to share new insights had started to become a tool that made me look pessimistically at my efforts and made me feel infinitely small.</p>

<p>These days, there are channels on other social media platforms that curate “How to become a good developer.” I follow those channels and tend to read them one by one while lying in bed. As I enter my late 30s, I constantly worry about whether I am being refined into a “good developer.” There are parts where I feel relieved, thinking “thank goodness,” but there are also contents that make me break out in a cold sweat beyond mere embarrassment. Personally, I believe the profession of a developer has a different “standard of evaluation” compared to many traditional jobs. If the career path for most office workers was based on “where you belong”—joining a famous large corporation, receiving a high salary, working as a manager, and retiring at the standard age—then for developers, the criteria for a career path has become prioritizing personal competence and happiness. That is why, even when belonging to a sufficiently good company, they constantly wander looking for other places and want to create and share their own achievements even outside of work hours.</p>

<p>In the end, it comes down to our mindset. If we start evaluating ourselves through comparison, looking at someone else’s achievements—big or small—will only make us anxious about our present. We need to have the leeway to think that there are countless teachers out there who give us insights through new content and teach us the parts we lack.</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[Social media is an essential tool for career branding, but it can also trigger burnout by compelling us to compare ourselves with the polished achievements of others. This post discusses how developers can separate 'curated lives' from reality and maintain a healthy mindset for growth.]]></summary></entry><entry xml:lang="ko"><title type="html">GopherCon Korea 2025 후기</title><link href="http://localhost:4000/2025/11/12/gophercon-korea/" rel="alternate" type="text/html" title="GopherCon Korea 2025 후기" /><published>2025-11-12T00:00:00+09:00</published><updated>2025-11-12T00:00:00+09:00</updated><id>http://localhost:4000/2025/11/12/gophercon-korea</id><content type="html" xml:base="http://localhost:4000/2025/11/12/gophercon-korea/"><![CDATA[<h2 id="나름-8년차-golang-개발자이지만-컨퍼런스는-처음">나름 8년차 Golang 개발자이지만, 컨퍼런스는 처음</h2>

<p>제가 처음으로 Go 언어를 경험한 것은 2018년 LG CNS에서 블록체인을 개발하는 프로젝트였습니다. 그전에도 Google에서 만든 언어라는 꽤 매력적인 타이틀 덕분에 관심을 갖고 있었지만, 다른 개발자들과 마찬가지로 업무와 관련없이 새로운 언어를 배우는 것이 쉽지 않았던 것 같습니다. 그러던 중 회사에서 사용하는 블록체인 플랫폼이 Go 언어를 사용하고 있었고, 지금은 Go 언어를 가장 많이 사용하는(거의 이것만 사용하는 것 같은) 개발자가 되어있네요.</p>

<p>하지만 부끄럽게도, Go 언어를 사용한 연수에 비해 컨퍼런스나 세미나, 하물며 특정 모임에 참석한 적은 한번도 없었습니다. 언어는 단순히 도구라고 생각해서였을지, 혹은 언어를 탐구한다는 것이 너무 철학적인 것 같다고 느껴서였을지 모르지만, 요즘 생각으로는 단지 ‘중요성을 몰라서’였기 때문이었던 것 같습니다.</p>

<p>누군가의 요구사항에 맞춰 단발성 프로젝트 형식으로 개발하는 일명 SI 회사에서, 플랫폼을 만들고 내부 기술을 연구하는 회사로 갈수록, 제가 사용하는 언어가 어떻게 업데이트 되어가는지, 그리고 어떤 기능들이 추가되고 삭제되는지 관심있게 보는 것이 꽤 중요하다는 것을 느꼈습니다. 어찌보면 언어 또한 일하면서 가장 많이 사용하는 도구 중 하나인데, 너무 관심없던 것은 아니었나 싶네요.</p>

<p>서론이 조금 길었지만, 그러던 중 <a href="https://gophercon.kr/">GopherCon Korea 2025</a>가 열린다는 소식을 접하게 되었고, ‘제 기준에서는 약간은 큰 돈이지만’ 기쁜 마음으로 참가비를 내고 참석하게 되었습니다.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/671bb182-5115-42bd-ac1c-e125fb1e42ec/image.png" alt="image" /></p>

<p>얼마나 기대가 되었던지(?), Go Wiki 사이트에 GopherCon Korea 2025에 대한 정보가 없다는 것을 발견하고 디스코드에 일러바치기도 했네요.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/0e97821e-4b43-4bf1-813a-8a0a53e7f06c/image.png" alt="image" /></p>

<h2 id="세션-요약">세션 요약</h2>

<p>처음으로 참석한 이번 GopherCon 2025 행사는 정말 만족스러웠습니다. 무엇보다 장소가 정말 쾌적했고, 연사분들의 발표와 슬라이드가 정말 잘 전달되는 환경이 조성되어 있었습니다.</p>

<p>그리고 개발자들이 가장 좋아하는 스티커가 넘쳐났고, 심지어 갯수 제한도 없어서 마음껏 가져올 수 있었습니다. 플리마켓에서 파는 굿즈들도 꽤나 매력적이었는데, 저는 그중 키캡 하나를 구매해서 잘 사용하고 있습니다.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/34edac4f-7a7b-48b8-83e3-dcdf24e0248b/image.JPG" alt="image" /></p>

<p>이번 행사에서 진행된 발표는 아래와 같습니다. 각 발표의 내용과 개인적인 생각을 간략하게 정리해보겠습니다.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/b13300e8-276c-40a3-a6c6-947cfa43ab1d/image.png" alt="image" /></p>

<h3 id="go-로-만든-ai-주식-추천-및-자동매매-시스템">Go 로 만든 AI 주식 추천 및 자동매매 시스템</h3>

<p>사실 이날 행사 전후로 개인적인 일정이 있었습니다. 그래서 10시 반에 시작하는 첫 발표는 못 들을 수도 있겠다고 생각했는데, 발표 주제를 보는순간 서둘러서라도 듣고싶은 마음에 최대한 시간을 맞춰서 행사장으로 뛰어왔습니다.</p>

<p>요즘 저는 AI 에이전트를 만드는 방법에 대해 학습하고 있는데, 대부분의 강의들이 Python 기반으로 프로그램을 작성하도록 설명하고 있습니다.</p>

<p>아무래도 데이터 사이언스부터 시작해서 AI 라이브러리의 대부분이 Python으로 되어있기 때문일것이고, Python이 상대적으로 배우기 쉬운 언어라 그럴수도 있을 것 같지만, 처리해야할 내용들이 일반적인 프로그램보다 상대적으로 훨씬 많을 것 같은 AI 에이전트에서 Go 언어를 후순위로 생각한다는 것이 조금 아이러니 하다고 생각하고 있었습니다. 그러던 참에 Go 언어를 가지고 AI 에이전트를 작성한 발표를 놓칠수가 없었습니다.</p>

<ul>
  <li><a href="https://github.com/suapapa/go_kinvest">github repo</a></li>
  <li><a href="https://ss-demo.homin.dev/">demo website</a></li>
</ul>

<p>가장 흥미로웠던 것은 <a href="https://github.com/firebase/genkit">Genkit</a> 이었습니다. Genkit은 Go 기반으로 LLM 에이전트를 개발할 수 있는 라이브러리로, Gemini 뿐만 아니라, OpenAI, Anthropic, 그리고 Ollama까지 지원하는 프레임워크입니다. (신기하게도 다른 도구들과 반대로, 지원하는 언어들 중 Python이 가장 안정적이지 않은 Early 단계에 있네요)</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/e2c63bb1-9f87-404e-b45a-711028f48e9b/image.png" alt="image" /></p>

<p>발표자분은 <a href="https://product.kyobobook.co.kr/detail/S000212731844">세븐 스플릿</a> 이라는 책을 보고 투자 방향을 설계하고 이를 기반으로 AI 에이전트에 필요한 기능과 프롬프트를 구현했다고 했습니다. 개인적으로 이제는 코딩, 사용 가능한 도구 갯수 등이 개발자의 실력을 평가하는 시대가 아니라, 얼마나 비지니스를 잘 이해하고 빠르게 설계해서 AI를 통해 구현하는가가 더 중요한 실력의 척도가 되어가고 있다 생각합니다.</p>

<p>그래서 AI 도구를 잘 사용하는 방법에 대해서 꾸준히 학습하고, 비록 내가 사용하지 않는 고차원적인 기능이라도 지속적으로 관심을 갖고 따라해봐야 한다고 생각합니다. 그런 관점에서 발표자분의 내용은, Go라는 언어가 단순히 구현에 사용한 하나의 도구에서 끝날 수 있지만, 개발자 커리어 관점에서 보면 굉장히 좋은 발표라고 생각했습니다. 특히 투자를 진지하게 공부한지 약 3개월정도 되었다고 말씀하셨는데, 그에 비해 구현된 AI 에이전트의 완성도는 굉장히 인상깊었습니다. 배울점이 많은 발표라고 생각했습니다.</p>

<h3 id="동시통역-go로-만들기---실시간-ai-인퍼런스-webrtc">동시통역 Go로 만들기 - 실시간 AI 인퍼런스, WebRTC</h3>

<p>Go 언어의 가장 큰 장점은 뭐니뭐니해도 채널입니다. 다른 언어들도 물론 병렬 프로세싱이 가능하지만, Go 만큼 이를 간편하게 해주는 언어는 없습니다. 채널을 생성하고 적절한 시기에 뮤텍스를 통해 제어해준다면, 복잡한 동시성 제어도 충분히 할 수 있습니다.</p>

<p>병렬 프로세싱이 가져오는 가장 큰 장점은 동일한 업무를 더욱 빠르게 처리할 수 있다는 것입니다. 특히 이번 발표 내용인 동시 통역은, 빠른 처리시간이 정말 중요합니다. 상대방의 말을 빠르게 이해하고 번역해야, 대화가 끊기거나 어색해지지 않을 것입니다. 여기서 말하는 WebRTC는 P2P 기반으로 동작하며, 중간에 통신을 릴레이하는 서버가 없습니다.</p>

<p>WebRTC로 사용할 수 있는 라이브러리는 크게 2가지가 있습니다.</p>
<ul>
  <li><a href="https://github.com/pion">pion</a>: 오픈소스, 간단한 프로젝트에 구현</li>
  <li><a href="https://github.com/livekit/livekit">livekit</a>: enterprise</li>
</ul>

<p>추가로 backpressure를 해결하기 위해 buffered channel을 구성하였다고 발표하셨는데요, backpressure는 소비자(subscriber)가 데이터를 생산자(producer)보다 빠르게 처리할 수 없을 때 발생하는 문제를 관리하기 위한 메커니즘입니다. 예를 들어, 상대방이 꽤 많은 말을 빠르게 할때, 병렬로 처리하는 과정에서 중간에 데이터가 유실되거나 순서가 변경되면 의도하지 않은 내용이 만들어질 수 있습니다. 이를 해결하기 위해 상대방의 대화를 적절한 크기의 공간에 담아두고, 내부에서 순서를 관리하는 방식을 적용한 것으로 보였습니다.</p>

<blockquote>
  <p>backpressure에 대한 자세한 내용은 <a href="https://looco.tistory.com/12#:~:text=%F0%9F%93%96%20Backpressure%EB%9E%80?,%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%95%88%EC%A0%95%EC%84%B1%EC%9D%84%20%EB%B3%B4%EC%9E%A5%ED%95%A9%EB%8B%88%EB%8B%A4.">이곳</a>을 참고해주세요.</p>
</blockquote>

<h3 id="프레임워크냐-아니냐-그것이-nethttp로다">프레임워크냐, 아니냐: 그것이 net/http로다</h3>

<p>개발자라면 성능과 유연성 중 하나를 선택해야 하는 기로에 서게 되는 상황이 있습니다. 서버 프레임워크를 선택하는 경우도 이에 해당하는데요, 일반적으로 가장 많이 사용되는 프레임워크로 Gin, Echo, Fiber가 있습니다.</p>

<ul>
  <li><a href="https://github.com/gin-gonic/gin">gin</a>
    <ul>
      <li>프레임워크중 가장 난이도가 낮음</li>
      <li>높은 트래픽이 예상된다면 gin 사용을 추천하지는 않지만, 그래도 어느정도는 커버 가능</li>
    </ul>
  </li>
  <li><a href="https://github.com/labstack/echo">echo</a>
    <ul>
      <li>가장 go스러운 프레임워크</li>
      <li>gin에 비해서 복잡함</li>
    </ul>
  </li>
  <li><a href="https://github.com/gofiber/fiber">fiber</a>
    <ul>
      <li>http2가 필요없고 속도가 함장 중요하다면 좋음</li>
      <li>단, 메모리 제어가 꼭 필요함</li>
    </ul>
  </li>
</ul>

<p>이 프레임워크들은 크게 2가지 종류로 구분이 됩니다.</p>
<ul>
  <li>net/http: gin, echo</li>
  <li><a href="https://github.com/valyala/fasthttp">fasthttp</a>: fiber</li>
</ul>

<p>fastttp는 net/http에 비해 6배나 높은 성능을 제공하기 때문에, 고성능을 요구하는 경우에 사용됩니다. 하지만 HTTP2 이상을 지원하지 않는다는 단점이 있습니다. 발표자분은 특별한 목적이 없다면, Gin을 사용할 것을 권장하였고, 그 안에서 세부적인 설정이 필요하다면 차라리 Go에서 제공하는 기본 라이브러리인 net/http를 직접 사용할 것을 권장했습니다. 자세한 내용은 <a href="https://wnjoon.github.io/2025/11/11/comparison-go-http-lib/">Go HTTP 라이브러리 비교: fasthttp vs net/http</a>에 정리해두었으니 참고하시면 좋을 것 같습니다.</p>

<h3 id="effect-ive-go-완전히-go-다운-함수형-프로그래밍">Effect-ive Go: 완전히 Go 다운 함수형 프로그래밍</h3>

<p>이번 발표는 굉장히 어렵고, 또 도전적이었습니다. 발표자분은 처음부터 본인을 Go를 너무나 사랑하는 사람으로 소개했습니다. 앞에서 적었듯이, 저는 언어를 단순히 일할때 사용하는 도구 이상으로는 여기지 않았던 것 같습니다. 그 언어의 철학과 문화를 이해해야 한다는 필요성도 느끼지 못했고, 그래서 언어가 어떻게 변화하고 있는지도 그렇게 관심을 두지 않았습니다. 하지만 발표자분은 정 반대였습니다. Go 언어가 제공하는 강력한 인터페이스 기반의 설계 안에서도 개선할 점을 찾아보고, 이를 직접 라이브러리로 구현했습니다.</p>

<p>발표자분은 추상을 최대한 적게만들고, 불필요한 추상은 겉어내고, 있는 추상도 최대한 작게 만드는 것이 Go 언어의 철학을 따르는 중요한 가치라고 생각했습니다. 하지만 이렇게 추상을 최소화할수록, 우리는 점점 이게 테스트인지 디버깅인지 헷갈릴 정도로 테스트를 위해 Mock을 포함한 많은 장치를 구현해야 하는 경우가 생기기도 합니다. 발표자분은 이를 개선한 라이브러리를 <a href="https://github.com/on-the-ground/effect_ive_go">effect-ive go</a>라고 소개했습니다.</p>

<p>Effect-ive Go proposes the minimal idiomatic interface for delegating effects, staying true to Go</p>
<ul>
  <li>Uses context and teardown for idiomatic effect handler binding/unbinding</li>
  <li>Effects declared with type and payload</li>
  <li>Effect payloads are sent over channels to matching handlers found in context</li>
</ul>

<p>이 외에도 순수함수를 Tableizable 하여 성능을 대폭 개선하는 등 정말 많은 기능들이 있었고, 나중에 꼼꼼히 읽어보면 좋겠다는 생각이 들었습니다. 이후에 링크드인에서 발표자님을 만나게 되었는데, 개인적인 존경의 의미를 담아 메시지도 드렸습니다.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/3a30efbb-d377-44b4-9e3d-da9301d41cc1/image.png" alt="image" /></p>

<h3 id="test-reality-not-mocks-reliable-go-tests-in-the-ai-era">Test Reality Not Mocks: Reliable Go Tests in the AI Era</h3>

<p>저는 개인적으로 Mock 기반의 테스트를 별로 좋아하지 않습니다. 뭔가 찜찜하다고 할까요. 작성된 함수가 예상하는 결과를 보여주는 것 까지는 가능하지만, 실제로 비지니스에서 발생할 수 있는 상황을 세밀하게 테스트하는 것은 Mock 기반의 테스트에서 한계가 있다고 늘 생각했었습니다. 하지만 <em>기분탓인지 모르겠지만</em> 시니어 개발자라면 Mock 기반의 테스트를 잘 사용해야 한다고 느껴서, 억지로 Mock을 만들어서 테스트하는 경우도 간혹 있었습니다. 하지만 대부분은 실제 환경를 로컬에 구성해서 이를 기반으로 테스트하는 경우가 많았는데요, 발표자분의 내용을 듣고나서 ‘아, 내가 틀린것은 아니었구나’하는 생각이 들었습니다.</p>

<p>발표자분은 “Mock을 테스트하는건 실제 어플리케이션을 테스트하는게 아니다”라고 표현했는데요, 요즘에는 AI를 기반으로 어플리케이션을 직접 테스트함으로써 훨씬 정확한 테스트를 할 수 있다는 점을 강조했습니다. 이를 포함해서 좋은 테스트를 위한 방법을 여러가지 공유해주셨습니다.</p>

<p>어플리케이션 전체를 테스트하는 방법(main)</p>
<ul>
  <li>main 함수를 테스트하는 것은 불가능하지만, main 함수를 특정 함수를 실행하는 단일 실행지점으로 만들 수 있다면 테스트 할 수 있습니다.</li>
  <li>예로 main 함수에서 <code class="language-plaintext highlighter-rouge">Run()</code> 함수를 호출하도록 구현하였다면, <code class="language-plaintext highlighter-rouge">Run()</code> 함수를 테스트하면 됩니다.</li>
  <li>테스트 코드에서 <code class="language-plaintext highlighter-rouge">waitForHealthCheck</code> (200을 반환할때까지 대기) 함수를 호출하여 <code class="language-plaintext highlighter-rouge">Run()</code> 함수가 정상적으로 실행되는지 테스트할 수 있습니다.</li>
  <li>이에 대한 내용은 <a href="https://grafana.com/blog/2024/02/09/how-i-write-http-services-in-go-after-13-years/">How I write HTTP services in Go after 13 years</a>에 좀 더 자세히 나와있습니다.</li>
</ul>

<p>go test를 활용하여 프로덕션 코드를 모니터링 하는 방법</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">*/10 * * * * go test -run ...</code></li>
  <li>개발된 어플리케이션을 cronjob 등을 활용하여 주기적으로 테스트해볼 수 있습니다.</li>
</ul>

<p>동시성 문제 테스트</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">t.Parallel()</code>를 사용하면, 동시성 문제로 발생하는 수많은 버그들을 테스트 과정에서 발견할 수 있음</li>
  <li><code class="language-plaintext highlighter-rouge">t.Parallel()</code>을 사용할 때는 unique data를 사용해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">flag.Parse</code>를 사용하여 여러 환경을 동시에 테스트할 수 있음 (예: 테스트 환경, 개발 환경, 프로덕션 환경)</li>
</ul>

<p>감사하게도 발표 내용을 <a href="https://docs.google.com/presentation/u/0/d/1P0BJFU0cjZuf5l-dHfg4pgOqJ24ZAXQ-/mobilepresent">slideshare</a>에 공유해주셨고, <a href="https://github.com/raeperd/realworld.go">readworld</a>라는 어플리케이션 개발 및 테스트 도구도 소개해주셨습니다.</p>

<h3 id="dev-in-go-way-go스러움">Dev in Go way (Go스러움)</h3>

<p>Go 스러운 개발은 무엇일까요? Go의 가장 큰 장점 중 하나인 Duck Typing은 인터페이스 기반으로 설계된 어플리케이션이 얼마나 높은 확장성을 가질 수 있는지를 단적으로 보여준다고 생각합니다. 발표자분은 이러한 인터페이스 관점의 설계에 대해서 조금 더 심도있는 내용을 전달해주셨습니다.</p>

<p><strong>Small Interface</strong></p>

<p>인터페이스를 크게 정의할수록, 불필요한 기능을 의존하게 될 가능성이 높아집니다. 예로 Storage라는 인터페이스가 있다고 가정해봅니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Storage</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Save</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">,</span> <span class="n">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
    <span class="n">Load</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="n">Delete</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Backup이라는 객체가 있고, 데이터를 저장(Save)하는 기능만 필요하다고 가정해봅시다. 위처럼 Storage 인터페이스가 정의되어 있으면, 필요하지 않은 Load, Delete를 의존해야 하는 문제가 생길 수 있습니다.</p>

<p>이러한 경우에는 Saver라는 인터페이스를 정의하는 것이 좋습니다. 그리고 Storage는 이렇게 작게 쪼개진 각각의 인터페이스를 포함하도록 설계하는 것이 좋습니다. 이를 통해 작고 명확하게 책임을 분리할 수 있습니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Saver</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Save</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">,</span> <span class="n">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Storage</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Saver</span>
    <span class="n">Loader</span>
    <span class="n">Deleter</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Discover Interface, Not Design</strong></p>

<p>개발초기에 과도한 상상력을 동원해서 인터페이스를 개발하면 어떻게 될까요? 필요하다고 생각해서 정의한 기능을 실제로 사용하지 않아서 불필요하게 코드가 낭비될 수 있습니다.</p>

<p>따라서 도메인을 먼저 파악하고 필요한 추상화만 진행하는 것이 좋습니다. 구현전에 완벽한 인터페이스를 예측하려고 시도하는 것은 잘못된 방식입니다. 
추가로 함수형 어댑터를 구현하면, 별도의 인터페이스가 필요할 때 동일한 규격을 갖는 인터페이스 여부를 확인하고 대체할 수 있습니다.</p>

<p><strong>Accept interface, return structs</strong></p>

<p>최소한만 요구하고, 최대한으로 제공할 수 있도록 설계해야 합니다. 꼭 인터페이스 타입으로 반환하지 않아도 된다면, 구조체 타입으로 반환하는 것도 좋습니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ProcessData</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ProcessData</span><span class="p">(</span><span class="n">r</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span> <span class="p">(</span><span class="n">o</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Options pattern</strong></p>

<p>인자값이 계속 늘어나게 되면, 코드의 모호함이 증가할 수 있습니다. 이를 ‘멀리 있는 별을 보기 위해 망원경을 계속 앞으로 뺀다’는 의미로 Telescoping Constructer Anti-Pattern라고도 부릅니다. 아래와 같이 A라는 함수가 있을 때, A라는 함수를 호출하기 위해 추가적인 인자가 필요할때마다 함수를 만들게 되면 오히려 코드를 이해하기 어렵게 될 수도 있습니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 나쁜 예: 인자가 계속 늘어나는 경우</span>
<span class="k">func</span> <span class="n">NewServer</span><span class="p">(</span><span class="n">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">Server</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">NewServerWithTimeout</span><span class="p">(</span><span class="n">addr</span> <span class="kt">string</span><span class="p">,</span> <span class="n">timeout</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="o">*</span><span class="n">Server</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">NewServerWithTimeoutAndMaxConn</span><span class="p">(</span><span class="n">addr</span> <span class="kt">string</span><span class="p">,</span> <span class="n">timeout</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">,</span> <span class="n">maxConn</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">Server</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="c">// 계속 늘어남...</span>
</code></pre></div></div>

<p>간혹 Builder 패턴을 사용하기도 하지만 추천하지는 않습니다. 가장 큰 이유로 build 과정에 validation이 집중될 수 있기 때문입니다. 그렇다면 SetX 함수에서 validation을 하면 해결될까요? 오히려 SetX 함수에서 에러가 발생하는 경우, 각 SetX 함수에서 발생하는 여러 에러들이 체이닝되지 않는 문제가 생길 수도 있습니다.</p>

<p>가장 좋은 해결방안은 private 형태의 <code class="language-plaintext highlighter-rouge">option</code> 구조체를 만들고, 이걸 사용하는 것입니다.</p>

<ul>
  <li>확장성: 새로운 옵션을 추가해도 기존 코드에 영향 없음</li>
  <li>가독성: 각 옵션의 의미가 명확함 (<code class="language-plaintext highlighter-rouge">WithTimeout(60*time.Second)</code>)</li>
  <li>선택적 설정: 필요한 옵션만 설정 가능</li>
  <li>기본값: 옵션을 지정하지 않으면 기본값 사용</li>
  <li>순서 무관: 옵션의 순서에 상관없이 설정 가능</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="c">// Server 구조체</span>
<span class="k">type</span> <span class="n">Server</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">addr</span>    <span class="kt">string</span>
    <span class="n">timeout</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span>
    <span class="n">maxConn</span> <span class="kt">int</span>
    <span class="n">tls</span>     <span class="kt">bool</span>
<span class="p">}</span>

<span class="c">// private options 구조체</span>
<span class="k">type</span> <span class="n">options</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">timeout</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span>
    <span class="n">maxConn</span> <span class="kt">int</span>
    <span class="n">tls</span>     <span class="kt">bool</span>
<span class="p">}</span>

<span class="c">// Option 함수 타입 정의</span>
<span class="k">type</span> <span class="n">Option</span> <span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">options</span><span class="p">)</span>

<span class="c">// 각 옵션을 설정하는 함수들</span>
<span class="k">func</span> <span class="n">WithTimeout</span><span class="p">(</span><span class="n">t</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="n">Option</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">o</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">o</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">t</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">WithMaxConnections</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="n">Option</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">o</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">o</span><span class="o">.</span><span class="n">maxConn</span> <span class="o">=</span> <span class="n">n</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">WithTLS</span><span class="p">(</span><span class="n">enabled</span> <span class="kt">bool</span><span class="p">)</span> <span class="n">Option</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">o</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">o</span><span class="o">.</span><span class="n">tls</span> <span class="o">=</span> <span class="n">enabled</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// NewServer 생성자 - 가변 인자로 Option을 받음</span>
<span class="k">func</span> <span class="n">NewServer</span><span class="p">(</span><span class="n">addr</span> <span class="kt">string</span><span class="p">,</span> <span class="n">opts</span> <span class="o">...</span><span class="n">Option</span><span class="p">)</span> <span class="o">*</span><span class="n">Server</span> <span class="p">{</span>
    <span class="c">// 기본값 설정</span>
    <span class="n">options</span> <span class="o">:=</span> <span class="n">options</span><span class="p">{</span>
        <span class="n">timeout</span><span class="o">:</span> <span class="m">30</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span>
        <span class="n">maxConn</span><span class="o">:</span> <span class="m">100</span><span class="p">,</span>
        <span class="n">tls</span><span class="o">:</span>     <span class="no">false</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="c">// 전달받은 옵션들을 적용</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">opts</span> <span class="p">{</span>
        <span class="n">opt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Server</span><span class="p">{</span>
        <span class="n">addr</span><span class="o">:</span>    <span class="n">addr</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">:</span> <span class="n">options</span><span class="o">.</span><span class="n">timeout</span><span class="p">,</span>
        <span class="n">maxConn</span><span class="o">:</span> <span class="n">options</span><span class="o">.</span><span class="n">maxConn</span><span class="p">,</span>
        <span class="n">tls</span><span class="o">:</span>     <span class="n">options</span><span class="o">.</span><span class="n">tls</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 사용 예시</span>
    
    <span class="c">// 1. 기본값만 사용</span>
    <span class="n">s1</span> <span class="o">:=</span> <span class="n">NewServer</span><span class="p">(</span><span class="s">"localhost:8080"</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Server 1: %+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
    
    <span class="c">// 2. 일부 옵션만 설정</span>
    <span class="n">s2</span> <span class="o">:=</span> <span class="n">NewServer</span><span class="p">(</span><span class="s">"localhost:8080"</span><span class="p">,</span>
        <span class="n">WithTimeout</span><span class="p">(</span><span class="m">60</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Server 2: %+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
    
    <span class="c">// 3. 여러 옵션 설정</span>
    <span class="n">s3</span> <span class="o">:=</span> <span class="n">NewServer</span><span class="p">(</span><span class="s">"localhost:8080"</span><span class="p">,</span>
        <span class="n">WithTimeout</span><span class="p">(</span><span class="m">60</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">),</span>
        <span class="n">WithMaxConnections</span><span class="p">(</span><span class="m">200</span><span class="p">),</span>
        <span class="n">WithTLS</span><span class="p">(</span><span class="no">true</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Server 3: %+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span>
    
    <span class="c">// 4. 순서에 상관없이 설정 가능</span>
    <span class="n">s4</span> <span class="o">:=</span> <span class="n">NewServer</span><span class="p">(</span><span class="s">"localhost:8080"</span><span class="p">,</span>
        <span class="n">WithTLS</span><span class="p">(</span><span class="no">true</span><span class="p">),</span>
        <span class="n">WithTimeout</span><span class="p">(</span><span class="m">45</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Server 4: %+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s4</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="go로-밑바닥부터-맨-땅에-헤딩하듯-만드는-p2p-블록체인-네트워크">Go로 밑바닥부터 맨 땅에 헤딩하듯 만드는 P2P 블록체인 네트워크</h3>

<p>이 발표가 있을때 개인적인 일이 있어서 듣지 못했네요😭.</p>

<h3 id="sync-패키지를-활용해서-강력한-버퍼링-만들기--부제-실제-사례로-살펴보는-go의-간편한-동시성-프로그래밍">sync 패키지를 활용해서 강력한 버퍼링 만들기 / 부제: 실제 사례로 살펴보는 Go의 간편한 동시성 프로그래밍</h3>

<p>사실 굉장히 관심있는 내용이었는데, 이날 컨퍼런스 이후에 중요한 일정이 있어서 다 듣지 못하고 나왔습니다😭. 이 내용이 조금 앞에 있었으면 좋았을 것 같다는 개인적인 아쉬움이 있었지만, 한편으로는 나머지 내용들이 너무 좋았어서 어쩔수 없는 상황이었다고 생각하기로 했습니다.</p>

<p>블록체인은 저장한 모든 데이터를 블록에 보관하기 때문에, 시간이 길어질수록 블록을 조회하고 의미있는 데이터를 추출하는데 걸리는 시간이 계속 증가하게 됩니다. 이를 보완하기 위해서 Indexer라는 블록체인 네트워크 조회용 서비스를 사용하는데, Indexer는 블록체인에 담긴 트랜잭션의 내용 또는 블록의 정보를 주기적으로 데이터베이스에 저장하고, 이 저장된 정보를 바탕으로 블록체인의 내부 정보를 실시간으로 확인할 수 있도록 도와주는 도구를 지칭하는 이름입니다.</p>

<p>물론 조회하고자 하는 데이터가 이미 데이터베이스에 동기화 되어있는, 시간이 어느정도 지난 블록이면 괜찮겠지만, 실시간으로 생성된 블록의 정보를 Indexer로부터 요구한다던가, 혹은 블록이 동기화되고 있는 시점에 Indexer로부터 정보 조회를 시도하는 등의 문제들이 발생할 수도 있습니다.</p>

<p>발표자분께서는 블록 정보들을 Worker Pool 이라는 특정 버퍼에 담아두고, 이걸 Sync 패키지를 사용하여 안전하고 빠르게 데이터베이스와 동기화하는 방법을 설명하려고 했던 것 같습니다. 내용을 듣지 못해 정확히 적기는 어렵지만, 정말 유익한 내용이었을텐데 아쉽네요.</p>

<h2 id="후기">후기</h2>

<p>한 발표자분께서 ‘Go언어를 사랑하는 사람들이 한자리에 모여서 관심사를 공유하고 이야기를 나눌 수 있어서 행복하다’고 하셨는데, 실제로 현장에 와보니 그런 분위기가 많이 느껴졌습니다.</p>

<p>언어에 대해 크게 감수성이 있는 편은 아니지만, 적어도 내가 가장 많이 사용하고 있는 기술에 대해서 진지하게 고민하고 더 나은 방향을 찾아가면서 인사이트를 공유할 수 있는 행사에 참석할 수 있어서 정말 좋았습니다. 2026년에도 좋은 내용이 담긴 GopherCon이 이어지길 기대해봅니다.</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><category term="golang" /><category term="gophercon" /><category term="gophercon korea" /><category term="gophercon korea 2025" /><category term="conference" /><category term="backend" /><category term="고퍼콘" /><category term="고퍼콘 코리아" /><category term="고퍼콘 2025" /><category term="고퍼콘 코리아 2025" /><summary type="html"><![CDATA[2025.11.09에 진행되었던 GopherCon Korea (고퍼콘 코리아) 2025에 참석한 후기와 소감을 적어본다.]]></summary></entry><entry xml:lang="en"><title type="html">Comparison of Go HTTP Libraries: fasthttp vs net/http</title><link href="http://localhost:4000/2025/11/11/comparison-go-http-lib-en/" rel="alternate" type="text/html" title="Comparison of Go HTTP Libraries: fasthttp vs net/http" /><published>2025-11-11T00:00:00+09:00</published><updated>2025-11-11T00:00:00+09:00</updated><id>http://localhost:4000/2025/11/11/comparison-go-http-lib-en</id><content type="html" xml:base="http://localhost:4000/2025/11/11/comparison-go-http-lib-en/"><![CDATA[<p>When building a web server in Go, you can use various server frameworks in addition to the default library, net/http. The three most famous frameworks are Gin, Fiber, and Echo, and the internal libraries each framework uses are as follows:</p>
<ul>
  <li><a href="https://github.com/gin-gonic/gin">Gin</a>, <a href="https://github.com/labstack/echo">Echo</a>: net/http</li>
  <li><a href="https://github.com/gofiber/fiber">Fiber</a>: fasthttp</li>
</ul>

<p>In the end, developers choose between net/http and <a href="https://github.com/valyala/fasthttp">fasthttp</a>. fasthttp offers overwhelming performance, while net/http provides versatility and stability. In this post, I intend to compare and analyze the fundamental differences between these two libraries. Furthermore, I will explore why fasthttp does not support HTTP/2, where the performance difference comes from, and even the specific use cases and code-level differences for each library.</p>

<h2 id="fasthttp-and-http2-why-its-not-supported">fasthttp and HTTP/2: Why It’s Not Supported</h2>

<p>The reason fasthttp does not support HTTP/2 is not a simple feature omission; it’s because the library’s core philosophy and architecture fundamentally conflict with the structure of HTTP/2.</p>

<p>The issue of fasthttp’s potential support for HTTP/2 has been a topic since 2016. The image below, from an issue in the <a href="https://github.com/valyala/fasthttp">official github repository</a>, shows that http2 was on fasthttp’s TODO list even back then.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/dbe0c31b-09d7-4956-8d75-a8d9b28c718d/image.png" alt="" /></p>

<p>Recently, a library supporting HTTP/2 is being developed at <a href="https://github.com/fasthttp/http2">fasthttp/http2</a>. It is still in the ‘Under construction’ phase, and an official version has not been developed.</p>

<p>fasthttp is a good library to use instead of net/http when the goal is “extreme performance and low memory usage in an HTTP/1.1 environment.” HTTP/2 support not only conflicts with this goal, but a great alternative (net/http) already exists. Therefore, fasthttp focuses on its own domain (HTTP/1.1 high performance). Looking closer, there are three main reasons.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/8434c87c-8a19-46f8-90fd-6ffc82073a97/image.png" alt="" /></p>

<h3 id="1-fundamental-architectural-mismatch">1. Fundamental Architectural Mismatch</h3>

<p>fasthttp is extremely optimized for the HTTP/1.1 protocol.</p>

<ul>
  <li>fasthttp (HTTP/1.1 based)
    <ul>
      <li>‘One connection = One request’ (excluding Keep-alive) is its simple premise. In other words, it has a simple structure where requests and responses are processed sequentially.</li>
      <li>It focuses on memory reuse by reusing the <code class="language-plaintext highlighter-rouge">RequestCtx</code> object to minimize GC (Garbage Collection) overhead.</li>
    </ul>
  </li>
  <li>HTTP/2
    <ul>
      <li>It uses ‘One connection = Multiple Streams’ (Multiplexing).</li>
      <li>Multiple requests and responses can come and go simultaneously and out of order over a single TCP connection, requiring complex state management like per-stream Flow Control and Prioritization.</li>
    </ul>
  </li>
</ul>

<p>fasthttp’s simple memory reuse architecture makes it virtually impossible to manage HTTP/2’s complex multiple streams and states. Supporting HTTP/2 would require a complete rewrite of the library’s core logic, turning it into a completely new library that changes the very advantages fasthttp pursues.</p>

<h3 id="2-implementation-complexity">2. Implementation Complexity</h3>

<p>The main developer of fasthttp (<a href="https://github.com/valyala">valyala</a>) has repeatedly stated that implementing HTTP/2 is a “massive task that requires as much, or more, effort as maintaining the existing library.”</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/58194363-af18-48bc-84cd-14b4333b9ff6/image.png" alt="" /></p>

<p>HTTP/2 is a binary protocol, and complex specs like HPACK for header compression, Server Push, and stream control must be implemented correctly. This is a workload equivalent to building an entirely new HTTP/2 library within fasthttp.</p>

<h3 id="3-the-existence-of-the-standard-library-nethttp">3. The Existence of the Standard Library (net/http)</h3>

<p>The Go language already provides excellent and stable HTTP/2 support in its standard library, net/http. Since Go 1.6 (2016), net/http has automatically supported HTTP/2 with no extra setup, and the official stance of the fasthttp development team is, “If you need HTTP/2, use the standard library net/http.” They even mention, ‘For most cases net/http is much better as it’s easier to use and can handle more cases,’ stating that net/http is a better choice for most environments that don’t require the high performance that fasthttp necessitates.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/8434c87c-8a19-46f8-90fd-6ffc82073a97/image.png" alt="" /></p>

<p>Furthermore, there is no API compatibility between fasthttp and net/http. According to the <a href="https://github.com/valyala/fasthttp?tab=readme-ov-file#switching-from-nethttp-to-fasthttp">official documentation</a>, a converter from net/http to fasthttp handlers exists, but they recommend that if you want to adopt fasthttp, it would be much better to re-implement it from scratch.</p>

<blockquote>
  <p>Unfortunately, fasthttp doesn’t provide an API identical to net/http. See the FAQ for details. There is a net/http -&gt; fasthttp handler converter, but it is better to write fasthttp request handlers by hand in order to use all of the fasthttp advantages.</p>
</blockquote>

<h2 id="so-why-is-fasthttp-faster">So Why Is fasthttp Faster?</h2>

<p>According to the <a href="https://github.com/valyala/fasthttp?tab=readme-ov-file#http-server-performance-comparison-with-nethttp">benchmarks provided by fasthttp</a>, fasthttp shows performance 6 times faster than net/http.</p>

<ul>
  <li>Minimized Memory Allocation (Zero Allocation):
    <ul>
      <li>net/http creates new http.Request and http.ResponseWriter objects for every request, putting a burden on the GC.</li>
      <li>fasthttp aggressively uses sync.Pool to reuse a single struct, fasthttp.RequestCtx. When a request is finished, the object is returned to the pool, minimizing GC occurrences and reducing overall system latency.</li>
    </ul>
  </li>
  <li>Byte Slice (<code class="language-plaintext highlighter-rouge">[]byte</code>) Centric Design:
    <ul>
      <li>net/http converts header keys, URL parameters, etc., to strings (string) to increase ease of use.</li>
      <li>fasthttp processes most data directly as <code class="language-plaintext highlighter-rouge">[]byte</code>, reducing unnecessary conversions to strings and minimizing memory copies/allocations.</li>
      <li>When performance improvement is paramount, it is recommended to use the <a href="https://github.com/valyala/fasthttp?tab=readme-ov-file#unsafe-zero-allocation-conversions">unsafe, zero-allocation conversions provided by fasthttp</a> rather than the default Go methods for converting between <code class="language-plaintext highlighter-rouge">[]byte</code> and <code class="language-plaintext highlighter-rouge">string</code>.</li>
    </ul>
  </li>
</ul>

<h2 id="speed-and-trade-offs">Speed and Trade-offs</h2>

<p>fasthttp offers high speed, but it also has the following disadvantages:</p>

<ul>
  <li>API Compatibility: net/http follows the standard <code class="language-plaintext highlighter-rouge">http.Handler</code> interface. In contrast, fasthttp uses a non-standard interface called <code class="language-plaintext highlighter-rouge">RequestHandler</code>.</li>
  <li>Middleware Ecosystem: net/http is compatible with almost all Go middleware and routers like Gin, Chi, and Echo. fasthttp can only use dedicated middleware, making its ecosystem very limited. (The Fiber framework is the only major one built on fasthttp).</li>
  <li>Protocol Support: net/http perfectly and automatically supports HTTP/2 and HTTP/3. fasthttp does not.</li>
  <li>Memory Management: In net/http, the GC handles it automatically. In fasthttp, manual developer management is required, such as not holding on to the <code class="language-plaintext highlighter-rouge">RequestCtx</code> for too long.</li>
  <li>Ease of Use: net/http is intuitive and safe. fasthttp has low usability, as breaking its rules can easily lead to memory leaks or bugs.</li>
  <li>Streaming: net/http fully supports large-volume streaming, whereas fasthttp’s support is limited.</li>
</ul>

<h2 id="specific-use-cases">Specific Use Cases</h2>

<h3 id="nethttp">net/http</h3>

<ul>
  <li>For almost all web applications and API servers.</li>
  <li>When starting a new project (if specific requirements are not yet defined).</li>
  <li>When a standard middleware ecosystem (Gin, Chi, etc.) is needed.</li>
  <li>For client-facing services where HTTP/2 or HTTP/3 support is essential.</li>
  <li>When streaming processing, such as large file uploads/downloads, is required.</li>
  <li>When development convenience, stability, and maintainability are more important than performance.</li>
</ul>

<h3 id="fasthttp">fasthttp</h3>

<ul>
  <li>When extreme high-throughput performance is required.</li>
  <li>For internal microservices that must handle hundreds of thousands of requests per second.</li>
  <li>For ad bidding (RTB), large-scale proxy servers, or high-performance API gateways.</li>
  <li>When profiling has proven that HTTP request handling itself in net/http is the clear bottleneck.</li>
</ul>

<h2 id="code-level-comparison">Code-Level Comparison</h2>

<p>The biggest code-level difference between the two libraries is that net/http uses the <code class="language-plaintext highlighter-rouge">http.ResponseWriter</code> and <code class="language-plaintext highlighter-rouge">*http.Request</code> interfaces, whereas fasthttp handles everything with a single <code class="language-plaintext highlighter-rouge">*fasthttp.RequestCtx</code> struct.</p>

<ul>
  <li>Signature: net/http is (w, r), fasthttp is (ctx).</li>
  <li>Data Access: net/http uses string (<code class="language-plaintext highlighter-rouge">r.URL.Path</code>), fasthttp uses []byte (<code class="language-plaintext highlighter-rouge">ctx.Path()</code>).</li>
  <li>Object Lifecycle: net/http’s r and w are valid for the entire duration of the request handling.</li>
</ul>

<p>The important point is that <strong>the fasthttp ctx object is immediately returned to the pool and reused as soon as the handler function returns</strong>. If you pass the ctx to a goroutine within a fasthttp handler, by the time the goroutine executes, the ctx may already be handling a different request, which can cause serious problems like concurrency issues.</p>

<p>Let’s look at the differences through handler examples for both.</p>

<h3 id="nethttp-1">net/http</h3>

<p>In net/http, the request and response objects are passed to the handler function separately.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"net/http"</span>
<span class="p">)</span>

<span class="c">// Handler signature: http.ResponseWriter, *http.Request</span>
<span class="k">func</span> <span class="n">helloHandler</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// Query parameter (string)</span>
  <span class="n">name</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">URL</span><span class="o">.</span><span class="n">Query</span><span class="p">()</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"name"</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"World"</span>
  <span class="p">}</span>
  <span class="c">// Write response</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s">"Hello, %s!"</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">http</span><span class="o">.</span><span class="n">HandleFunc</span><span class="p">(</span><span class="s">"/hello"</span><span class="p">,</span> <span class="n">helloHandler</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"net/http server starting on :8080"</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">":8080"</span><span class="p">,</span> <span class="no">nil</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see in the example above, the handler signature is func(http.ResponseWriter, *http.Request), and the request (r) and response (w) objects are separate, making it intuitive to understand.</p>

<h3 id="fasthttp-1">fasthttp</h3>

<p>fasthttp passes only the context object *fasthttp.RequestCtx to the handler.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"https://github.com/valyala/fasthttp"</span>
<span class="p">)</span>

<span class="c">// Handler signature: *fasthttp.RequestCtx</span>
<span class="k">func</span> <span class="n">helloHandler</span><span class="p">(</span><span class="n">ctx</span> <span class="o">*</span><span class="n">fasthttp</span><span class="o">.</span><span class="n">RequestCtx</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// Query parameter ([]byte)</span>
  <span class="n">name</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">QueryArgs</span><span class="p">()</span><span class="o">.</span><span class="n">Peek</span><span class="p">(</span><span class="s">"name"</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"World"</span>
  <span class="p">}</span>
  <span class="c">// Write response (directly to ctx)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">"Hello, %s!"</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">requestHandler</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">ctx</span> <span class="o">*</span><span class="n">fasthttp</span><span class="o">.</span><span class="n">RequestCtx</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="kt">string</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">Path</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s">"/hello"</span><span class="o">:</span>
      <span class="n">helloHandler</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="n">ctx</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">"Unsupported path"</span><span class="p">,</span> <span class="n">fasthttp</span><span class="o">.</span><span class="n">StatusNotFound</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"fasthttp server starting on :8081"</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fasthttp</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">":8081"</span><span class="p">,</span> <span class="n">requestHandler</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Unlike net/http, fasthttp uses the <code class="language-plaintext highlighter-rouge">func(*fasthttp.RequestCtx)</code> handler signature, and the single ctx object handles both accessing request information and writing the response. Also, data is processed as <code class="language-plaintext highlighter-rouge">[]byte</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Looking back on when I used to design server APIs, I think I used to first worry about ‘how fast can it process requests.’ That’s why I mostly used Fiber, which provides fasthttp. However, if I had first clearly defined the requirements, such as what data the server would process and in what environment it needed to operate, I wonder if I wouldn’t have used net/http directly or a framework that supports it from a different perspective than performance.</p>

<p>I recently attended GopherCon. A presenter mentioned that ‘when implementing a general server in Go without clear requirements, using net/http directly or using the Gin framework is most recommended.’ Unless extreme performance improvements are required, applying the most versatile framework or using the pure library provided by Go could be a better choice for future maintainability. It was a time to think about that.</p>

<p>In conclusion, I think it’s a good choice to use fasthttp when you can precisely control concurrent data processing on a server that requires high performance, and to use net/http otherwise.</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Comparison of Go HTTP Libraries: fasthttp vs net/http]]></summary></entry><entry xml:lang="ko"><title type="html">Go HTTP 라이브러리 비교: fasthttp vs net/http</title><link href="http://localhost:4000/2025/11/11/comparison-go-http-lib/" rel="alternate" type="text/html" title="Go HTTP 라이브러리 비교: fasthttp vs net/http" /><published>2025-11-11T00:00:00+09:00</published><updated>2025-11-11T00:00:00+09:00</updated><id>http://localhost:4000/2025/11/11/comparison-go-http-lib</id><content type="html" xml:base="http://localhost:4000/2025/11/11/comparison-go-http-lib/"><![CDATA[<p>Go 언어로 웹서버를 구축할 때, 기본적으로 제공하는 라이브러리인 net/http를 외에도 다양한 서버 프레임워크들을 사용할 수 있습니다. 가장 유명한 3개의 프레임워크인 Gin, Fiber, Echo가 있는데요, 각 프레임워크들이 사용하는 내부 라이브러리들은 아래와 같습니다.</p>
<ul>
  <li><a href="https://github.com/gin-gonic/gin">Gin</a>, <a href="https://github.com/labstack/echo">Echo</a>: net/http</li>
  <li><a href="https://github.com/gofiber/fiber">Fiber</a>: fasthttp</li>
</ul>

<p>결국 개발자는 net/http, <a href="https://github.com/valyala/fasthttp">fasthttp</a>중 하나의 라이브러리를 선택하게 되는데요, fasthttp는 압도적인 성능을 제공하고 net/http는 범용성과 안정성을 제공합니다. 이번 포스팅에서는 두 라이브러리의 근본적인 차이점을 비교 분석하려고 합니다. 더 나아가 fasthttp가 왜 HTTP/2를 지원하지 않는지, 성능 차이는 어디에서 오는지, 그리고 각 라이브러리의 구체적인 사용 사례와 코드 레벨의 차이점까지 작성해보려고 합니다.</p>

<h2 id="fasthttp와-http2-지원되지-않는-이유">fasthttp와 HTTP/2: 지원되지 않는 이유</h2>

<p>fasthttp가 HTTP/2를 지원하지 않는 이유는 단순한 기능 누락이 아니라, 라이브러리의 핵심 철학 및 아키텍처와 HTTP/2의 구조가 근본적으로 충돌하기 때문입니다.</p>

<p>fasthttp의 HTTP/2를 지원 가능에 대한 이슈는 2016년부터 이어진 주제입니서. <a href="https://github.com/valyala/fasthttp">공식 github 리포지토리</a>의 이슈에서 가져온 아래 그림을 보면, 그 당시부터 http2는 fasthttp의 TODO 리스트에 존재했습니다.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/dbe0c31b-09d7-4956-8d75-a8d9b28c718d/image.png" alt="" /></p>

<p>최근에는 <a href="https://github.com/fasthttp/http2">fasthttp/http2</a>에서 HTTP/2를 지원하는 라이브러리를 개발하고 있습니다. 아직은 Under construction 단계로, 정식 버전이 개발되진 않았습니다.</p>

<p>fasthttp는 “HTTP/1.1 환경에서 극한의 성능과 낮은 메모리 사용량”을 목표로 할때 net/http를 대신하여 사용하기 좋은 라이브러리입니다. HTTP/2 지원은 이 목표와 상충될 뿐만 아니라 net/http라는 훌륭한 대안이 존재하기 때문에, fasthttp는 자신의 영역(HTTP/1.1 고성능)에 집중하고 있습니다. 좀더 자세히 살펴보면 아래의 3가지 원인이 있습니다.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/8434c87c-8a19-46f8-90fd-6ffc82073a97/image.png" alt="" /></p>

<h3 id="1-아키텍처의-근본적인-불일치">1. 아키텍처의 근본적인 불일치</h3>

<p>fasthttp는 HTTP/1.1 프로토콜에 극단적으로 최적화되어 있습니다.</p>

<ul>
  <li>fasthttp (HTTP/1.1 기반)
    <ul>
      <li>‘하나의 연결 = 하나의 요청’ (Keep-alive 제외)이라는 단순한 모델을 전제로 합니다. 즉, 요청과 응답이 순차적으로 처리되는 간단한 구조입니다.</li>
      <li><code class="language-plaintext highlighter-rouge">RequestCtx</code> 객체를 재사용하여 GC(가비지 컬렉션) 오버헤드를 최소화하는 메모리 재사용에 중점을 둡니다.</li>
    </ul>
  </li>
  <li>HTTP/2
    <ul>
      <li>‘하나의 연결 = 다중 스트림(Streams)’ (Multiplexing)을 사용합니다.</li>
      <li>하나의 TCP 연결을 통해 여러 요청과 응답이 동시에, 순서에 상관없이 오고 갈 수 있으며, 스트림별 흐름 제어(Flow Control), 우선순위 지정(Prioritization) 등 복잡한 상태 관리가 필요합니다.</li>
    </ul>
  </li>
</ul>

<p>fasthttp의 단순한 메모리 재사용 아키텍처로는 HTTP/2의 복잡한 다중 스트림과 상태를 관리하기가 사실상 불가능합니다. HTTP/2를 지원하려면 라이브러리의 핵심 로직을 완전히 새로 작성해야하는데, 이는 fasthttp가 추구하는 장점을 바꿔버리는 수준의 완전히 새로운 라이브러리가 됩니다.</p>

<h3 id="2-구현의-복잡성">2. 구현의 복잡성</h3>

<p>fasthttp의 메인 개발자(<a href="https://github.com/valyala">valyala</a>)는 HTTP/2를 구현하는 것이 “기존 라이브러리 유지보수와 맞먹는, 혹은 그 이상의 노력이 드는 거대한 작업”이라고 여러 차례 언급했습니다.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/58194363-af18-48bc-84cd-14b4333b9ff6/image.png" alt="" /></p>

<p>HTTP/2는 바이너리(Binary) 프로토콜이며, 헤더 압축을 위한 HPACK, 서버 푸시(Server Push), 스트림 제어 등 매우 복잡한 스펙을 정확히 구현해야 합니다. 이는 사실상 fasthttp 내부에 완전히 새로운 HTTP/2 라이브러리를 하나 더 만드는 것과 같은 업무량입니다.</p>

<h3 id="3-표준-라이브러리의-존재-nethttp">3. 표준 라이브러리의 존재 (net/http)</h3>

<p>Go 언어는 이미 표준 라이브러리인 net/http에서 매우 훌륭하고 안정적인 HTTP/2를 지원합니다. net/http는 Go 1.6(2016년)부터 별도 설정 없이도 자동으로 HTTP/2를 지원하며, fasthttp 개발팀의 공식 입장도 “HTTP/2가 필요하다면 표준 라이브러리 net/http를 사용하라”는 것입니다. 심지어 ‘For most cases net/http is much better as it’s easier to use and can handle more cases’ 라고 언급하면서, fasthttp가 꼭 필요한 고성능의 환경이 필요하지 않은 대부분의 환경에서는 net/http가 더 좋은 선택이라고 말합니다.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/8434c87c-8a19-46f8-90fd-6ffc82073a97/image.png" alt="" /></p>

<p>또한 fasthttp와 net/http 사이에 일치하는 API도 없는데요. <a href="https://github.com/valyala/fasthttp?tab=readme-ov-file#switching-from-nethttp-to-fasthttp">공식 문서</a>에 따르면, net/http -&gt; fasthttp로 변형해주는 컨버터가 존재하지만, fasthttp를 적용하고 싶다면 차라리 처음부터 다시 적용하는 것이 훨씬 좋을 것이라고 권장하고 있습니다.</p>

<blockquote>
  <p>Unfortunately, fasthttp doesn’t provide API identical to net/http. See the FAQ for details. There is net/http -&gt; fasthttp handler converter, but it is better to write fasthttp request handlers by hand in order to use all of the fasthttp advantages.</p>
</blockquote>

<h2 id="그렇다면-fasthttp는-왜-더-빠른가">그렇다면 fasthttp는 왜 더 빠른가?</h2>

<p><a href="https://github.com/valyala/fasthttp?tab=readme-ov-file#http-server-performance-comparison-with-nethttp">fasthttp에서 제공하는 벤치마크</a>에 따르면, fasthttp는 net/http보다 6배 더 빠른 성능을 보여줍니다.</p>

<ul>
  <li>메모리 할당 최소화 (Zero Allocation):
    <ul>
      <li>net/http는 모든 요청마다 http.Request와 http.ResponseWriter 객체를 새로 생성하여 GC에 부담을 줍니다.</li>
      <li>fasthttp는 sync.Pool을 적극적으로 사용하여 fasthttp.RequestCtx라는 단일 구조체를 재사용합니다. 요청이 끝나면 객체를 풀(Pool)에 반환하여 GC 발생을 최소화하고 시스템 전체의 지연 시간을 줄입니다.</li>
    </ul>
  </li>
  <li>바이트 슬라이스([]byte) 중심 설계:
    <ul>
      <li>net/http는 헤더 키, URL 파라미터 등을 문자열(string)로 변환하여 사용 편의성을 높입니다.</li>
      <li>fasthttp는 대부분의 데이터를 []byte로 직접 처리하여, 문자열로의 불필요한 변환 및 메모리 복사/할당을 줄입니다.</li>
      <li>성능 향상이 제일 중요한 경우, []byte와 string을 변환할때 Go에서 기본적으로 제공하는 방식을 사용하는 것보다 <a href="https://github.com/valyala/fasthttp?tab=readme-ov-file#unsafe-zero-allocation-conversions">fasthttp에서 제공하는 unsafe, zero-allocation</a>을 사용할 것을 권장합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="속도와-트레이드오프">속도와 트레이드오프</h2>

<p>fasthttp는 빠른 속도를 제공하지만, 아래와 같은 단점 또한 존재합니다.</p>

<ul>
  <li>API 호환성: net/http는 http.Handler라는 표준 인터페이스를 따릅니다. 반면 fasthttp는 <code class="language-plaintext highlighter-rouge">RequestHandler</code>라는 비표준 인터페이스를 사용합니다.</li>
  <li>미들웨어 생태계: net/http는 Gin, Chi, Echo 등 거의 모든 Go 미들웨어 및 라우터와 호환됩니다. fasthttp는 전용 미들웨어만 사용 가능하여 생태계가 매우 제한적입니다. (유일하게 Fiber 프레임워크가 fasthttp를 기반으로 만들어졌습니다)</li>
  <li>프로토콜 지원: net/http는 HTTP/2와 HTTP/3를 완벽하게 자동 지원합니다. fasthttp는 미지원입니다.</li>
  <li>메모리 관리: net/http는 GC가 자동으로 처리합니다. fasthttp는 RequestCtx를 오래 잡고 있으면 안 되는 등 개발자의 수동 관리가 필요합니다.</li>
  <li>사용 편의성: net/http는 직관적이고 안전합니다. fasthttp는 규칙을 어기면 메모리 누수나 버그가 발생하기 쉬워 사용 편의성이 낮습니다.</li>
  <li>스트리밍: net/http는 대용량 스트리밍을 완벽 지원하지만, fasthttp는 제한적입니다.</li>
</ul>

<h2 id="구체적인-사용-사례">구체적인 사용 사례</h2>

<h3 id="nethttp">net/http</h3>

<ul>
  <li>거의 모든 웹 애플리케이션 및 API 서버에서 사용 가능</li>
  <li>프로젝트를 처음 시작할 때 (구체적인 요구사항이 정의되지 않았을 경우)</li>
  <li>Gin, Chi 등 표준 미들웨어 생태계가 필요한 경우</li>
  <li>HTTP/2 또는 HTTP/3 지원이 필수적인 클라이언트 대면 서비스</li>
  <li>대용량 파일 업로드/다운로드 등 스트리밍 처리가 필요한 경우</li>
  <li>개발 편의성, 안정성, 유지보수성이 성능보다 중요한 경우</li>
</ul>

<h3 id="fasthttp">fasthttp</h3>

<ul>
  <li>극단적인 초고성능(High-Throughput)이 요구되는 경우</li>
  <li>초당 수십만 건 이상의 요청을 처리해야 하는 내부 마이크로서비스</li>
  <li>광고 입찰(RTB), 대규모 프록시 서버, 하이 퍼포먼스 API 게이트웨이</li>
  <li>net/http로 프로파일링 결과, HTTP 요청 처리 자체가 명백한 병목임이 입증된 경우</li>
</ul>

<h2 id="코드-레벨-비교">코드 레벨 비교</h2>

<p>두 라이브러리의 가장 큰 코드 레벨 차이점은 net/http가 <code class="language-plaintext highlighter-rouge">http.ResponseWriter</code>와 <code class="language-plaintext highlighter-rouge">*http.Request</code> 인터페이스를 사용하는 반면, fasthttp는 모든 것을 <code class="language-plaintext highlighter-rouge">*fasthttp.RequestCtx</code> 단일 구조체로 처리한다는 것입니다.</p>

<ul>
  <li>시그니처: net/http는 (w, r), fasthttp는 (ctx).</li>
  <li>데이터 접근: net/http는 string (<code class="language-plaintext highlighter-rouge">r.URL.Path</code>), fasthttp는 []byte (<code class="language-plaintext highlighter-rouge">ctx.Path()</code>).</li>
  <li>객체 생명주기: net/http의 r과 w는 요청 처리 내내 유효합니다.</li>
</ul>

<p>중요한 점은, <strong>fasthttp의 ctx 객체는 핸들러 함수가 반환(return)되는 즉시 풀(Pool)로 돌아가 재사용</strong>됩니다. 만약 fasthttp 핸들러 내에서 고루틴(goroutine)을 실행하며 ctx를 전달하면, 고루틴이 실행될 시점에는 ctx가 이미 다른 요청을 처리하고 있을 수 있어 동시성 문제와 같은 심각한 문제가 발생할 수 있습니다.</p>

<p>두 방식의 핸들러 예시를 통해 차이점을 살펴보겠습니다.</p>

<h3 id="nethttp-1">net/http</h3>

<p>net/http는 요청과 응답 객체가 별도로 핸들러 함수에 전달됩니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"net/http"</span>
<span class="p">)</span>

<span class="c">// 핸들러 시그니처: http.ResponseWriter, *http.Request</span>
<span class="k">func</span> <span class="n">helloHandler</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 쿼리 파라미터 (string)</span>
	<span class="n">name</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">URL</span><span class="o">.</span><span class="n">Query</span><span class="p">()</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"name"</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
		<span class="n">name</span> <span class="o">=</span> <span class="s">"World"</span>
	<span class="p">}</span>
	<span class="c">// 응답 작성</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s">"Hello, %s!"</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">http</span><span class="o">.</span><span class="n">HandleFunc</span><span class="p">(</span><span class="s">"/hello"</span><span class="p">,</span> <span class="n">helloHandler</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"net/http server starting on :8080"</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">":8080"</span><span class="p">,</span> <span class="no">nil</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 예시에서 볼 수 있듯이, 핸들러 시그니처가 <code class="language-plaintext highlighter-rouge">func(http.ResponseWriter, *http.Request)</code>이며, 요청(r)과 응답(w) 객체가 분리되어 직관적으로 이해할 수 있습니다.</p>

<h3 id="fasthttp-1">fasthttp</h3>

<p>fasthttp는 컨텍스트 객체 <code class="language-plaintext highlighter-rouge">*fasthttp.RequestCtx</code> 하나만 핸들러에 전달합니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"github.com/valyala/fasthttp"</span>
<span class="p">)</span>

<span class="c">// 핸들러 시그니처: *fasthttp.RequestCtx</span>
<span class="k">func</span> <span class="n">helloHandler</span><span class="p">(</span><span class="n">ctx</span> <span class="o">*</span><span class="n">fasthttp</span><span class="o">.</span><span class="n">RequestCtx</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 쿼리 파라미터 ([]byte)</span>
	<span class="n">name</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">QueryArgs</span><span class="p">()</span><span class="o">.</span><span class="n">Peek</span><span class="p">(</span><span class="s">"name"</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
		<span class="n">name</span> <span class="o">=</span> <span class="s">"World"</span>
	<span class="p">}</span>
	<span class="c">// 응답 작성 (ctx에 직접)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">"Hello, %s!"</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">requestHandler</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">ctx</span> <span class="o">*</span><span class="n">fasthttp</span><span class="o">.</span><span class="n">RequestCtx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="kt">string</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">Path</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">case</span> <span class="s">"/hello"</span><span class="o">:</span>
			<span class="n">helloHandler</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="n">ctx</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">"Unsupported path"</span><span class="p">,</span> <span class="n">fasthttp</span><span class="o">.</span><span class="n">StatusNotFound</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"fasthttp server starting on :8081"</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fasthttp</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">":8081"</span><span class="p">,</span> <span class="n">requestHandler</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>net/http와 다르게, fasthttp에서는 <code class="language-plaintext highlighter-rouge">func(*fasthttp.RequestCtx)</code> 핸들러 시그니처를 사용하며, ctx 객체 하나로 요청 정보 접근과 응답 작성을 모두 처리합니다. 또한 데이터가 []byte로 처리됩니다.</p>

<h2 id="결론">결론</h2>

<p>예전에 제가 서버 API를 설계할 때를 돌아보면, ‘얼마나 빠르게 요청을 처리할 수 있는가’를 먼저 고민했던 것 같습니다. 그래서 대부분 fasthttp를 제공하는 fiber를 사용했었는데요. 하지만 서버가 어떤 데이터를 처리할지, 그리고 서버가 어떤 환경에서 동작해야하는지 등의 요구사항을 먼저 명확하게 정의했다면 성능이 아닌 다른 관점에서 net/http를 직접 사용하거나 혹은 이를 지원하는 프레임워크를 사용하지 않았을까 싶습니다.</p>

<p>최근에 gophercon을 다녀왔는데요. <a href="https://gophercon.kr/program/sessions/session-3">발표자</a>분께서 ‘명확한 요구사항이 없는 일반적인 서버를 Go로 구현할 경우, net/http를 직접 사용하거나 Gin 프레임워크 사용을 가장 권장한다’고 말씀하셨습니다. 극도의 성능 개선이 요구되는 경우가 아니라면, 가장 범용적으로 설계하고 사용할 수 있는 프레임워크를 적용하거나, 혹은 Go에서 제공하는 순수 라이브러리를 적용하는 것이 향후 유지보수 측면에서도 더욱 좋은 선택이 될 수 있겠다고 생각할 수 있는 시간이었습니다.</p>

<p>결론적으로, 높은 성능을 요구하는 서버에서 데이터 동시처리를 정확하게 제어할 수 있는 경우에 fasthttp를, 그 외에는 net/http를 사용하는 것이 좋은 선택이 되지 않을까 생각합니다.</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Go HTTP 라이브러리 비교: fasthttp vs net/http]]></summary></entry><entry xml:lang="ko"><title type="html">회고록:10월</title><link href="http://localhost:4000/2025/10/29/retrospect/" rel="alternate" type="text/html" title="회고록:10월" /><published>2025-10-29T00:00:00+09:00</published><updated>2025-10-29T00:00:00+09:00</updated><id>http://localhost:4000/2025/10/29/retrospect</id><content type="html" xml:base="http://localhost:4000/2025/10/29/retrospect/"><![CDATA[<h2 id="추석">추석</h2>

<p>10월에는 한국 고유의 명절 추석이 있었다. 올해 추석은 휴일을 포함해서 약 10일간 쉴 수 있는 시간이었는데, 마침 아내가 직장에서 대기발령을 하라는 요청을 받아서 부득이(?)하게 명절내내 본가에 내려가지 않았다.</p>

<p>사실 나는 ‘명절때 조부모댁에 가지 않고 집에 머무르는 것’을 엄청나게 하고싶어했다. 우리 집에서는 상상도 못할 일이었고, 내 기억에 고3 수험생 시절과 피치못한 사정이 아니고서는 항상 추석에는 조부모댁에 갔었다. 심지어 기억나는 ‘피치못할 사정’에는 해외에 있는 바람에 가지 못한 경우 뿐이었던 것 같다.</p>

<p>아내는, 사실 본인의 의지와 전혀 관련없는 대기발령이었지만, 나에게 굉장히 미안해했다. 혼자서라도 본가에 다녀오고싶으면 그렇게 하라고 했지만, 나는 단칼에 거절했다. 37년을 살면서 처음으로 아무런 문제 없이 추석에 집에만 있을 수 있는 시간인데, 부모님께는 조금 죄송하지만 정말 행복했다.</p>

<p>다행이 아내가 출근하는 상황은 아니었기 때문에, 원래는 날씨 좋은날에 등산도 가고 맛있는것도 먹으러 가려고 했다. 하지만 이것도 하늘의 장난인지, 이번 추석에는 비가 정말 많이 왔다. 날씨가 좋은적이 없었다. 덕분에 집에서 내내 쉬게 되었고, 이 때문에 <a href="#고스트-오브-요테이">절대 손을 대서는 안될 녀석</a>을 시작하고야 말았다.</p>

<h2 id="고스트-오브-요테이">고스트 오브 요테이</h2>

<p>10월 2일. 내가 생각하기엔 매우 계획적인 날짜인 추석의 시작일에, 플레이스테이션 게임이 발매되었다. 꽤 많은 사람들이 역작이라고 표현하였고, 최근에 재미있게 보던 유투버가 이 게임을 리뷰하는것(<a href="https://youtu.be/UfHoEuXIiRU?si=QIzXEQgBsvvNiNvc">영상</a>)을 보게 되면서 ‘추석에 딱히 할것도 없는데 게임이나 해볼까?’ 하는 정말 발칙한 생각을 하게 되었다.</p>

<blockquote>
  <p>참고로 이 유튜버의 <a href="https://youtu.be/-Zk-WyCoIbU?si=2XPvY2ygu3_S7oGi">영상</a>을 재미있게 보고나서, 좋은 핸드폰이 필요없다고 아이폰 13 미니의 배터리를 교체하려던 아내가 17 프로를 구매해버렸다.</p>
</blockquote>

<p>원래 이번 추석에는 책과 강의를 열심히 들으면서 나의 실력을 마음껏 향상시키는 상상을 하고 있었는데, 연휴에 마냥 재미없게 보내는것도 잘못된 생각인것만 같아 거금을 주고 게임을 구매했다. 사람들이 여주 얼굴이 못생겨서 게임하기 싫다고하는데, 나는 그냥 괜찮게 생겼다고 생각한다.</p>

<p>길게 말할 필요 없이, 약 4-5일가량을 하루에 7시간 가까이 게임에 빠져버렸다. 심지어 이 게임은 본 스토리만 있는게 아니라 주변에 발생하는 여러 서브스토리들이 많은데, 추석 연휴기간동안 본편 스토리를 포함해서 대략 60%에 달하는 이야기를 완주해버렸다.</p>

<blockquote>
  <p>현재는 대략 61시간의 게임 플레이와 85%의 트로피를 완료했다. 더이상은 하면 안될것 같다.</p>
</blockquote>

<h2 id="공유-오피스">공유 오피스</h2>

<p>그래서였을까, 10월 중순이 넘어가면서 문득 이번달에 내가 뭘 했는지 도저히 생각이 나지 않았다. 아내에게 진지하게 고민을 털어놓으니, 우선 추석 연휴가 길어서 실제로 일한 시간이 적어서고, 두번째는 계속 재택을 하다보니 점점 집에서 일이 잘되는 시간보다 무기력하게 지내는 시간이 늘어나는 것 같다고 했다.</p>

<p>사실 재택을 하게되면 ‘내가 집중할 수 있는 시간을 최대한으로 사용할 수 있다’는 엄청난 장점이 있다. 물론 출퇴근에 낭비되는 시간과 체력도 없고, 그로인해 받는 스트레스도 현저히 적다. 하지만 이 장점 이면에는 내가 그만큼 집중하는 시간을 만들어서 효율적으로 사용해야 한다는 압박도 있다.</p>

<p>이러면 안된다는 생각에 이것저것 알아보다가 <a href="https://fivespot.io/">파이브스팟</a>에서 운영하는 무제한 공유오피스 입장권을 구매했다. 이걸 사용하면 전국에 약 250개 가까이 되는 제휴 카페, 공유오피스, 그리고 패스트파이브에서 운영하는 파이브스팟 오피스를 마음껏 이용할 수 있다. 나는 집에서 대략 차로 10분정도 걸리는 고척점과 그나마 가까운 영등포점, 여의도점을 주로 이용하고 있다. 확실히 카페에서 하는것보다 훨씬 안정적이고 쾌적하다. 그리고 모두가 집중하고 있는 공간에서 같이 집중하다보니 일의 효율도 훨씬 높아졌다. 매달 들어가는 돈이 대략 15만원정도 되는데, 이 돈을 아까워하는 것보다 15만원어치의 효율과 더 많은 기회를 찾아보라는 아내의 현명한 대답이 기억난다. 역시 현명한 아내는 남편을 성장하게 한다.</p>

<blockquote>
  <p>참고로 추천인 코드를 입력하면 가입 시 할인받을 수 있다: <strong>S1VCY4</strong></p>
</blockquote>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[10월에는 한국 고유의 명절 추석으로 인해 자그마치 10일간의 휴일이 있었다. 그래서 그런가, 10월은 너무 빠르게 지나갔다. 내가 무엇을 했는지 기억하지도 못할정도로.]]></summary></entry><entry xml:lang="ko"><title type="html">회고록:9월</title><link href="http://localhost:4000/2025/09/30/retrospect/" rel="alternate" type="text/html" title="회고록:9월" /><published>2025-09-30T00:00:00+09:00</published><updated>2025-09-30T00:00:00+09:00</updated><id>http://localhost:4000/2025/09/30/retrospect</id><content type="html" xml:base="http://localhost:4000/2025/09/30/retrospect/"><![CDATA[<h2 id="uniswap-강의-참여">Uniswap 강의 참여</h2>

<p>8월말이었나, 링크드인에 아래와 같은 포스트가 올라왔다. 먼저 나는 저 사람을 당시에는 몰랐고, 누군가가 좋아요를 눌렀던 탓에 나에게도 피드가 뜬것 같았다.</p>

<p><br /></p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/53b25df3-0cd3-422a-97cf-247094319dfe/image.png" alt="image" /></p>

<p><br /></p>

<p>올해 5월 이후로 블록체인과 관련된 커리어를 쌓고 있지는 않지만, 그래도 약 6년간 몸담았던 분야다보니 계속해서 관심을 갖고는 있었다. 그러던중 평소에 배우고싶었던 Uniswap이라는 프로젝트에 대한 무료 강의가 나에게 노출되었고, 정말 아무런 고민도 없이 신청했다.</p>

<p>강의는 4주동안 진행되었고, 매주 <strong>생각보다 시간을 많이 소요하는</strong> 과제들이 부여되었다. 스마트 컨트랙트 개발할 때 Truffle, Hardhat만 사용해봤는데, 이번에 Foundry의 사용법에 대해서도 배울 수 있었고, Uniswap의 동작 방식에 대해서도 이해할 수 있었다. 직접 AMM을 스마트 컨트랙트로 구현해보았고, 구현한 컨트랙트를 사용해서 직접 토큰을 교환할 수 있는 웹페이지도 만들어보았다. <a href="https://wnjoon.github.io/2025/09/15/miniamm-dapp-with-ai/">이전 포스트 ‘백엔드 개발자의 AI로 아주 작은 dApp 만들기’</a>에서도 적었듯이, 프론트엔드에 대해 경험이 없었던 나에게 이번 강의에서 진행된 모든 과제들은 정말 많은 도움이 되었다.</p>

<p>사실 강의만큼이나 과제를 만드는 것이 정말 쉽지 않은 부분인데, 좋은 마음으로 모든것을 정말 좋은 퀄리티로 제공해준 <a href="https://www.linkedin.com/in/7oelm/">Joel Mun</a>님께 <em>비록 이 글을 보지 않겠지만</em> 다시한번 감사의 인사를 전하고싶다. 기대에 부응(?)하기 위해 정말 열심히 과제를 했고, 최종적으로 이번 강의의 수료자로 이름이 올라갔고 졸업생 채널에 초대되었다 🎉.</p>

<p><br /></p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/d762c192-5e0f-46d9-970c-c0f58c34e748/image.png" alt="image" /></p>

<p><br /></p>

<h2 id="밋업-더하기-밋업은-밋업의-연속">밋업 더하기 밋업은 밋업의 연속</h2>

<p>5월부터 일하고있는 회사가 전면적으로 재택이 가능하다보니, 1주일동안 나가는 횟수도 거의 없고 심지어 만나는 사람도 없는 경우가 많았다. 지난달에는 내가 사람좀 만나고 다녔으면 좋겠다는 아내의 바램에 따라 <a href="https://www.careerday.jobs/club">커리어데이에서 운영하는 디너클럽</a>에도 참석했다.</p>

<blockquote>
  <p>디너클럽에 대한 후기는 나중에 올릴지 모르겠지만, 정말 좋은 시간이었다. 특히 다양한 직업 속에서 공통된 주제들이 나올 수 있을 법한 사람들을 어떻게 이렇게 모아줄 수 있는지 신기했다. 혹은 모든 직장인이 비슷한 관심거리를 갖고있어서는 아니었을까 하는 생각도 든다.</p>
</blockquote>

<p>특히 아내는 개발자들이 밋업을 통해 공통된 관심사와 주제를 가지고 만난다는 것을 좋아했다. 그래서 나에게도 밋업이 있으면 자주 나가서 사람들과 교류하고 인사이트를 얻고 오기를 바랬는데, 문제는 코로나 이후로 예전만큼 밋업이 활발하지 않았고, 그마저도 내가 관심있는 주제들에 대해 열린 밋업은 열리지 않았다.</p>

<p>그런데 신기하게도 이번 9월은 내가 관심있는 밋업들이 정말 많이 열렸다. 밋업과 북토크를 포함해서 무려 5개의 모임에 참석했다.</p>

<p><strong>ZZIN’ Web3 Builders 2025</strong></p>

<p>위에서 언급한 Uniswap 강의를 진행한 Joel님과 블록체인 빌더에서 꽤 이름이 있는 <a href="https://www.linkedin.com/in/learner-bora/">Bora</a>님이 주최한 ‘Web3 개발자 지망생을 위한 밋업’에 참여했다. 사실 Web3 커뮤니티에 큰 관심이 있는것은 아니었지만, 강의를 진행한 Joel님이 헬퍼를 모집하면서 뭔가 도움을 줄 수 있을것 같아 참여했다 (사실 Web3 개발자가 되기 위한 사람들에게 도움을 주기 위한 모임이라는 것을 밋업 당일에 알았다).</p>

<p>생각이상으로 많은 사람들(약 100명 이상)이 참여했는데, 헬퍼로 돌아다니면서 이런저런 이야기도 귓동냥으로 듣고 링크드인에서만 보던 사람들과 인사도 하는 좋은 시간이었다. 특히 평소에 관심이 많은 스테이블코인에 대해 유명한 책도 쓰신 분이 참여하셨는데, 덕분에 아래에 언급할 북토크에도 참여할 수 있는 기회도 생겼다.</p>

<p><strong>북토크: 스테이블코인의 시대</strong></p>

<p>최근에 스테이블코인에 대해 나온 책중 ‘스테이블코인의 시대’라는 책의 저자인 <a href="https://www.linkedin.com/in/seon-min-yi-21a741151/">Seon Min Yi</a>님이 주최한 북토크에 참여했다. 사실 참여하게 된 계기가 좀 재미있는데, ‘ZZIN’ Web3 Builders 2025’ 밋업에 작가님이 참여하신걸 보고 인사를 드리고 싶었으나, 너무 인기가 많으셔서 멀리서만 지켜볼 수 밖에 없던게 아쉬워서, 밋업이 끝난 후에 개인적으로 링크드인 메시지를 드렸다.</p>

<p><br /></p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/cd07299c-69c5-4a8c-84df-434de285112b/image.png" alt="image" /></p>

<p><br /></p>

<p>마지막에 ‘시간이 괜찮으시면 커피챗을 꼭 하고싶다’고 적었는데, 반대로 작가님께서 이번 북토크가 이미 신청은 마감되었지만 와도 된다고 자리를 열어주셔서 기쁜 마음에 참여할 수 있었다. 역시 두드린 사람만이 기회를 잡을 수 있다는 생각이 들었다.</p>

<p>사실 나는 스테이블코인에 대해 계속해서 의문을 가지고 있다. CBDC, 토큰증권 등 여러 블록체인 프로젝트를 지나면서 생긴 의심이랄까. 혹은 ‘그래서 스테이블코인, 특히 원화 스테이블코인이 꼭 필요한 이유는 뭐야?’는 질문의 답변을 할 정도로 아직 지식이 부족하기 때문이라고 생각했다. 이번 북토크에도 중간에 패널 토론 시간이 있었고, 나서기 좋아하는 성격상 손을 들고 질문했다.</p>

<p>“스테이블코인이 발행되면 국채 매입을 통한 국가 재정이 늘어나기 때문에 국가 입장에서는 좋을 것 같은데요, 그럼 스테이블코인 발행을 통한 기업과 우리같은 사용자들은 뭐가 좋아지나요?”</p>

<p>아뿔사, 앞에 ‘원화’를 붙이는 것을 잊었다. 패널 모더레이터분은 “USDT, USDC가 얼마나 돈을 버는지 먼저 말씀드려야 할 것 같은데요?” 라고 말씀하셨지만, 그건 나도 알고 있는 사실이었다. 나서기 좋아하지만 질문할때 항상 긴장하는 성격탓에 어떻게 질문할지 적어놓고도 핵심적인 내용이 비어있는 질문을 하고 말았다. 어찌되었든 작가님을 포함한 패널분들은 나의 질문에 매우 성심성의껏 답변해주셨다.</p>

<p>그런데 이 북토크에서 가장 의미있던 시간은, 사실 북토크가 모두 종료되고 사인회가 열리는 도중이었다. 사인회가 있을거라고 생각하지 못하고 구매한 책을 집에 두고왔지만, 그래도 이런 자리를 참여하게 해주신 작가님께 고마운 마음이 있어 꼭 인사를 드리고 집에 돌아가야겠다고 생각했다. 하지만 사인 줄이 생각보다 길어서 좀 기다리는 중이었는데, 패널 토론자였던 <a href="https://www.linkedin.com/in/junyoung-jeong-703306113/">Junyoung Jeong</a> 님께서 먼저 인사를 걸어주셨다. 서로 인사를 나누고 이야기를 하던도중, 갑자기 내가 정말로 궁금했던 질문이 입밖으로 나왔다.</p>

<p>“스테이블코인이 요즘 다시 부상하고있는데, 다시 블록체인 개발자로 돌아가야할까요?”</p>

<p>사실 최근에 스테이블코인이 다시 부상하면서, 꽤 많은 블록체인 기업에서 면접 제안을 받는다. 뒤에서도 이야기하겠지만, 나는 앞으로 특정 분야에 전문성을 갖는 개발자가 아닌 AI를 활용해서 목표하는 바를 명확하게 계획하고 이를 에이전트에게 정확하게 지시하고 돌아오는 결과에 대해 검토하고 제대로 질문하는 개발자가 필요한 시대가 오고 있다고 생각한다. 이러한 생각을 하게 된 계기에 대해서는 나중에 따로 포스팅할 기회가 있으면 좋겠지만, 그러다보니 ‘내가 생각한 방식대로 앞으로 나아가야할지, 아니면 시대의 흐름에 다시 몸을 맡겨야할지’에 대한 고민이 있었던 것이다.</p>

<p>그런데 돌아온 대답은 굉장히 간단했다.</p>

<p>“아니요. 결국 스테이블코인은 비지니스가 중요할겁니다.”</p>

<p>앞으로의 개발자의 방향성에 대해 내가 생각하고 있는 바가 틀릴수도 있다. 하지만 이 대답을 통해 그 결심을 믿고 앞으로 계속 나아보기로 했다.</p>

<p><strong>AI 밋업 3종세트</strong></p>

<p>9월 한달동안 KBW(Korea Blockchain Week) 2025의 영향으로 수많은 블록체인 관련 밋업들이 열렸는데, 그 안에서도 AI에 대한 알짜배기 밋업들이 있었다.</p>

<p>나는 AI 자체의 기술에는 관심이 없다. 그 분야는 이미 엄청난 전문가들이 있고, 내가 이 사람들보다 더 뛰어난 AI 엔지니어가 될 것이라고 생각하지는 않는다. 다만 AI 에이전트를 잘 다루는 개발자, 그리고 AI 에이전트를 잘 만드는 개발자가 되는것은 충분히 시도할만하다고 생각한다. 특히 지금 회사에서 AI 에이전트를 만드는 계획도 있었기 때문에, 이와 관련된 밋업들이 생기면 바로 신청해서 다녀왔다.</p>

<p>특히 Claude Code에 대해 많은 관심이 있었다. ChatGPT, Gemini도 충분히 업무에서 활용하고 있었고 심지어 IDE는 Windsurf를 사용하고 있었지만, 많은 개발자들이 Claude Code를 사용하고 있었고 심지어 일부는 $200 달러를 매달 지불하면서 대부분의 업무를 AI 에이전트를 통해 처리한다는 것이 흥미로웠다. 그래서 이번달 초에 $100 요금제를 구독했는데, 막상 구독하고보니 어떻게 이걸 효율적으로 쓸 수 있는지 모르는 상태다보니 아까운 내 구독료만 낭비되고 있다는 생각이 들었다.</p>

<p>그래서 총 3군데의 AI 관련 밋업에 참석했다. <strong>AWSKRUG, Claude Code Seoul</strong> 밋업에서는 Claude Code를 사용하는 방법에 대한 인사이트를 얻을 수 있었다. 그리고 <strong>AI Builder Seoul</strong> 밋업에서는 실제로 AI 에이전트를 구축하고 이를 통해 서비스를 만들어본 경험에 대해서 배울 수 있었다.</p>

<p><br /></p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/2a585316-12f0-4313-9407-4f0a8177de7d/image.png" alt="" /></p>

<p><br /></p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/3f7f1ab4-a91e-4e00-bcf8-4f1975ee7fa0/image.png" alt="" /></p>

<p><br /></p>

<p>3군데 밋업 모두에서 느낀 내용을 종합해서 정리해보면,</p>
<ul>
  <li>대부분의 개발자들은 AI에게 단순한 질문으로부터 얻은 코드를 복사하고 붙여넣기 하고있다. 이것은 단순히 ‘내 수고로움을 줄이는 노동의 감소’의 의미 이상이 되지 않는다.</li>
  <li>하지만 AI를 정말 잘 사용하는 상위 1%의 개발자들은, AI를 또한명의 직원으로 고용한것처럼 사용한다. 계획하고 검토하는 인간의 일을 수행할 뿐, 모든 노동 작업들을 AI를 통해 수행한다.</li>
  <li>이를 위해 ‘정말로 잘 설명하고, 계획하고, 작업을 지시하는’ 연습이 필요하다. 이것은 단순히 기술 사용의 능숙함이 아니라, 만들고자 하는 상품에 대해 명확하고 빠르게 이해하고 이를 잘 지시할 수 있는 능력이다. 결국에는 AI가 있다고 해서 새로운 기술이 필요한게 아니다. 뛰어난 시니어 개발자가 되는 기준은 변한게 없다. 단지 시니어 개발자가 되는 기간이 전보다 훨씬 짧아졌을 뿐이다.</li>
</ul>

<blockquote>
  <p>밋업에 대해 조금 더 자세히 정리한 내용은 브런치에 올린 포스트 <a href="https://brunch.co.kr/@wallee/26">Meetup에 푹 절여진(?) 한주</a>를 참고해주세요.</p>
</blockquote>

<h2 id="50만원-그까이꺼">50만원. 그까이꺼!</h2>

<p>위에서 말한 AI 에이전트를 잘 사용하는 방법과, AI 에이전트를 구축하는 방법을 알기 위해 강의와 책을 구매했다. 강의는 NomadCoder의 <a href="https://nomadcoders.co/ai-agents-masterclass">AI Agents 마스터클래스</a>이고, 책은 <a href="https://product.kyobobook.co.kr/detail/S000217402731">한 걸음 앞선 개발자가 지금 꼭 알아야 할 클로드 코드</a>이다. 총 50만원 정도가 들었는데, 돈이 아깝지 않으려면 정말 열심히 들어야겠다 💸. 10월안에 강의와 책 모두 끝내려고 한다.</p>

<p>나는 배움에 대해 조금 인색(?)한 편이다. 특히 개발자와 관련된 학습은 유튜브나 인터넷에서 무료로 할 수 있는게 많아서 그런것 같다. 하지만 결국 좋은 정보를 찾는 과정에서 시간도 낭비되고 무료 강의인 경우 대부분은 품질이나 내용이 좋지 않거나 마지막에는 유료 강의 등록을 요구하는 경우들이 많다는 생각에, 적지 않지만 앞으로의 발전을 위해 과감하게 구매했다.</p>

<h2 id="수영-시작">수영 시작</h2>

<p>어렸을때 수영 선수반까지 할정도로 나는 수영을 좋아한다. (대전에서도 안했지만) 서울에 올라와서도 수영을 하고싶어서 여러곳을 찾아다녔지만, 회사 시간도 그렇고 등록하기도 어려워서 하지 못했었다. 그러다가 최근 집 근처에 있는 문화체육센터에서 진행하는 새벽 수영 등록에 성공했고, 일주일에 3번 아침 7시부터 한시간동안 수영을 하고있다. 최근에는 <strong>이유는 잘 모르지만</strong> 어렸을때 성장에 방해된다는 이유로 배우지 못했던 접영을 배우기 시작했다. 참고로 나는 선수반까지 했지만, 접영은 전혀 할 줄 모르는 상태였다.</p>

<h2 id="재택근무-이후에-생긴-익숙해짐과-나태해짐-그-사이">재택근무 이후에 생긴 익숙해짐과 나태해짐 그 사이</h2>

<p>확실히 재택근무를 하면 업무에 집중할 수 있는 시간을 내가 선택할 수 있다는 장점이 있다. 가장 좋은 상황은 아침 일찍부터 업무의 몰입에 들어간 상태인데, 이동하는 시간, 누군가와 점심을 먹는 시간 등 몰입을 방해할만한 요소들이 전부 제거되기 때문에 하루 종일 일에 완전히 몰두한 상태로 엄청나게 높은 퍼포먼스를 발휘할 수 있다.</p>

<p>하지만 이와 완전히 반대되는 상황은, 아침에 몰두하지 못한 상태를 혼자서 이겨내야하고, 이를 이겨내지 못하면 위에서 얻은 것만큼 최적의 퍼포먼스를 낼 수 없다는 것이다. 책 ‘<a href="https://product.kyobobook.co.kr/detail/S000211596949">개발자, 오늘도 마음 튼튼하게 성장하기</a>‘에서는 아침에 잠시 밖에 산책을 다녀오는 것처럼 ‘출근을 모방하는 태도’를 루틴으로 만드는 것을 추천했다.</p>

<p>결국 어떤 방법이던지 루틴을 만드는 것이 굉장히 중요한데, 앞으로 해외에서 일하게 될 상황을 고려할때 이러한 습관을 만드는 연습은 꼭 필요하다고 생각했다. 몸이 편한 것에 안주하는 것이 아니라, 내가 사용할 수 있는 시간이 늘어났다는 것에 더 집중하는 태도가 필요한 것 같다.</p>

<p>이제 2025년도 3분기가 지나고, 총 3개월만 남았다. 남은 시간도 더 많이 경험하고 성장하자!</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[2025년 9월도 순식간에 지나갔다. 이번 9월은 벌여놓은 일도 많았고, 실제로 해본일도 많은 좋은 시간이었다. 앞으로 나는 어떤 개발자가 되어야할까. 찾으면 찾을수록 맞는길인지 모르지만 적어도 확신이 조금씩 들어가는것 같다.]]></summary></entry><entry xml:lang="ko"><title type="html">vim에서 esc를 누르면 자동으로 영문으로 바꿔주기 with Hammerspoon</title><link href="http://localhost:4000/2025/09/21/auto-lang-updated-when-esc-using-hs/" rel="alternate" type="text/html" title="vim에서 esc를 누르면 자동으로 영문으로 바꿔주기 with Hammerspoon" /><published>2025-09-21T00:00:00+09:00</published><updated>2025-09-21T00:00:00+09:00</updated><id>http://localhost:4000/2025/09/21/auto-lang-updated-when-esc-using-hs</id><content type="html" xml:base="http://localhost:4000/2025/09/21/auto-lang-updated-when-esc-using-hs/"><![CDATA[<h2 id="왜-계속-mode-적용이-안됐지">왜 계속 mode 적용이 안됐지?</h2>

<p>개발자라면 영어를 사용해서 주석을 작성하는것이 당연히 좋겠지만, 사실 한국인의 경우에는 모국어로 주석을 다는것만큼 빠르고 편리한 것이 없죠. 저도 되도록이면 영어를 사용하려고 노력하지만, 지금같이 포스팅을 작성하거나 제가 빠르게 이해하기 위한 글이나 주석을 작성할 때에는 일반적으로 한국어를 사용하곤 합니다.</p>

<p>지난번 포스팅 <a href="https://wnjoon.github.io/2025/09/17/vim-vscode-extenstion/">Claude Code를 활용한 vim cheatsheet vscode extension 개발기</a>에서 말했듯이, 저는 항상 vim을 사용해서 멋지게(?) 개발하고싶은 욕심이 있습니다. 단축키가 잘 외워지지 않아 오히려 생산성을 떨어트리는 것 같아서 이를 도와줄 수 있는 <a href="https://marketplace.visualstudio.com/items?itemName=xonxoon.quick-vim-cheatsheet">vscode 기반 extension</a>을 만들기도 했죠.</p>

<p>하지만 vim을 사용하기 어렵게 만드는 또 다른 이유가 있었는데 바로 ‘한/영 전환’입니다. vim은 normal/insert/visual 모드를 지원하고 있고, 명령어들은 normal, visual 모드에서 동작합니다. 명령어를 입력하기 위한 상태로 가려면 insert -&gt; normal/visual 모드로 전환해야 하는데 이때 vim은 영문 단어를 이해합니다.</p>

<p>그러다보니 한글로 열심히 글을 적다가 모드를 바꾸게 되면 한글이 계속 인식되어서 한영전환을 한번 더 해줘야 하는데 이는 굉장히 번거롭고 생산성을 저하시킵니다. 이 문제를 해결할 수 있는 방법을 찾다가 <a href="https://www.hammerspoon.org/">hammerspoon</a>을 사용해서 해결할 수 있다는 것을 발견하여 공유합니다.</p>

<h2 id="hammerspoon">Hammerspoon</h2>

<p>Hammerspoon은 Lua라는 스크립트를 사용해서 MacOS의 일부 기능을 제어할 수 있도록 하는 도구입니다. 사용자는 스크립트 작성을 하고 이를 적용해서 OS와 어플리케이션 간에 발생하는 동작 사이에 Hook을 넣거나, 지금처럼 특정 버튼이 눌렸을때 원하는 커스텀 동작이 수행되도록 할 수 있습니다.</p>

<p>설치는 <a href="https://github.com/Hammerspoon/hammerspoon/releases/tag/1.0.0">이곳</a>에서 할 수 있습니다.</p>

<h2 id="스크립트-작성-및-적용-방법">스크립트 작성 및 적용 방법</h2>

<p>Hammerspoon을 설치하면 메뉴바에 망치모양의 아이콘이 표시됩니다.</p>

<ul>
  <li>Open Config: Hammerspoon은 기본적으로 <code class="language-plaintext highlighter-rouge">~/Users/&lt;YOUR_USERNAME&gt;/.hammerspoon/init.lua</code> 파일을 통해 스크립트를 설정할 수 있습니다. 해당 메뉴는 이 설정 파일을 불러옵니다.</li>
  <li>Reload Config: <code class="language-plaintext highlighter-rouge">~/Users/&lt;YOUR_USERNAME&gt;/.hammerspoon/init.lua</code> 파일에 작성된 설정값으로 Hammerspoon을 재시작합니다. 변경된 스크립트를 즉시 적용할 때 사용합니다.</li>
  <li>Console: Hammerspoon의 콘솔을 열어 스크립트를 실행하거나 디버깅할 때 사용합니다.</li>
</ul>

<p>이 외에도 몇가지 메뉴들이 있지만, 일반적인 다른 앱들과 동일한 성격을 가집니다.</p>

<h2 id="스크립트-적용하기">스크립트 적용하기</h2>

<p><strong>1. 특정 앱에서만 동작할 것</strong></p>

<p>제가 목표하는 것은 ‘vscode에서 vim 작업을 하기 위해 esc 키를 눌렀을때 자동으로 영문으로 전환되도록 하는 것’입니다. 기존에는 karabiner를 이용해서 esc를 눌렀을때 무조건 한/영 전환이 되도록 설정했었는데요, 이렇게 하니 vscode와 무관하게 실제로는 한/영 전환이 필요하지 않은 어플리케이션에서도 한/영 전환이 되어버렸습니다.</p>

<p>hammerspoon에서는 스크립트를 이용하여 이러한 부분을 세밀하게 조정할 수 있었기 때문에, <code class="language-plaintext highlighter-rouge">targetAppBundleID</code>를 이용하여 vscode에서 esc 키를 눌렀을때만 영문으로 전환되도록 설정할 수 있습니다.</p>

<p>원하는 어플리케이션의 bundle ID를 확인하는 방법은 여러가지가 있는데요, 저는 hammerspoon의 console을 이용해보기로 했습니다. 아래의 코드를 콘솔에 넣으면 5초 후에 가장 앞에있는(활성화 되어있는) 앱의 bundle ID를 출력해줍니다.</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- print the bundle ID of the frontmost application after 5 seconds</span>
<span class="n">hs</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">doAfter</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span>
  <span class="kd">local</span> <span class="n">app</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">frontmostApplication</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">app</span> <span class="k">then</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Bundle ID of frontmost application: "</span> <span class="o">..</span> <span class="n">app</span><span class="p">:</span><span class="n">bundleID</span><span class="p">())</span>
    <span class="n">hs</span><span class="p">.</span><span class="n">alert</span><span class="p">.</span><span class="n">show</span><span class="p">(</span><span class="s2">"Bundle ID: "</span> <span class="o">..</span> <span class="n">app</span><span class="p">:</span><span class="n">bundleID</span><span class="p">())</span>
  <span class="k">else</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Could not find the frontmost application."</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span><span class="p">)</span>
</code></pre></div></div>

<p>처음에는 5초 후에 실행하는 조건을 넣지 않았었는데, 이렇게하니 console창의 bundle ID, 즉 hammerspoon의 bundle ID가 출력되었습니다. 그래서 console에 명령어를 넣고 원하는 앱을 누를 수 있을 정도의 여유로운 시간(사실 5초는 좀 길긴 합니다)을 설정해주었습니다.</p>

<p>저는 실제로 Windsurf를 사용하기 때문에, <code class="language-plaintext highlighter-rouge">com.exafunction.windsurf</code>가 출력되는 것을 확인할 수 있었습니다.</p>

<p><strong>2. 스크립트 적용하기</strong></p>

<p>위에서 얻은 bundle ID를 이용하여 스크립트를 작성했습니다.</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- ID of the target application.</span>
<span class="kd">local</span> <span class="n">targetAppBundleID</span> <span class="o">=</span> <span class="s2">"com.exafunction.windsurf"</span>

<span class="c1">-- If a listener already exists upon reloading the config, stop it to prevent conflicts.</span>
<span class="k">if</span> <span class="n">escape_keyevent</span> <span class="k">then</span>
    <span class="n">escape_keyevent</span><span class="p">:</span><span class="n">stop</span><span class="p">()</span>
<span class="k">end</span>

<span class="c1">-- Create a new event tap listener for key down events.</span>
<span class="n">escape_keyevent</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">eventtap</span><span class="p">.</span><span class="n">new</span><span class="p">({</span><span class="n">hs</span><span class="p">.</span><span class="n">eventtap</span><span class="p">.</span><span class="n">event</span><span class="p">.</span><span class="n">types</span><span class="p">.</span><span class="n">keyDown</span><span class="p">},</span> <span class="k">function</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">event</span><span class="p">:</span><span class="n">getFlags</span><span class="p">()</span>
    <span class="kd">local</span> <span class="n">keycode</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">keycodes</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">event</span><span class="p">:</span><span class="n">getKeyCode</span><span class="p">()]</span>
    <span class="kd">local</span> <span class="n">frontApp</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">frontmostApplication</span><span class="p">()</span>

    <span class="c1">-- 1. First, check if a key was pressed within the target application.</span>
    <span class="k">if</span> <span class="n">frontApp</span> <span class="ow">and</span> <span class="n">frontApp</span><span class="p">:</span><span class="n">bundleID</span><span class="p">()</span> <span class="o">==</span> <span class="n">targetAppBundleID</span> <span class="k">then</span>

        <span class="c1">-- 2. Check if the pressed key is ESC or the Ctrl+C combination.</span>
        <span class="k">if</span> <span class="n">keycode</span> <span class="o">==</span> <span class="s1">'escape'</span> <span class="ow">or</span> <span class="p">(</span><span class="n">keycode</span> <span class="o">==</span> <span class="s1">'c'</span> <span class="ow">and</span> <span class="n">flags</span><span class="p">.</span><span class="n">ctrl</span><span class="p">)</span> <span class="k">then</span>

            <span class="c1">-- Add a 0.05-second delay to resolve timing issues.</span>
            <span class="n">hs</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">doAfter</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">03</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span>
                <span class="kd">local</span> <span class="n">input_english</span> <span class="o">=</span> <span class="s2">"com.apple.keylayout.ABC"</span>
                <span class="kd">local</span> <span class="n">current_source</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">keycodes</span><span class="p">.</span><span class="n">currentSourceID</span><span class="p">()</span>

                <span class="c1">-- [CASE 1] If the ESC key was pressed (original logic).</span>
                <span class="k">if</span> <span class="n">keycode</span> <span class="o">==</span> <span class="s1">'escape'</span> <span class="k">then</span>
                    <span class="k">if</span> <span class="n">current_source</span> <span class="o">~=</span> <span class="n">input_english</span> <span class="k">then</span>
                        <span class="n">hs</span><span class="p">.</span><span class="n">keycodes</span><span class="p">.</span><span class="n">currentSourceID</span><span class="p">(</span><span class="n">input_english</span><span class="p">)</span>
                        <span class="c1">-- print("ESC pressed: Switched to English.")</span>
                    <span class="k">end</span>
                
                <span class="c1">-- [CASE 2] If the Ctrl+C key combination was pressed (new logic).</span>
                <span class="k">elseif</span> <span class="n">keycode</span> <span class="o">==</span> <span class="s1">'c'</span> <span class="ow">and</span> <span class="n">flags</span><span class="p">.</span><span class="n">ctrl</span> <span class="k">then</span>
                    <span class="c1">-- Perform this special action only if the current input source is not English.</span>
                    <span class="k">if</span> <span class="n">current_source</span> <span class="o">~=</span> <span class="n">input_english</span> <span class="k">then</span>
                        <span class="c1">-- print("Ctrl+C (in non-English): Intercepted.")</span>
                        <span class="c1">-- a. Change the input source to English.</span>
                        <span class="n">hs</span><span class="p">.</span><span class="n">keycodes</span><span class="p">.</span><span class="n">currentSourceID</span><span class="p">(</span><span class="n">input_english</span><span class="p">)</span>
                        <span class="c1">-- b. Simulate an ESC key press.</span>
                        <span class="n">hs</span><span class="p">.</span><span class="n">eventtap</span><span class="p">.</span><span class="n">keyStroke</span><span class="p">({},</span> <span class="s1">'escape'</span><span class="p">)</span>
                        <span class="c1">-- print("--&gt; Switched to English and sent ESC.")</span>
                        <span class="c1">-- c. Block the original Ctrl+C event from being processed. (Crucial)</span>
                        <span class="k">return</span> <span class="kc">true</span>
                    <span class="k">end</span>
                <span class="k">end</span>
            <span class="k">end</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>

    <span class="c1">-- Allow all other key events to pass through.</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span><span class="p">)</span>

<span class="c1">-- Start the listener.</span>
<span class="n">escape_keyevent</span><span class="p">:</span><span class="n">start</span><span class="p">()</span>
</code></pre></div></div>

<ol>
  <li>
    <p>중간에 보면 0.03s의 delay를 주는 부분이 있는데요, 이는 esc 키를 눌렀을때 앱이 포커스를 받는 시간이 필요하기 때문입니다. 이 부분이 없는 상태에서 작성했더니, 어느 시점에서는 아무리 esc 키를 눌러도 영문으로 전환되지 않았습니다. 확인해보니 실제로 esc가 동작하지 않더라구요. 정확한 원인을 파악하지는 못했지만, 아마 esc 키를 눌렀을때 앱이 포커스를 받는 시간이 필요하기 때문이라고 생각했고 해당 부분을 적용한 뒤에는 문제가 없었습니다.</p>
  </li>
  <li>
    <p>vim에서는 ctrl+c가 esc와 동일한 역할을 하는데요, 그래서 대부분 esc를 누르지 않고 ctrl+c를 사용합니다. 문제는 한글로 입력할 경우 ctrl+ㅊ으로 입력이 되어서 esc가 정상적으로 동작하지 않았습니다. 이를 해결하기 위해서 별도의 조건을 추가하였습니다.</p>
  </li>
</ol>

<p>혹시나 저와 같이 이러한 불편을 겪고계신 분들이 있다면 도움이 되었길 바랍니다.</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[한국인들이 vim을 사용할때 자주 겪는 어려움 중 하나는 한글로 주석을 작성하다가 mode를 바꾸면 한글이 계속 인식되어 있어서 한영전환을 한번 더 해줘야 한다는 것이다. 이게 생각보다 생산성을 엄청나게 저하시키는데, 많은 곳에서 hammerspoon을 사용해서 이를 해결하고 있어서 이를 공유한다.]]></summary></entry></feed>