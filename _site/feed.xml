<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-08-25T09:59:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">wxnjxxn.log</title><subtitle>A blog about software engineering, blockchain, and other development topics.
</subtitle><author><name>Wonjoon</name></author><entry><title type="html">컨텍스트 엔지니어링: AI를 효과적으로 사용하는 방법</title><link href="http://localhost:4000/2025/08/14/context-engineering/" rel="alternate" type="text/html" title="컨텍스트 엔지니어링: AI를 효과적으로 사용하는 방법" /><published>2025-08-14T00:00:00+09:00</published><updated>2025-08-14T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/14/context-engineering</id><content type="html" xml:base="http://localhost:4000/2025/08/14/context-engineering/"><![CDATA[<h2 id="점점-빠르게-변화하는-ai">점점 빠르게 변화하는 AI</h2>

<p>작년과 올해 사이에 삶에서 느껴진 가장 큰 변화가 있다면 AI일 것입니다. 사람과 대화하듯 질문하는 내용에, 사람처럼 대답하는 AI를 보면서 신기해하던게 불과 작년이었는데, 이제는 복잡한 내용을 이해하고 정리하는 것을 넘어서 새로운 것을 만들고 이를 검토하는 것까지 가능할정도로 엄청나게 빠르게 발전하고 있습니다.</p>

<p>작년에 서점에 가면 ‘프롬프트 엔지니어가 되는 방법’이라는 주제의 책들이 굉장히 많았습니다. ‘좋은 질문을 할 수 있는 엔지니어’가 앞으로 AI 시대에 가장 필요할 것이라는 내용이 대다수였죠.</p>

<p>하지만 불과 1년이 채 되지 않은 시점에, 우리는 ‘개같이 말해도 찰떡같이 알아듣는’ AI를 만나고 있습니다. 내가 무엇을 궁금해하는지 모를 정도로 이해하기 어려운 질문을 던지더라도, 100%는 아니지만 그만큼 근접할 정도로 이해하기 위해 노력한 흔적이 뭍은 답변을 제공하는 것을 경험하고 있습니다.</p>

<p>앞에서 이야기할 내용이지만, 현재 AI는 ‘잘 설계된 컨텍스트, 즉 풍부하고 정확한 정보가 주어졌을 때, 매우 복잡한 내용이라 하더라도 정확하게 이해’할 수 있습니다. 하지만 이러한 이해를 바탕으로 무언가를 새롭게 생성하고자 하면, 특히 결과물이 점점 복잡해질수록 일관성이 부족해지거나 중복된 내용이 발생하는 등 생성 능력에 있어서 아직 부족한 점을 보이고 있습니다.</p>

<p>2025년 7월에 작성된 논문 ‘<a href="https://arxiv.org/abs/2507.13334">A Survey of Context Engineering for Large Language Models</a>‘에서는 컨텍스트 엔지니어링에 대해서 소개하고 있습니다. 이 논문은 프롬프트 엔지니어링과 컨텍스트 엔지니어링을 비교하고, 사용자가 더 나은 AI 활용을 위해 어떻게 컨텍스트 엔지니어링을 적용해야하는지에 대해 설명합니다.</p>

<h2 id="프롬프트-엔지니어링과-컨텍스트-엔지니어링">프롬프트 엔지니어링과 컨텍스트 엔지니어링</h2>

<p>프롬프트 엔지니어링은 ‘최고의 답변을 생성할 수 있는 최고의 질문’을 만드는데 집중합니다. 마치 ‘숙련된 수사관이 증인에게서 가장 정확한 진술을 이끌어내기 위해 단어 하나와 뉘앙스 하나까지 신중하게 고르는 것’과 비슷합니다.</p>

<p>하지만 컨텍스트 엔지니어링은 ‘AI가 문제를 해결하고 좋은 답변을 줄 수 있도록 최선을 다해 도와주는 것’과 같습니다. 숙련된 수사관인 AI에게 이제까지 모든 자료가 담긴 사건 파일을 건내주는 것과 같습니다. 이 파일에는 명확한 지시사항, 외부 참고자료, 사용 가능한 도구 목록, 그리고 과거 상호작용 기록등이 포함될 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>차원</th>
      <th>프롬프트 엔지니어링</th>
      <th>컨텍스트 엔지니어링</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>범위</td>
      <td>단일 텍스트 입력(프롬프트) 최적화</td>
      <td>다수의 정보 소스로 구성된 전체 정보 환경 설계</td>
    </tr>
    <tr>
      <td>모델</td>
      <td>정적인 텍스트 문자열 ($C = \text{prompt}$)</td>
      <td>동적이고 구조화된 정보 요소들의 조립 ($C = \mathcal{A}(c_1, c_2,…, c_n)$)</td>
    </tr>
    <tr>
      <td>목표</td>
      <td>특정 프롬프트에 대한 최상의 응답 생성</td>
      <td>주어진 과제에 대해 보상(품질)을 극대화하는 정보 시스템 최적화</td>
    </tr>
    <tr>
      <td>복잡성</td>
      <td>수동적, 반복적 시도를 통한 최적의 문구 탐색</td>
      <td>검색, 선택, 조립 등 여러 기능으로 구성된 시스템 수준의 최적화</td>
    </tr>
    <tr>
      <td>정보 흐름</td>
      <td>프롬프트 내에 정보가 고정됨</td>
      <td>외부 데이터베이스, 도구, 메모리 등에서 정보를 동적으로 가져와 활용</td>
    </tr>
    <tr>
      <td>상태 관리</td>
      <td>주로 상태가 없음 (매번 새로운 대화)</td>
      <td>메모리 구성요소를 통해 이전 상호작용의 상태를 명시적으로 관리</td>
    </tr>
    <tr>
      <td>확장성</td>
      <td>프롬프트가 길고 복잡해질수록 취약해짐</td>
      <td>모듈식 구성 요소를 통해 복잡성을 체계적으로 관리</td>
    </tr>
    <tr>
      <td>오류 분석</td>
      <td>수동 검사 및 반복적인 프롬프트 수정</td>
      <td>각 정보 구성 요소(함수)에 대한 체계적인 평가 및 디버깅</td>
    </tr>
  </tbody>
</table>

<h2 id="컨텍스트-엔지니어링의-단계">컨텍스트 엔지니어링의 단계</h2>

<p>논문에서는 컨텍스트 엔지니어링을 크게 3가지 기반 요소로 구성합니다. 이를 제품을 만드는 공급망이라고 할 때, 아래와 같이 표현할 수 있습니다.</p>

<ul>
  <li>검색 및 생성: 원자재를 조달합니다</li>
  <li>처리: 공장에서 원자재를 가공합니다.</li>
  <li>관리: 가공된 제품을 창고에 효율적으로 전달하고 이를 관리합니다.</li>
</ul>

<h3 id="1-컨텍스트-검색-및-생성">1. 컨텍스트 검색 및 생성</h3>

<p><strong>좋은 프롬프트의 중요성</strong></p>

<p>컨텍스트 엔지니어링에서도 프롬프트 엔지니어링, 즉 좋은 질문은 당연히 중요합니다. 우리는 AI에게 ‘이렇게 답변하게 된 과정을 보여달라고 요청’하거나, ‘하나의 답변 말고 여러 가능성을 동시에 탐색하도록 요청’해야 합니다. 이를 통해 AI가 성급한 결론을 내리지 않고, 여러 가능성을 추론함으로써 가장 효과적인 방향으로 사고를 확장할 수 있도록 도울 수 있습니다.</p>

<p><strong>외부 지식의 활용</strong></p>

<p>AI는 ‘학습한 내용까지만 생각할 수 있다’는 제약이 있습니다. ChatGPT의 경우에도 선택한 모델에 따라 알고 있는 최신 정보가 달라지기도 합니다.</p>

<p>하지만 최근에는 검색 증강 생성(RAG: Retrieval Augmented Generation) 기술을 통해 AI에게 인터넷, 내부 문서와 같은 외부 지식을 답변 생성에 사용할 수 있도록 제공할 수 있습니다. 이는 컨텍스트 엔지니어링 기법에 가장 핵심적인 기술중 하나로, AI가 가지고 있는 큰 문제점 중 하나인 환각(Hallucination)이라고 불리는 거짓된 정보 생성을 크게 줄일 수 있습니다.</p>

<p>초기 RAG가 단순한 사실 검색에 그쳤다면, 최근 RAG 시스템은 크게 2가지로 구분되어 더욱 정교한 방식으로 정보를 처리합니다.</p>

<ul>
  <li>
    <p>모듈형(Modular RAG): 사용자는 질문을 더 명확하게 다듬는 ‘질의 재작성’ 모듈, 여러 데이터베이스에서 동시에 정보를 가져오는 ‘다중 소스 검색’ 모듈, 그리고 검색된 정보들 중 가장 유용한 것을 골라내는 ‘재순위화’ 모듈 등을 필요에 따라 자유롭게 조합하여 최적의 RAG 파이프라인을 구축합니다.</p>
  </li>
  <li>
    <p>에이전트(Agentic RAG):  AI는 단순히 정보를 검색하는 것을 넘어, 스스로 ‘조사’를 수행합니다. 복잡한 질문을 받으면 이를 여러 개의 하위 질문으로 분해하고, 각각에 대한 정보를 검색한 뒤, 그 결과들을 종합하여 최종 결론을 도출합니다.</p>
  </li>
</ul>

<p>AI는 외부로부터 전달받은 지식을 마인드맵과 같은 그래프 형태로 연결합니다. 이렇게 연결된 정보들은 AI가 연관된 내용을 통한 다단계 추론을 훨씬 정확하게 할 수 있도록 합니다.</p>

<h3 id="2-컨텍스트-처리">2. 컨텍스트 처리</h3>

<p><strong>컨텍스트 크기의 한계</strong></p>

<p>AI는 한번에 처리할 수 있는 정보의 양에 한계를 갖고 있습니다. 우리도 한번에 공부할 수 있는 정보의 양이 한정되어 있듯이, AI 또한 메모리에 한계를 갖고 있습니다. 이로 인해, AI에게 너무 많은 정보를 제공하게 되면 중간 분실(Lost-In-The-Middle) 현상이 발생하기도 합니다. 중간에 있는 정보를 잊어버린채 잘못된 답변을 하거나, 생성된 결과의 일관성이 무너지기도 합니다. 이를 해결하기 위한 다양한 연구들(FlashAttention, Mamba 등)이 있습니다.</p>

<p>사실 이부분은 ‘컴퓨터 또한 메모리라는 한정된 기억공간을 갖는다’는 내용으로 보면, 당연한 결과일 뿐입니다. 다만 인간은 ‘과거를 기억하기 위한 다양한 수단을 사용’하는 것과 달리, AI는 상대적으로 방법과 공간의 한계가 명확합니다.</p>

<p><strong>자발적인 개선</strong></p>

<p>AI는 주어진 컨텍스트를 가지고 자체적인 개선(Self-Refine)이 가능합니다. 스스로 초안을 만들고, 이걸 비평하고, 초안을 수정합니다. 이러한 과정을 계속 반복해서 최적의 결과물을 생성합니다. 이를 다른 관점에서 보면, 우리가 공상 과학에서나 보던 ‘AI는 스스로 성장하고 있다’는 이야기가 현실로 이루어지고 있는 것이죠. 우리는 점점 발전해가는 결과를 얻을 수 있다는 기술적 이점 이면에, 앞으로 어떻게 발전할지 예측할 수 없는 진정한 인공지능을 마주하고 있는지도 모릅니다.</p>

<h3 id="3-컨텍스트-관리">3. 컨텍스트 관리</h3>

<p>AI는 기본적인 대화가 끝나면 모든것을 잊어버립니다. 이를 해결하기 위해, AI는 메모리라는 한정된 기억공간을 갖습니다. 메모리는 작은 공간이라는 제약이 있지만, 빠르게 기억을 불러올 수 있습니다. AI 뿐만 아니라 많은 시스템에서는 ‘자주 사용하는 정보를 메모리에 두고, 장기 기억을 할 수 있는 저장소에서 필요할 때마다 정보를 불러오는 방식’을 사용합니다. MemGPT는 이러한 방식을 통해 정보를 효율적으로 관리할 수 있는 기능(페이징)을 제공합니다.</p>

<p>또한 AI가 사용하는 작업공간, 즉 컨텍스트 창도 한정된 공간을 갖습니다. 모든 정보를 그대로 담을 수 없기 때문에, AI는 이를 압축하여 사용합니다. 컨텍스트 압축을 통해 AI는 핵심만 요약한 ‘요약노트’를 만들어서, 메모리에 더 많은 정보를 효율적으로 저장할 수 있도록 합니다.</p>

<h2 id="우리는-어떻게-ai를-사용하면-좋을까">우리는 어떻게 AI를 사용하면 좋을까?</h2>

<p>논문에서 제공한 내용을 바탕으로, 우리는 ‘AI를 통해 최적의 답변을 얻을 수 있는 방법’을 찾을 수 있습니다.</p>

<p><strong>작업의 목적을 명확하게 하고, 범위를 최소화 한다.</strong></p>

<p>이는 ‘내가 무엇을 요청하고 싶은지 명확하게 파악’하는 것에서부터 시작합니다. 실생활에서도 그렇듯이, AI에도 좋은 질문, 즉 프롬프트 엔지니어링이 가장 중요합니다. 그리고 이 요청을 가장 작은 단위의 질문으로 나눌 수 있어야 합니다. 질문의 크기가 커질수록 Lost-In-The-Middle 현상이 발생할 가능성이 높아집니다. 논문에서는 ‘중요한 정보가 컨텍스트의 시작 또는 끝에 위치할 때 가장 좋은 성능을 보여준다’고 말합니다.</p>

<p>작업을 요청할때에도 마찬가지입니다. 한번에 많은 작업을 요청하기보다는, 작업을 모듈화하고 단계별로 요청하는 것이 좋습니다.</p>

<p><strong>최대한의 정보를 제공한다.</strong></p>

<p>사용자가 AI를 사용하는 가장 큰 목적은 ‘빠르게 최적의 결과물을 얻는 것’입니다. 사실 AI에게 정보를 제공하는 것 자체가 또다른 업무일 수 있습니다. 하지만 AI에게 제공하는 정보가 많아질수록, AI가 더욱 양질의 답변을 제공한다는 것은 당연한 결과입니다.</p>

<p>단순히 정보를 많이 주는 것을 넘어, AI가 잘 활용할 수 있는 형태로 정보를 가공하고 이를 조립하여 제공해야 합니다. 정확한 정보가 담긴 전문 지식을 제공해야 하고, AI가 자체적으로 할 수 없는 일을 도울 수 있는 외부 도구(API)를 호출하여 효과적인 작업이 가능하도록 해야 합니다.</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[AI의 이해 능력과 생성 능력 사이의 비대칭성을 설명하고, '프롬프트 엔지니어링'을 넘어 AI의 잠재력을 최대한 활용하기 위한 '컨텍스트 엔지니어링'의 개념, 핵심 단계(검색, 처리, 관리), 그리고 이를 바탕으로 한 최적의 AI 활용 방법을 제시합니다.]]></summary></entry><entry><title type="html">스테이블코인의 현주소: 시장의 구성과 주요 플레이어</title><link href="http://localhost:4000/2025/08/07/stable-coin/" rel="alternate" type="text/html" title="스테이블코인의 현주소: 시장의 구성과 주요 플레이어" /><published>2025-08-07T00:00:00+09:00</published><updated>2025-08-07T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/07/stable-coin</id><content type="html" xml:base="http://localhost:4000/2025/08/07/stable-coin/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/21">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="crypto" /><summary type="html"><![CDATA[2025년 기준, 스테이블코인의 정의와 1달러 가치를 유지하는 차익거래 원리, 시장 발전 과정, USDT·USDC 등 주요 플레이어 분석 및 미래 전망을 다룹니다.]]></summary></entry><entry><title type="html">SQLite FTS의 토크나이저와 인덱싱에 대해서</title><link href="http://localhost:4000/2025/08/06/sql-fts5/" rel="alternate" type="text/html" title="SQLite FTS의 토크나이저와 인덱싱에 대해서" /><published>2025-08-06T00:00:00+09:00</published><updated>2025-08-06T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/06/sql-fts5</id><content type="html" xml:base="http://localhost:4000/2025/08/06/sql-fts5/"><![CDATA[<h2 id="목차">목차</h2>

<ul>
  <li><a href="#전문-검색full-text-search이란">전문 검색(Full-Text Search)이란?</a></li>
  <li><a href="#fts는-어떻게-동작하나요">FTS는 어떻게 동작하나요?</a></li>
  <li><a href="#좀더-자세히-알아보기">좀더 자세히 알아보기</a></li>
  <li><a href="#fts의-장점">FTS의 장점</a></li>
</ul>

<h2 id="전문-검색full-text-search이란">전문 검색(Full-Text Search)이란?</h2>

<p>우리가 구글에서 “오늘 서울 날씨”라고 검색하면, 구글은 어떻게 요청 데이터를 처리할까요?
아마도 구글은 ‘오늘’, ‘서울’, ‘날씨’라는 단어가 포함된 수많은 웹페이지 중에서 가장 관련성 높은 문서를 찾아서 보여줄겁니다.</p>

<p>이처럼, 전문 검색(Full-Text Search)은 단순히 문자가 완전히 일치하는지(예: <code class="language-plaintext highlighter-rouge">LIKE '%검색어%'</code>)를 확인하는 것을 넘어, <strong>문장이나 문단 전체에서 특정 단어나 구문이 포함된 문서를 빠르고 효율적으로 찾아주는 기술</strong>입니다. 
일반적인 데이터베이스 검색(예: <code class="language-plaintext highlighter-rouge">WHERE title = '검색어'</code>)이 책의 ‘목차’에서 제목을 찾는 것이라면, 전문 검색은 일반적으로 책의 맨 뒤에서 볼 수 있는 ‘찾아보기(인덱스)’를 이용해 본문 내용 안에서 단어를 찾는 것과 같습니다.</p>

<p>SQLite 데이터베이스는 이 ‘전문 검색’ 기능을 사용할 수 있도록 해주는 강력한 확장 기능(extension)인 FTS를 제공합니다. ‘FTS’는 Full-Text Search의 약자이고, 뒤에 숫자로 버전을 명시합니다. 예를 들어 FTS5라는 것은 5번째 버전을 의미합니다. <strong>앞으로 설명할 FTS는 FTS5를 의미합니다.</strong></p>

<h2 id="fts는-어떻게-동작하나요">FTS는 어떻게 동작하나요?</h2>

<p>FTS는 일반적인 검색보다 훨씬 빠르고 효율적으로 동작하기 위해, 아래와 같은 과정을 거칩니다.</p>

<h3 id="1-가상-테이블virtual-table-생성">1. 가상 테이블(Virtual Table) 생성</h3>

<p>전문 검색을 할 텍스트 데이터(예: 상품 설명)를 일반 테이블이 아닌 FTS 전용의 ‘가상 테이블(VIRTUAL)’에 저장합니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 'product_fts' 라는 이름의 FTS5 가상 테이블을 생성</span>
<span class="k">CREATE</span> <span class="n">VIRTUAL</span> <span class="k">TABLE</span> <span class="n">product_fts</span> <span class="k">USING</span> <span class="n">fts5</span><span class="p">(</span>
    <span class="n">Name</span><span class="p">,</span>         <span class="c1">-- 상품명</span>
    <span class="n">Description</span>   <span class="c1">-- 상품설명</span>
    <span class="c1">-- , tokenize = 'porter' -- (옵션) 추가적인 토크나이저 설정</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="2-토큰화tokenization">2. 토큰화(Tokenization)</h3>

<p>FTS5 테이블에 텍스트를 저장하면, FTS5는 이 텍스트를 의미 있는 최소 단위의 단어, 즉 <strong>‘토큰(token)’</strong>으로 분해합니다. 예를 들어, “최고의 서울 야경 투어”라는 문장은 ‘최고’, ‘서울’, ‘야경’, ‘투어’ 같은 토큰으로 쪼개지는데, 이 과정에서 ‘의’ 같은 조사는 보통 무시됩니다.</p>

<h3 id="3-인덱싱indexing">3. 인덱싱(Indexing)</h3>

<p>앞에서 쪼개진 토큰들을 바탕으로 ‘역인덱스(inverted index)’라는 특별한 목록을 만듭니다. 이 목록에는 어떤 단어(토큰)가 어떤 문서(row)에 나타나는지에 대한 정보가 기록됩니다.</p>

<p>예를 들어, ‘서울’이 포함된 문서 목록(1, 5, 12)과 ‘야경’이 포함된 문서 목록(1, 7)을 찾아서 아래와 같이 매핑합니다.</p>

<ul>
  <li>‘서울’ -&gt; 1번, 5번, 12번 문서에 있음</li>
  <li>‘야경’ -&gt; 1번, 7번 문서에 있음</li>
</ul>

<h3 id="4-검색search">4. 검색(Search)</h3>

<p>사용자가 <code class="language-plaintext highlighter-rouge">MATCH</code> 연산자를 사용해 “서울 야경”이라고 검색하면, FTS는 앞에서 생성한 역인덱스를 이용해서 ‘서울’과 ‘야경’이 포함된 문서를 빠르게 찾아냅니다. 그리고 두 목록에 공통으로 존재하는 문서를 최종 결과로 반환합니다.</p>

<h2 id="좀더-자세히-알아보기">좀더 자세히 알아보기</h2>

<p>아래와 같이 다양한 옵션을 사용해서 가상 테이블을 설정해봅시다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="n">VIRTUAL</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">USING</span> <span class="n">FTS5</span><span class="p">(</span>
    <span class="n">id</span> <span class="n">UNINDEXED</span><span class="p">,</span>
    <span class="n">sub_id</span><span class="p">,</span>
    <span class="k">comment</span><span class="p">,</span>
    <span class="n">field</span> <span class="n">UNINDEXED</span><span class="p">,</span>
    <span class="nb">text</span><span class="p">,</span>
    <span class="k">prefix</span> <span class="o">=</span> <span class="s1">'1 2 3'</span><span class="p">,</span>
    <span class="n">tokenize</span> <span class="o">=</span> <span class="s1">'unicode61 remove_diacritics 2'</span>
<span class="p">)</span>
</code></pre></div></div>

<p>먼저 결론을 말씀드리면, 이 명령어를 통해 대소문자를 무시하고, 발음 기호를 제거하며, 공백/문장부호로 단어를 나누는 규칙으로 sub_id, comment, text 컬럼의 내용을 토큰으로 만들어 저장하는 FTS 테이블을 생성합니다.</p>

<h3 id="검색-대상-컬럼-선정">검색 대상 컬럼 선정</h3>

<p>일부 필드에는 UNINDEXED라는 옵션이 붙어있는 것을 볼수 있는데요, 이 옵션이 붙어있는 컬럼은 테이블에 저장되기는 하지만 전문 검색의 대상이 되지는 않습니다. 즉, MATCH 연산자를 사용해서 이 컬럼들을 검색할 수 없습니다.</p>

<ul>
  <li>검색 대상: sub_id, comment, text</li>
  <li>검색 비대상: id, field</li>
</ul>

<p>검색 대상 컬럼에 있는 텍스트는 토큰으로 분해되어 검색용 인덱스로 만들어집니다.</p>

<h3 id="토큰화tokenization">토큰화(Tokenization)</h3>

<p>토큰화(Tokenization)는 바로 <code class="language-plaintext highlighter-rouge">tokenize</code> 옵션에 의해 결정됩니다. 코드를 보면 <code class="language-plaintext highlighter-rouge">unicode61 remove_diacritics 2</code>라는 옵션이 붙어있는 것을 볼 수 있습니다. 이 옵션은 2가지 옵션을 포함하고 있습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">unicode61</code></strong></p>

<p>사용할 토크나이저(Tokenizer, 분해기)의 이름입니다. 이름 그대로 유니코드 6.1 표준에 정의된 규칙에 따라 텍스트를 단어로 분해합니다. 이 분해기는 크게 2가지 특징을 가지고 있습니다.</p>

<ol>
  <li>Case-insensitive: 대소문자를 구분하지 않습니다. Apple, apple, APPLE은 모두 같은 토큰 ‘apple’로 처리됩니다.</li>
  <li>Separator: 공백(space), 마침표(.), 쉼표(,) 등 문장 부호를 기준으로 단어를 나눕니다.</li>
</ol>

<p><strong><code class="language-plaintext highlighter-rouge">remove_diacritics 2</code></strong></p>

<p>토크나이저에 전달하는 추가 옵션입니다. 여기서 diacritic은 발음 구별 기호(예: é, ü, ñ)를 의미하고, 결국 앞에 remove가 붙었다는 것은 발음 기호를 제거하라는 옵션이 됩니다.</p>

<p>예를 들어,</p>

<ul>
  <li>résumé -&gt; resume로,</li>
  <li>café -&gt; cafe</li>
</ul>

<p>로 변환되어 토큰으로 만들어집니다.</p>

<p>그럼 뒤에 숫자는 무엇을 의미할까요? 이러한 기능을 처리하는 내부적인 알고리즘의 버전을 의미합니다. 즉 2버전을 기반으로 발음 기호를 제거하라는 옵션입니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">prefix</code></strong></p>

<p>단어의 앞부분만으로도 빠르게 검색할 수 있도록 <strong>접두어 인덱스(prefix index)</strong>를 만듭니다. ‘1 2 3’의 의미는 한 글자, 두 글자, 세 글자짜리 접두어에 대한 인덱스를 미리 만들어두겠다는 뜻입니다.</p>

<p>예를 들어, apple이라는 단어가 있다면 a, ap, app에 대한 인덱스가 생성됩니다. 이를 통해 사용자는 ‘app’ 까지만 입력해도 apple을 매우 빠르게 찾아낼 수 있습니다.</p>

<p>자동완성 기능이라고 생각하시면 이해하기 좋습니다.</p>

<h3 id="예시-1-영어-텍스트-토큰-분해-과정">예시 1. 영어 텍스트 토큰 분해 과정</h3>

<p><strong>원본 텍스트 저장</strong></p>

<p>“The best Café in Seoul is near City Hall.” 라는 원본 텍스트가 있다고 가정합니다. 이 텍스트는 <code class="language-plaintext highlighter-rouge">text</code> 컬럼에 저장됩니다.</p>

<p><strong>토큰화 과정</strong></p>

<p>unicode61 토크나이저는 대소문자를 통합하고 문장 부호를 기준으로 단어를 나눕니다.</p>

<p>결과로 [the, best, café, in, seoul, is, near, city, hall]이 생성됩니다.</p>

<p><strong>발음 기호 제거</strong></p>

<p>remove_diacritics 옵션은 발음 기호를 제거합니다. café -&gt; cafe</p>

<p>결과로 [the, best, cafe, in, seoul, is, near, city, hall]이 생성됩니다.</p>

<p><strong>접두어 인덱스 생성</strong></p>

<p>단어의 앞부분만으로도 빠르게 검색할 수 있도록 접두어 인덱스(prefix index)를 만듭니다.</p>

<p>위에서 prefix 뒤에 붙은 ‘1 2 3’의 의미는 한 글자, 두 글자, 세 글자짜리 접두어에 대한 인덱스를 미리 만들어두겠다는 뜻입니다.</p>

<p>예를 들어, apple이라는 단어가 있다면 a, ap, app에 대한 인덱스가 생성됩니다. 덕분에 사용자가 ‘app’까지만 입력해도 apple을 매우 빠르게 찾아낼 수 있습니다. 자동완성과 동일한 기능이라고 볼 수 있습니다.</p>

<h3 id="예시-2-한글-텍스트-토큰-분해-과정">예시 2. 한글 텍스트 토큰 분해 과정</h3>

<p><strong>원본 텍스트 저장</strong></p>

<p>“최고의 서울 야경 투어!”라는 원본 텍스트가 있습니다. 이 텍스트 또한 <code class="language-plaintext highlighter-rouge">text</code> 컬럼에 저장됩니다.</p>

<p><strong>토큰화 과정</strong></p>

<p>여기서 중요한 점이 있습니다. <strong><code class="language-plaintext highlighter-rouge">unicode61</code> 토크나이저는 한글의 형태소(명사, 조사 등)를 분석하는 기능이 없기 때문에, 공백과 문장 부호를 기준으로만 단어를 나눕니다.</strong></p>

<p>그러므로 최종 생성 토큰은 [최고의, 서울, 야경, 투어]가 됩니다.</p>

<p>이때 사용자가 ‘최고’라고 검색하면 어떻게 될까요? 토큰으로 저장된 결과는 ‘최고의’뿐이므로, ‘최고’라는 토큰을 찾을 수 없게 됩니다. 이것이 <code class="language-plaintext highlighter-rouge">unicode61</code> 토크나이저를 한글에 사용할 때의 한계점입니다.
그래서 일반적으로 더 정확한 한글 검색을 위해서는 별도의 한글 형태소 분석기를 FTS에 연동합니다.</p>

<p>그렇다면 궁금한 점이 생깁니다. 위에서 prefix해서 인덱스를 추가로 생성할 수 있다고 했는데, 그러면 ‘최고의’ 토큰은 [‘최’, ‘최고’, ‘최고의’] 인덱스를 가지게 되니까 ‘최고’를 검색할 때도 ‘최고의’를 찾을 수 있게 되는 거 아닌가?</p>

<p>결론부터 말씀드리면, 아쉽게도 그렇게 동작하지 않습니다.</p>

<p>이유를 명확히 이해하려면 <strong>토큰화(Tokenization)</strong>와 <strong>접두어 인덱싱(Prefix Indexing)</strong>의 역할을 정확하게 이해해야 합니다.</p>

<p>FTS에서 가장 먼저 일어나는 일은 입력된 텍스트에서 ‘단어(토큰)’가 무엇인지 정의하는 것입니다.</p>

<p>위에서 <code class="language-plaintext highlighter-rouge">unicode61</code>은 공백을 기준으로 단어를 나누므로, FTS는 이 텍스트에 최고의, 서울, 야경 이라는 3개의 단어(토큰)만 존재한다고 인식하고 저장합니다. 이 시점에서 FTS의 ‘단어 사전’에는 최고의라는 단어는 있지만, 최고라는 단어는 존재하지 않습니다. 토크나이저가 그렇게 정의했기 때문입니다.</p>

<p>이 다음에 진행되는 prefix (접두어 인덱싱)은 “결정된 단어를 빨리 찾기 위한 ‘색인’ 추가”의 역할을 합니다. 중요한 점은 <strong>‘생성된 색인이 토큰이 되지는 않는다’</strong>는 것입니다. 특정 토큰으로 이동할 수 있는 지름길을 만드는 것이지, 이미 만들어진 토큰을 글자수 단위로 더욱 세밀하게 쪼개서 토큰으로 생성하라는 의미가 아닙니다.</p>

<ul>
  <li>최고의라는 토큰에 대해: [최 -&gt; 최고의], [최고 -&gt; 최고의]로 가는 지름길을 만듭니다.</li>
  <li>서울이라는 토큰에 대해: [서 -&gt; 서울], [서울 -&gt; 서울]로 가는 지름길을 만듭니다.</li>
  <li>야경이라는 토큰에 대해: [야 -&gt; 야경], [야경 -&gt; 야경]로 가는 지름길을 만듭니다.</li>
</ul>

<p>그러므로 최나 최고가 독립적인 단어로 사전에 추가되는 것이 아니라, 오직 ‘최고의’라는 원본 단어를 더 빨리 찾기 위한 ‘색인’ 또는 ‘포인터’의 역할만 하게 됩니다.</p>

<h3 id="검색-시-어떻게-동작하는가">검색 시 어떻게 동작하는가?</h3>

<p>한글 텍스트를 기준으로 사용자가 검색을 시도하였을 때 어떻게 동작하는지 알아보겠습니다.</p>

<p><strong>CASE 1: … <code class="language-plaintext highlighter-rouge">MATCH '최고'</code> 라고 검색한 경우</strong></p>

<p>FTS는 단어 사전에서 최고라는 토큰이 완벽하게 일치하는 항목이 있는지 먼저 찾습니다. 하지만 단어 사전에는 ‘최고의’만 있을 뿐 ‘최고’라는 단어는 없습니다.</p>

<p>이때 접두어 인덱스는 사용되지 않는데요, 오직 <code class="language-plaintext highlighter-rouge">*</code> 와 함께 사용될 때만 접두어 인덱스는 활성화됩니다.</p>

<p>그러므로 결과적으로 문서를 찾지 못합니다.</p>

<p><strong>CASE 2: … <code class="language-plaintext highlighter-rouge">MATCH '최고*'</code> 라고 검색한 경우</strong></p>

<p>FTS는 검색어 끝에 <code class="language-plaintext highlighter-rouge">*</code>가 붙은 것을 보고, 접두어 인덱스를 활용한 검색을 수행합니다. 접두어 인덱스를 확인한 결과, ‘최고’라는 단어가 ‘최고의’ 토큰을 가리키는 지름길로 등록되어있음을 확인합니다.</p>

<p>이 지름길이 가리키는 ‘최고의’ 토큰이 포함된 문서를 찾아 성공적으로 반환합니다.</p>

<h2 id="fts의-장점">FTS의 장점</h2>

<p>일반적으로 사용되는 <code class="language-plaintext highlighter-rouge">WHERE content LIKE '%검색어%'</code> 방식과 FTS 방식을 간단하게 비교해보면, FTS 방식이 훨씬 빠르고 효율적이라는 것을 알 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>FTS (MATCH)</th>
      <th>일반 검색 (LIKE)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>속도</td>
      <td>매우 빠름. 미리 만들어 둔 인덱스를 사용해 검색하기 때문에 데이터가 수십만 건이 되어도 성능 저하가 거의 없습니다.</td>
      <td>매우 느림. 테이블의 모든 데이터를 하나씩 처음부터 끝까지 다 읽어서 비교(Table Full Scan)하기 때문에 데이터가 많아지면 속도가 급격히 느려집니다.</td>
    </tr>
    <tr>
      <td>정확도/기능</td>
      <td>- 단어(토큰) 단위로 검색하여 더 정확합니다.<br />- AND, OR, NOT 등 논리 연산이 가능합니다.<br />- “서울 야경”처럼 여러 단어가 가까이 있는 문서를 찾는 NEAR 검색도 가능합니다.<br />- 검색 결과의 관련도 순으로 정렬(rank)할 수 있습니다.</td>
      <td>- 단순히 문자열 포함 여부만 체크합니다.<br />- 복잡한 조건의 검색이 어렵습니다.</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[FTS5는 SQLite 데이터베이스에서 바로 이 '전문 검색' 기능을 사용할 수 있도록 해주는 강력한 확장 기능(extension)입니다. 'FTS'는 Full-Text Search의 약자입니다.]]></summary></entry><entry><title type="html">채권 가격과 금리의 관계: 왜 반대로 움직일까?</title><link href="http://localhost:4000/2025/08/03/interest-rate-bonds/" rel="alternate" type="text/html" title="채권 가격과 금리의 관계: 왜 반대로 움직일까?" /><published>2025-08-03T00:00:00+09:00</published><updated>2025-08-03T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/03/interest-rate-bonds</id><content type="html" xml:base="http://localhost:4000/2025/08/03/interest-rate-bonds/"><![CDATA[<p><strong>결론: 채권의 수요가 증가하면, 채권 가격이 상승하고 시장 금리가 하락합니다.</strong></p>

<h3 id="채권의-특징">채권의 특징</h3>

<p>채권 시장을 보다 보면 이런 말을 자주 듣게 됩니다. 주식처럼 가격이 오르면 좋은 것 아닌가? 싶은데, 왜 금리는 반대로 움직이는 걸까요? 이 원리를 알기 위해선 먼저 채권의 기본 특징 한 가지를 이해해야 합니다.</p>

<p>채권은 정부(국채)나 회사(회사채)가 자금을 조달하기 위해 발행하는 일종의 ‘차용증서’입니다. 정부는 일반적으로 매달 정기적으로 경쟁입찰을 통해 국채를 발행하고, 회사는 자금이 필요한 시기에 이사회의 결정을 거쳐 비정기적으로 회사채를 발행합니다.</p>

<p>채권의 대표적인 특징은 아래와 같습니다.</p>

<ul>
  <li><strong>채권은 발행 시점에 이자와 총량이 고정</strong>된다는 점입니다.</li>
  <li><strong>한번 발행된 채권은 만기가 되기 전까지 주식처럼 시장에서 자유롭게 거래됩니다.</strong></li>
  <li>채권은 발행될 때 지급하기로 약속한<strong>표면 이자율과 이자액이 절대 변하지 않습니다</strong>.</li>
</ul>

<p>특히 마지막 특징인 ‘변하지 않는 표면 이자율과 이자액’이 어떻게 채권 가격과 금리를 반대로 움직이게 만드는지 구체적인 예시로 살펴보겠습니다.</p>

<h3 id="고정된-이자-vs-변동하는-가격">고정된 이자 vs 변동하는 가격</h3>

<p>여기, A회사가 발행한 채권이 있다고 가정해 봅시다.</p>

<ul>
  <li><strong>채권 가격(발행가):</strong> 10,000원</li>
  <li><strong>표면 이자율:</strong> 연 5% (매년 500원의 이자를 지급하기로 약속)</li>
</ul>

<p>이 채권을 발행가인 10,000원에 샀다면, 투자 수익률은 약속 그대로 연 5%입니다.</p>

<p>그런데 이 A회사가 유망하다는 소문이 나면서 채권을 사려는 사람(수요)이 몰렸습니다. 한정된 채권을 사기 위한 경쟁이 붙으면서, 시장 가격이 <strong>10,000원에서 12,000원으로 올랐습니다.</strong></p>

<p>이때 채권의 시장 가격은 12,000원으로 올랐지만, A회사가 지급하기로 약속한 <strong>이자액은 여전히 500원으로 고정</strong>되어 있습니다.</p>

<p>그렇다면 지금 12,000원을 주고 이 채권을 산 사람의 실제 수익률은 어떻게 될까요?</p>

<ul>
  <li><strong>발행 시점 수익률:</strong> 500원 ÷ 10,000원 = <strong>5%</strong></li>
  <li><strong>가격 상승 후 수익률:</strong> 500원 ÷ 12,000원 = <strong>약 4.16%</strong></li>
</ul>

<p>이처럼 채권 가격이 오르니, 투자금 대비 실제 얻게 되는 <strong>‘수익률’은 오히려 떨어졌습니다.</strong> 경제 뉴스에서 말하는 시장 금리는 바로 채권의 실제 수익률을 의미하는 경우가 많습니다. 즉 채권 가격이 오르면서, <strong>금리가 하락(5% → 4.16%)했다고 평가하게 됩니다.</strong></p>]]></content><author><name>Wonjoon</name></author><category term="investment" /><summary type="html"><![CDATA[채권 가격이 오르면 왜 시장 금리는 하락하는지, 그 역학 관계를 설명합니다.]]></summary></entry><entry><title type="html">Go 에러 처리: fmt.Errorf는 언제, 어떻게 사용해야 할까요?</title><link href="http://localhost:4000/2025/06/23/fmt-error-handling/" rel="alternate" type="text/html" title="Go 에러 처리: fmt.Errorf는 언제, 어떻게 사용해야 할까요?" /><published>2025-06-23T00:00:00+09:00</published><updated>2025-06-23T00:00:00+09:00</updated><id>http://localhost:4000/2025/06/23/fmt-error-handling</id><content type="html" xml:base="http://localhost:4000/2025/06/23/fmt-error-handling/"><![CDATA[<h2 id="핵심-요약-tldr">핵심 요약 (TL;DR)</h2>

<ul>
  <li><strong>언제 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 쓰면 안 되나요?</strong>
    <ul>
      <li>라이브러리(예: <code class="language-plaintext highlighter-rouge">backoff.Retry</code>)가 에러의 종류를 파악해야 할 때. <strong>원본 에러를 그대로 반환</strong>해야 라이브러리와의 ‘약속’을 지킬 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>언제 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 써야 하나요?</strong>
    <ul>
      <li>모든 재시도 등 정책적 판단이 끝난 후, 최종적으로 에러를 반환하는 시점. <strong>“재시도 끝에 실패”와 같은 명확한 맥락(Context)을 추가</strong>하기 위해 사용합니다.</li>
    </ul>
  </li>
  <li><strong>가장 중요한 원칙은 무엇인가요?</strong>
    <ul>
      <li><strong>역할 분리</strong>. 에러를 발생시키는 ‘실무자’ 함수와, 그 에러를 받아 정책을 결정하는 ‘매니저’ 함수로 역할을 나누고 각 계층에 맞는 책임을 부여하는 것입니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="질문-1-fmterrorf를-무조건-사용하면-왜-안-되나요">질문 1: <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 무조건 사용하면 왜 안 되나요?</h2>

<p>많은 Go 개발자가 외부 API 호출과 같은 불안정한 작업을 처리할 때 <code class="language-plaintext highlighter-rouge">cenk/backoff</code> 같은 라이브러리로 재시도 로직을 구현합니다. 이때 모든 에러를 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>로 감싸는 실수를 하곤 합니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">doRetry</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span><span class="n">Client</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ...</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">backoff</span><span class="o">.</span><span class="n">Retry</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
		<span class="n">bs</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span> <span class="c">// &lt;-- 여기서는 원본 에러를 그대로 반환</span>
	<span class="p">},</span> <span class="o">...</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="c">// &lt;-- 여기서는 컨텍스트를 추가하여 반환</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"failed after retries %w"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bs</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>결론부터 말하면, <strong>라이브러리가 에러의 종류를 보고 특정 행동(예: 재시도 중단)을 결정해야 할 때, <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>로 에러를 감싸면 원본 에러의 정보가 가려져 라이브러리가 올바르게 동작하지 못하기 때문입니다.</strong></p>

<h2 id="질문-2-어떻게-역할을-분리해야-하나요">질문 2: 어떻게 역할을 분리해야 하나요?</h2>

<p>견고한 에러 처리는 함수의 역할을 ‘실무자’와 ‘매니저’로 명확히 나누는 것에서 시작합니다.</p>

<ul>
  <li>실무자 (<code class="language-plaintext highlighter-rouge">do</code> 함수): 실제 작업을 딱 한 번 수행하고, 그 결과를 가공하지 않은 원본 에러 그대로 보고하는 역할만 합니다.</li>
  <li>매니저 (<code class="language-plaintext highlighter-rouge">doRetry</code> 함수): 실무자의 보고(원본 에러)를 받아 정책적 결정을 내립니다. 예를 들어 ‘일시적 오류’는 재시도, ‘영구적 오류’는 즉시 중단 같은 결정을 합니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">backoff.Retry</code> 라이브러리는 매니저의 ‘비서’와 같습니다. 비서는 실무자가 제출한 원본 에러 보고서에 <code class="language-plaintext highlighter-rouge">backoff.PermanentError</code> 같은 특정 도장이 찍혀 있는지 확인합니다. 만약 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>라는 별도의 봉투에 담아 보고하면, 비서는 중요한 도장을 보지 못하고 재시도하면 안 되는 일에 불필요한 노력을 쏟게 됩니다.</p>

<p>이것이 <code class="language-plaintext highlighter-rouge">backoff.Retry</code> 안에서는 원본 에러(<code class="language-plaintext highlighter-rouge">return err</code>)를 그대로 반환해야 하는 이유입니다. 라이브러리와의 약속(Contract)을 지키는 것이죠.</p>

<h2 id="질문-3-에러에-컨텍스트는-언제-추가해야-가장-좋은가요">질문 3: 에러에 컨텍스트는 언제 추가해야 가장 좋은가요?</h2>

<p>“재시도 끝에 실패했다”와 같은 구체적인 맥락은 <strong>매니저가 모든 정책적 판단을 끝낸 시점</strong>에 추가하는 것이 가장 좋습니다.</p>

<p><code class="language-plaintext highlighter-rouge">doRetry</code> 함수는 <code class="language-plaintext highlighter-rouge">backoff.Retry</code>가 최종적으로 실패했을 때, 비로소 <code class="language-plaintext highlighter-rouge">fmt.Errorf("failed after retries %w", err)</code>를 통해 더 자세한 컨텍스트를 담은 최종 에러를 생성하여 상위 호출자에게 반환합니다.</p>

<blockquote>
  <p><strong>Go 에러 처리 철학</strong>: 에러가 발생한 가장 낮은 수준에서는 원본을 유지하고, 계층을 따라 올라오며 각 계층의 역할에 맞는 컨텍스트를 추가합니다.</p>
</blockquote>

<h2 id="질문-4-defer를-사용할-때-에러는-어떻게-처리해야-하나요">질문 4: <code class="language-plaintext highlighter-rouge">defer</code>를 사용할 때 에러는 어떻게 처리해야 하나요?</h2>

<p><code class="language-plaintext highlighter-rouge">defer</code>로 리소스를 정리할 때 발생하는 에러를 놓치지 않으면서, 더 중요한 원인 에러를 덮어쓰지 않는 것이 중요합니다. 아래는 매우 실용적인 Go의 표준 패턴(idiomatic Go)입니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">do</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="n">bs</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">st</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="c">// &lt;-- 1. 반환 값을 'err'로 명명</span>
    <span class="c">// ...</span>
    <span class="c">// http 요청 등 주요 로직</span>
    <span class="c">// ...</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">closeErr</span> <span class="o">:=</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">();</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="c">// &lt;-- 2. 기존 에러가 없을 때만</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">closeErr</span> <span class="c">// &lt;-- 3. 뒷정리 에러를 최종 에러로 할당</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="c">// ...</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 패턴의 핵심은 <code class="language-plaintext highlighter-rouge">if err == nil</code> 조건입니다.</p>

<ul>
  <li>주요 로직에서 에러가 없었을 경우 (<code class="language-plaintext highlighter-rouge">err</code>가 <code class="language-plaintext highlighter-rouge">nil</code>일 때): defer문에서 발생한 뒷정리 에러(<code class="language-plaintext highlighter-rouge">closeErr</code>)를 최종 반환 에러로 삼습니다.</li>
  <li>주요 로직에서 이미 에러가 발생했을 경우 (<code class="language-plaintext highlighter-rouge">err</code>가 <code class="language-plaintext highlighter-rouge">nil</code>이 아닐 때): 덜 중요한 뒷정리 에러는 무시하고, 더 중요한 최초의 원인 에러를 그대로 보존하여 반환합니다.</li>
</ul>

<p>이는 “함수가 실패했다면, 그 최초의 원인을 보존하라”는 Go의 중요한 에러 처리 철학을 잘 보여줍니다</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Go 언어에서 fmt.Errorf를 올바르게 사용하는 방법을 알아봅니다. 모든 에러를 fmt.Errorf로 감싸는 것이 왜 안티 패턴인지, 재시도 로직과 에러 래핑(wrapping)의 모범 사례를 실제 코드를 통해 명확히 설명합니다.]]></summary></entry><entry><title type="html">맥북 10년 차 개발자가 전하는 구매 가이드</title><link href="http://localhost:4000/2025/03/20/macbook-purchase-guide/" rel="alternate" type="text/html" title="맥북 10년 차 개발자가 전하는 구매 가이드" /><published>2025-03-20T00:00:00+09:00</published><updated>2025-03-20T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/20/macbook-purchase-guide</id><content type="html" xml:base="http://localhost:4000/2025/03/20/macbook-purchase-guide/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/20">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[맥북 구매를 고민하는 개발자와 입문자를 위한 10년 차 개발자의 현실적인 구매 가이드. 나에게 맞는 모델 선택, 사양 결정, 그리고 필수 확인 사항까지 담았습니다.]]></summary></entry><entry><title type="html">Understanding inline Functions in C: When and How They Work</title><link href="http://localhost:4000/2025/03/17/inline-function-c/" rel="alternate" type="text/html" title="Understanding inline Functions in C: When and How They Work" /><published>2025-03-17T00:00:00+09:00</published><updated>2025-03-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/17/inline-function-c</id><content type="html" xml:base="http://localhost:4000/2025/03/17/inline-function-c/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#what-is-an-inline-function-in-c">What Is an inline Function in C?</a></li>
  <li><a href="#why-use-inline-functions">Why Use inline Functions?</a></li>
  <li><a href="#when-does-the-compiler-ignore-inline">When Does the Compiler Ignore inline?</a></li>
  <li><a href="#forcing-the-compiler-to-inline-a-function">Forcing the Compiler to Inline a Function</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="what-is-an-inline-function-in-c">What Is an inline Function in C?</h2>

<p>An <code class="language-plaintext highlighter-rouge">inline</code> function is a special function in C that suggests the compiler replace the function call with its actual code to optimize performance.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// Expands to: int result = (5 * 5);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>When the compiler processes <code class="language-plaintext highlighter-rouge">square(5)</code>, it replaces the function call with its definition: <code class="language-plaintext highlighter-rouge">int result = (5 * 5);</code></li>
  <li>This eliminates the overhead of function calls, potentially improving performance.</li>
</ul>

<h2 id="why-use-inline-functions">Why Use inline Functions?</h2>

<ul>
  <li>Performance Optimization – Reduces function call overhead.</li>
  <li>Encapsulation – Keeps function logic organized while avoiding extra calls.</li>
  <li>Reduced Stack Usage – No need to store function call metadata in the stack.</li>
</ul>

<h2 id="when-does-the-compiler-ignore-inline">When Does the Compiler Ignore inline?</h2>

<p>However, unlike Rust macros, inline in C is just a hint to the compiler—it does not guarantee inlining. The compiler decides whether to actually inline the function based on various optimization criteria.</p>

<p>Despite marking a function as inline, the compiler might not inline it in the following cases:</p>

<h3 id="1️-the-function-is-too-large">1️. The Function Is Too Large</h3>

<p>If a function contains too many instructions, inlining it could increase code size unnecessarily.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">big_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Large loop</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Expanding this function in multiple places increases binary size.</li>
  <li>Too much code duplication can harm performance rather than improve it.</li>
  <li>The compiler might keep it as a regular function instead.</li>
</ul>

<h3 id="2-recursive-functions">2. Recursive Functions</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Recursive call</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Inlining a recursive function is impossible in most cases because the function keeps calling itself.</li>
  <li>The compiler would need to unroll the recursion into a loop, which is not always feasible.</li>
  <li>If recursion depth is small and known in advance, consider manual loop unrolling instead.</li>
</ul>

<h3 id="3-function-pointers-prevent-inlining">3. Function Pointers Prevent Inlining</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span> <span class="c1">// Assign function to pointer</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">func_ptr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>     <span class="c1">// Compiler does not know function at compile time</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>When using function pointers, the actual function call is determined at runtime, not at compile time.</li>
  <li>The compiler cannot replace function calls with direct code expansion because the target function is unknown during compilation.</li>
  <li>Use direct function calls instead of function pointers when inlining is critical.</li>
</ul>

<h2 id="forcing-the-compiler-to-inline-a-function">Forcing the Compiler to Inline a Function</h2>

<p>If the compiler ignores inline, you can explicitly force inlining using compiler-specific attributes.</p>

<h3 id="1-gcc--clang-attributealways_inline">1. GCC &amp; Clang: <strong>attribute</strong>((always_inline))</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">))</span> <span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Ensures the function will always be inlined, even if it’s large.</li>
  <li>Only works if optimizations are enabled (-O2 or higher).</li>
  <li>Forcing inlining on a large function can increase binary size and reduce cache efficiency.</li>
</ul>

<h3 id="2-msvc-microsoft-compiler-__forceinline">2. MSVC (Microsoft Compiler): __forceinline</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__forceinline</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Forces the function to be inlined in Microsoft compilers (MSVC).</li>
  <li>Ensures consistent inlining behavior across different builds.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Use inline for:</p>

<ul>
  <li>Small, frequently used functions.</li>
  <li>Performance-sensitive calculations (e.g., mathematical operations).</li>
  <li>Functions that replace macros for better type safety.</li>
</ul>

<p>Avoid inline for:</p>

<ul>
  <li>Large functions (can increase binary size).</li>
  <li>Recursive functions.</li>
  <li>Functions used with pointers or virtual functions (C++).</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[inline functions in C allow code to be expanded at compile time and included in the final executable.]]></summary></entry><entry><title type="html">defer in Go Doesn’t Always Reflect the Latest Value</title><link href="http://localhost:4000/2025/03/14/go-defer-value/" rel="alternate" type="text/html" title="defer in Go Doesn’t Always Reflect the Latest Value" /><published>2025-03-14T00:00:00+09:00</published><updated>2025-03-14T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/14/go-defer-value</id><content type="html" xml:base="http://localhost:4000/2025/03/14/go-defer-value/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#the-problem">The Problem</a></li>
  <li><a href="#the-reason-why-status-is-not-updated">The Reason why status is not updated</a></li>
  <li><a href="#how-to-fix-it">How to Fix It?</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="the-problem">The Problem</h2>

<p>Consider the following Go function:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">status</span> <span class="kt">string</span>  <span class="c">// Initialized as an empty string</span>
    <span class="k">defer</span> <span class="n">notify</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">foo</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s">"error"</span>  <span class="c">// Status changes here, but defer does not reflect this change</span>
        <span class="k">return</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">status</span> <span class="o">=</span> <span class="s">"success"</span>
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We might expect notify(status) to reflect the latest value of status.
However, in reality, it always receives an empty string (<code class="language-plaintext highlighter-rouge">""</code>), regardless of how status is updated later.</p>

<h2 id="the-reason-why-status-is-not-updated">The Reason why status is not updated</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">status</span> <span class="kt">string</span> <span class="c">// ""</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">status</code> is initialized as an empty string</li>
  <li><code class="language-plaintext highlighter-rouge">defer</code> evaluates its arguments immediately when declared.
    <ul>
      <li>When <code class="language-plaintext highlighter-rouge">defer notify(status)</code> is called, <code class="language-plaintext highlighter-rouge">status</code> is still an empty string.</li>
      <li>Thus, <code class="language-plaintext highlighter-rouge">defer</code> captures the empty string(<code class="language-plaintext highlighter-rouge">""</code>) at this moment and never updates, even if <code class="language-plaintext highlighter-rouge">status</code> changes later.</li>
    </ul>
  </li>
  <li>Even though <code class="language-plaintext highlighter-rouge">status</code> is modified in the function, the deferred function call was already bound to the original value of <code class="language-plaintext highlighter-rouge">status</code> (empty string).</li>
  <li>In Go, when a function is deferred, its arguments are evaluated and stored immediately—not when the function actually executes.</li>
</ul>

<h2 id="how-to-fix-it">How to Fix It?</h2>

<p>To ensure that notify(status) receives the latest value of status, we can use two different approaches.</p>

<h3 id="1-using-a-closure-anonymous-function">1. Using a Closure (Anonymous Function)</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">notify</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">}()</span>
</code></pre></div></div>

<ul>
  <li>Instead of immediately passing <code class="language-plaintext highlighter-rouge">status</code> to <code class="language-plaintext highlighter-rouge">notify</code>, we defer an anonymous function.</li>
  <li>This function captures <code class="language-plaintext highlighter-rouge">status</code> at the moment <code class="language-plaintext highlighter-rouge">defer</code> executes, ensuring it reflects the latest value.</li>
  <li>When <code class="language-plaintext highlighter-rouge">notify(status)</code> is finally called, it uses the updated value of <code class="language-plaintext highlighter-rouge">status</code>.</li>
</ul>

<h3 id="2-passing-a-pointer">2. Passing a Pointer</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defer</span> <span class="n">notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Instead of passing the value of <code class="language-plaintext highlighter-rouge">status</code>, we pass its memory address (<code class="language-plaintext highlighter-rouge">&amp;status</code>).</li>
  <li>Since <code class="language-plaintext highlighter-rouge">defer</code> captures the pointer, any changes to <code class="language-plaintext highlighter-rouge">status</code> are reflected at execution time.</li>
  <li>However, this requires modifying <code class="language-plaintext highlighter-rouge">notify</code> to accept a pointer parameter.</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// If using a pointer, notify must be updated:</span>
<span class="c">// Dereference the pointer to get the latest value</span>
<span class="k">func</span> <span class="n">notify</span><span class="p">(</span><span class="n">status</span> <span class="o">*</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">)</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3-comparison-of-solutions">3. Comparison of Solutions</h3>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th>How it Works</th>
      <th>Requires Function Signature Change?</th>
      <th>Best Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Closure (Anonymous Function)</td>
      <td>Captures <code class="language-plaintext highlighter-rouge">status</code> at execution time</td>
      <td>No</td>
      <td>Works for most cases</td>
    </tr>
    <tr>
      <td>Pointer Passing (&amp;status)</td>
      <td>Passes a pointer, reflects latest value</td>
      <td>Yes</td>
      <td>When working with functions that support pointers</td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>Deferred functions capture arguments immediately, not when they actually run.</li>
  <li>If the deferred function needs the latest value, use:
    <ul>
      <li>Closures (Anonymous Functions): Recommended, as they don’t require modifying function signatures.</li>
      <li>Pointers (&amp;status): Useful when modifying function behavior explicitly.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[In Go, deferred functions capture arguments immediately, not when they actually run. Learn how to fix this common issue using closures or pointers to ensure your deferred calls use the latest variable values.]]></summary></entry><entry><title type="html">Using sync.Cond for Goroutine Synchronization in Go</title><link href="http://localhost:4000/2025/03/13/go-sync-cond/" rel="alternate" type="text/html" title="Using sync.Cond for Goroutine Synchronization in Go" /><published>2025-03-13T00:00:00+09:00</published><updated>2025-03-13T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/13/go-sync-cond</id><content type="html" xml:base="http://localhost:4000/2025/03/13/go-sync-cond/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#what-is-synccond">What is <code class="language-plaintext highlighter-rouge">sync.Cond</code>?</a></li>
  <li><a href="#how-synccond-works">How <code class="language-plaintext highlighter-rouge">sync.Cond</code> Works</a></li>
  <li><a href="#example-donation-goal-tracker-using-synccond">Example: Donation Goal Tracker Using <code class="language-plaintext highlighter-rouge">sync.Cond</code></a></li>
  <li><a href="#comparison-signal-vs-broadcast">Comparison: <code class="language-plaintext highlighter-rouge">Signal()</code> vs. <code class="language-plaintext highlighter-rouge">Broadcast()</code></a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="what-is-synccond">What is sync.Cond?</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> is a condition variable that helps synchronize multiple goroutines.</li>
  <li>It is typically used when one or more goroutines must wait until a shared resource reaches a specific state.</li>
  <li>One goroutine waits (<code class="language-plaintext highlighter-rouge">Wait()</code>) until a condition is satisfied, and another goroutine notifies (<code class="language-plaintext highlighter-rouge">Signal()</code> or <code class="language-plaintext highlighter-rouge">Broadcast()</code>) the waiting goroutines when the condition is met.</li>
</ul>

<h2 id="how-synccond-works">How sync.Cond Works</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Wait()</code></td>
      <td>Makes a goroutine wait until a condition is met (automatically unlocks the mutex)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Signal()</code></td>
      <td>Wakes only one waiting goroutine (even if multiple goroutines are waiting)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Broadcast()</code></td>
      <td>Wakes all waiting goroutines</td>
    </tr>
  </tbody>
</table>

<h2 id="example-donation-goal-tracker-using-synccond">Example: Donation Goal Tracker Using sync.Cond</h2>

<p>The following example demonstrates how <code class="language-plaintext highlighter-rouge">sync.Cond</code> can be used to coordinate multiple goroutines that monitor a donation goal.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Donation</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">cond</span>    <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span> <span class="c">// Condition variable</span>
    <span class="n">balance</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">donation</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Donation</span><span class="p">{</span>
        <span class="n">cond</span><span class="o">:</span> <span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{}),</span> <span class="c">// Create a condition variable with a mutex</span>
    <span class="p">}</span>

    <span class="c">// Listener goroutine (checks if goal is reached)</span>
    <span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">// Acquire mutex lock</span>
        <span class="k">for</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="n">goal</span> <span class="p">{</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait until balance &gt;= goal</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="p">)</span>
        <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">// Release mutex lock</span>
    <span class="p">}</span>

    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
    <span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="m">15</span><span class="p">)</span>

    <span class="c">// Updater goroutine (increments balance)</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="o">++</span> <span class="c">// Increase balance</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
            <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span> <span class="c">// Wake all waiting goroutines</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">20</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// Keep program running</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="step-1-creating-a-synccond-object">Step 1: Creating a sync.Cond Object</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Donation</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">cond</span>    <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">Cond</span>  
    <span class="n">balance</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="n">donation</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Donation</span><span class="p">{</span>
    <span class="n">cond</span><span class="o">:</span> <span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">{}),</span> 
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">cond</code>: A condition variable based on <code class="language-plaintext highlighter-rouge">sync.Mutex</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> provides synchronization between multiple goroutines using <code class="language-plaintext highlighter-rouge">Wait()</code>, <code class="language-plaintext highlighter-rouge">Signal()</code>, and <code class="language-plaintext highlighter-rouge">Broadcast()</code>.</li>
</ul>

<h3 id="step-2-listener-goroutine-fgoal-int">Step 2: Listener Goroutine (<code class="language-plaintext highlighter-rouge">f(goal int)</code>)</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">goal</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>  
    <span class="k">for</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="n">goal</span> <span class="p">{</span>
        <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span> <span class="c">// Wait until condition is met</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d goal reached</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="p">)</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>How It Works:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">donation.cond.L.Lock()</code>: Acquires mutex lock before checking <code class="language-plaintext highlighter-rouge">donation.balance</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">for donation.balance &lt; goal</code>: Checks if goal is reached.</li>
  <li><code class="language-plaintext highlighter-rouge">donation.cond.Wait()</code>:
    <ul>
      <li>Pauses execution until another goroutine calls <code class="language-plaintext highlighter-rouge">Signal()</code> or <code class="language-plaintext highlighter-rouge">Broadcast()</code>.</li>
      <li>Automatically releases the mutex lock while waiting.</li>
    </ul>
  </li>
  <li>Once woken up, the goroutine resumes execution, prints the message, and releases the lock (<code class="language-plaintext highlighter-rouge">L.Unlock()</code>).</li>
</ol>

<h3 id="step-3-updater-goroutine">Step 3: Updater Goroutine</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">{</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">balance</span><span class="o">++</span>      
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="n">donation</span><span class="o">.</span><span class="n">cond</span><span class="o">.</span><span class="n">Broadcast</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>How It Works:</p>

<ol>
  <li>Acquires the lock (<code class="language-plaintext highlighter-rouge">donation.cond.L.Lock()</code>).</li>
  <li>Increments the balance every second (<code class="language-plaintext highlighter-rouge">donation.balance++</code>).</li>
  <li>Releases the lock (<code class="language-plaintext highlighter-rouge">donation.cond.L.Unlock()</code>).</li>
  <li>Calls <code class="language-plaintext highlighter-rouge">donation.cond.Broadcast()</code>:
    <ul>
      <li>Wakes up all waiting goroutines.</li>
      <li>Each waiting goroutine checks if its goal is met and either continues waiting or exits.</li>
    </ul>
  </li>
</ol>

<h3 id="overall-execution-flow">Overall Execution Flow</h3>

<table>
  <thead>
    <tr>
      <th><strong>Step</strong></th>
      <th><strong>Active Goroutine(s)</strong></th>
      <th><strong>Balance</strong></th>
      <th><strong>After Broadcast()</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>f(10), f(15) (waiting)</td>
      <td>0</td>
      <td>Still waiting</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Updater goroutine</td>
      <td>1 -&gt; 9</td>
      <td>Still waiting</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Updater goroutine</td>
      <td>10</td>
      <td>f(10) wakes up and exits</td>
    </tr>
    <tr>
      <td>4</td>
      <td>f(15) (still waiting)</td>
      <td>11 -&gt; 14</td>
      <td>Still waiting</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Updater goroutine</td>
      <td>15</td>
      <td>f(15) wakes up and exits</td>
    </tr>
  </tbody>
</table>

<p>Key Observations:</p>

<ul>
  <li>Each time balance increases, <code class="language-plaintext highlighter-rouge">Broadcast()</code> wakes all waiting goroutines.</li>
  <li>If a goroutine’s goal is not met, it goes back to <code class="language-plaintext highlighter-rouge">Wait()</code>.</li>
  <li>If a goroutine’s goal is met, it exits after printing the result.</li>
  <li>Once all goals are reached, no goroutines are waiting, so <code class="language-plaintext highlighter-rouge">Broadcast()</code> no longer has any effect.</li>
</ul>

<h2 id="comparison-signal-vs-broadcast">Comparison: Signal() vs. Broadcast()</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Behavior</strong></th>
      <th><strong>Use Case</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Wait()</code></td>
      <td>Makes a goroutine wait until a condition is met (automatically unlocks the mutex)</td>
      <td>Used when waiting for a condition</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Signal()</code></td>
      <td>Wakes only one waiting goroutine (even if multiple goroutines are waiting)</td>
      <td>Use when a single goroutine should proceed</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Broadcast()</code></td>
      <td>Wakes all waiting goroutines</td>
      <td>Use when all goroutines should be notified</td>
    </tr>
  </tbody>
</table>

<p>When to Use <code class="language-plaintext highlighter-rouge">Signal()</code> vs. <code class="language-plaintext highlighter-rouge">Broadcast()</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Signal()</code>: Use when only one goroutine needs to proceed.</li>
  <li><code class="language-plaintext highlighter-rouge">Broadcast()</code>: Use when all waiting goroutines should be notified (e.g., donation.balance updates).</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> helps synchronize multiple goroutines by allowing them to wait for a condition to be met.</li>
  <li><code class="language-plaintext highlighter-rouge">Wait()</code> makes goroutines wait, while <code class="language-plaintext highlighter-rouge">Signal()</code> and <code class="language-plaintext highlighter-rouge">Broadcast()</code> notify them.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">Broadcast()</code> when all waiting goroutines should proceed, and use <code class="language-plaintext highlighter-rouge">Signal()</code> when only one goroutine should continue.</li>
  <li><code class="language-plaintext highlighter-rouge">sync.Cond</code> is useful for implementing event-based synchronization, such as resource availability or state changes.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[In Go, sync.Cond is a synchronization primitive that allows goroutines to efficiently wait until a certain condition is met. It helps coordinate multiple goroutines by providing a mechanism to wait (Wait()) and notify (Signal() or Broadcast()) when conditions change.]]></summary></entry><entry><title type="html">Understanding GasKVStore in Cosmos SDK</title><link href="http://localhost:4000/2025/03/12/cosmos-sdk-gaskvstore/" rel="alternate" type="text/html" title="Understanding GasKVStore in Cosmos SDK" /><published>2025-03-12T00:00:00+09:00</published><updated>2025-03-12T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/12/cosmos-sdk-gaskvstore</id><content type="html" xml:base="http://localhost:4000/2025/03/12/cosmos-sdk-gaskvstore/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#overview-of-gaskvstore">Overview of GasKVStore</a></li>
  <li><a href="#core-methods-of-gaskvstore">Core Methods of GasKVStore</a></li>
  <li><a href="#gas-consumption-based-on-key-and-value-size">Gas Consumption Based on Key and Value Size</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="overview-of-gaskvstore">Overview of GasKVStore</h2>

<p>GasKVStore measures gas usage in real-time as internal field values change during transaction execution.
Each read, write, and delete operation is designed to consume gas, ensuring that gas limits are properly enforced.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Store applies gas tracking to an underlying KVStore. It implements the KVStore interface.</span>
<span class="k">type</span> <span class="n">Store</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">gasMeter</span>  <span class="n">types</span><span class="o">.</span><span class="n">GasMeter</span>   <span class="c">// GasMeter that tracks gas usage during transactions</span>
    <span class="n">gasConfig</span> <span class="n">types</span><span class="o">.</span><span class="n">GasConfig</span>  <span class="c">// Configuration for gas costs of read/write/delete operations</span>
    <span class="n">parent</span>    <span class="n">types</span><span class="o">.</span><span class="n">KVStore</span>    <span class="c">// The underlying KVStore that stores actual data</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="core-methods-of-gaskvstore">Core Methods of GasKVStore</h2>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Functionality</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Get(key)</td>
      <td>Reads the value of a given key and consumes gas proportional to the key size</td>
    </tr>
    <tr>
      <td>Set(key, value)</td>
      <td>Stores a value for a given key and consumes gas based on both key and value size</td>
    </tr>
    <tr>
      <td>Delete(key)</td>
      <td>Deletes a key-value pair and consumes a fixed amount of gas</td>
    </tr>
  </tbody>
</table>

<h3 id="1-getkey---read-operation">1. Get(key) - Read Operation</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">GasKVStore</span><span class="p">)</span> <span class="n">Get</span><span class="p">(</span><span class="n">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="n">g</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">ConsumeGas</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">gasConfig</span><span class="o">.</span><span class="n">ReadCostPerByte</span> <span class="o">*</span> <span class="kt">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)),</span> <span class="s">"Read"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This function retrieves the value associated with a key.</li>
  <li>It is similar to searching for a word in a book.</li>
  <li>The function fetches and returns the data stored in the parent KVStore.</li>
</ul>

<h3 id="2-setkey-value---write-operation">2. Set(key, value) - Write Operation</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">GasKVStore</span><span class="p">)</span> <span class="n">Set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gasToConsume</span> <span class="o">:=</span> <span class="n">g</span><span class="o">.</span><span class="n">gasConfig</span><span class="o">.</span><span class="n">WriteCostPerByte</span> <span class="o">*</span> <span class="kt">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
    <span class="n">g</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">ConsumeGas</span><span class="p">(</span><span class="n">gasToConsume</span><span class="p">,</span> <span class="s">"Write"</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This function stores a new value for a given key.</li>
  <li>It works like adding new content to a book.</li>
  <li>The function records or updates data in the parent KVStore.</li>
</ul>

<h3 id="3-deletekey---delete-operation">3. Delete(key) - Delete Operation</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">GasKVStore</span><span class="p">)</span> <span class="n">Delete</span><span class="p">(</span><span class="n">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g</span><span class="o">.</span><span class="n">meter</span><span class="o">.</span><span class="n">ConsumeGas</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">gasConfig</span><span class="o">.</span><span class="n">DeleteCost</span><span class="p">,</span> <span class="s">"Delete"</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This function removes the data associated with a given key.</li>
  <li>It is similar to erasing a word from a book.</li>
  <li>The function deletes data stored in the parent KVStore.</li>
</ul>

<h2 id="gas-consumption-based-on-key-and-value-size">Gas Consumption Based on Key and Value Size</h2>

<p>Some methods in GasKVStore consume gas in proportion to the size of the key and value.
While gas in blockchain systems is often associated with CPU execution costs, the Cosmos SDK includes storage access costs as well.
Thus, the size of the key affects gas consumption.</p>

<h3 id="what-is-a-key">What is a Key?</h3>

<p>A key is an address that identifies a specific state in the blockchain.
It serves as an identifier for a specific data entry managed by a module.</p>

<p>Here are some examples:</p>

<h4 id="1-bank-module-storing-account-balances">1. Bank module storing account balances</h4>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="s">"balances/&lt;account_address&gt;"</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"&lt;account_balance&gt;"</span>
</code></pre></div></div>

<h4 id="2-staking-module-storing-validator-information">2. Staking module storing validator information</h4>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="s">"validators/&lt;validator_address&gt;"</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"&lt;validator_info&gt;"</span>
</code></pre></div></div>

<h4 id="3-ibc-module-storing-channel-information">3. IBC module storing channel information</h4>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="s">"ibc/ports/&lt;port_id&gt;/channels/&lt;channel_id&gt;"</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"&lt;channel_info&gt;"</span>
</code></pre></div></div>

<h3 id="why-key-size-affects-gas-consumption">Why Key Size Affects Gas Consumption?</h3>

<ul>
  <li>In the Cosmos SDK, gas is not only used for computation but also for storage access.</li>
  <li>Since accessing a key-value store (KVStore) consumes gas, larger keys and values require more gas.</li>
  <li>The longer the key, the more resources are needed to retrieve and store it, resulting in higher gas costs.</li>
</ul>

<h3 id="gas-consumption-per-method">Gas Consumption per Method</h3>

<table>
  <thead>
    <tr>
      <th><strong>Operation</strong></th>
      <th><strong>Function</strong></th>
      <th><strong>Gas Consumption Criteria</strong></th>
      <th><strong>Gas Consumption Amount</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Get(key)</td>
      <td>Reads the value of a key</td>
      <td>Proportional to key size</td>
      <td>Low</td>
    </tr>
    <tr>
      <td>Set(key, value)</td>
      <td>Stores a new value for a key</td>
      <td>Proportional to key + value size</td>
      <td>High</td>
    </tr>
    <tr>
      <td>Delete(key)</td>
      <td>Deletes a key-value pair</td>
      <td>Fixed cost (DeleteCost)</td>
      <td>Medium</td>
    </tr>
  </tbody>
</table>

<h4 id="1-getkey---gas-consumption-for-reads">1. Get(key) - Gas Consumption for Reads</h4>

<p>Gas is consumed in proportion to the key size since retrieving a value requires locating the key in storage.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Example: Retrieving an account balance from the bank module</span>
<span class="n">store</span> <span class="o">:=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">KVStore</span><span class="p">(</span><span class="n">bankStoreKey</span><span class="p">)</span>
<span class="n">balanceKey</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"balances/cosmos1xyz..."</span><span class="p">)</span>  <span class="c">// Using account address as key</span>
<span class="n">balance</span> <span class="o">:=</span> <span class="n">store</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">balanceKey</span><span class="p">)</span>  <span class="c">// Gas is consumed here</span>
</code></pre></div></div>

<h4 id="2-setkey-value---gas-consumption-for-writes">2. Set(key, value) - Gas Consumption for Writes</h4>

<p>Gas is consumed in proportion to the sum of key and value sizes since writing new data requires additional storage resources.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Example: Storing validator information</span>
<span class="n">store</span> <span class="o">:=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">KVStore</span><span class="p">(</span><span class="n">stakingStoreKey</span><span class="p">)</span>
<span class="n">validatorKey</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"validators/valoper1abc..."</span><span class="p">)</span>  
<span class="n">validatorInfo</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"{status: active, power: 1000}"</span><span class="p">)</span>  
<span class="n">store</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">validatorKey</span><span class="p">,</span> <span class="n">validatorInfo</span><span class="p">)</span>  <span class="c">// Gas is consumed here</span>
</code></pre></div></div>

<p>Steps:</p>

<ol>
  <li>Locate the key “validators/valoper1abc…” in storage (or create a new entry if it does not exist).</li>
  <li>Store the value “{status: active, power: 1000}”.</li>
  <li>Consume gas proportional to the size of both the key and value.</li>
</ol>

<h4 id="3-deletekey---gas-consumption-for-deletes">3. Delete(key) - Gas Consumption for Deletes</h4>

<p>Gas consumption is fixed (DeleteCost), independent of key size.</p>

<p><em>Why is deletion a fixed-cost operation?</em></p>

<ul>
  <li>Deleting is a simple operation
    <ul>
      <li>Writing new data (Set) modifies storage, while deleting data (Delete) simply marks it as removed.</li>
    </ul>
  </li>
  <li>Deletion can be faster than retrieval
    <ul>
      <li>Get(key) requires searching for a key, meaning longer keys take longer to process.</li>
      <li>Delete(key) usually marks data as deleted, which is computationally simpler.</li>
    </ul>
  </li>
  <li>Merkle Tree Structure
    <ul>
      <li>The Cosmos SDK uses a Merkle Tree-based IAVL Store, where deletions primarily mark nodes as invalid rather than requiring extensive modifications.</li>
      <li>As a result, gas does not need to scale with key size.</li>
    </ul>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>GasKVStore ensures real-time tracking of gas consumption during transaction execution, preventing gas limit violations.</li>
  <li>Gas is consumed not only for CPU operations but also for accessing and modifying storage (KVStore).</li>
  <li>Optimizing key and value sizes can help reduce unnecessary gas costs.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[GasKVStore is a core component of the Cosmos SDK that tracks gas consumption in real-time during transaction execution. It ensures every read, write, and delete operation consumes gas, preventing transactions from exceeding their gas limits.]]></summary></entry></feed>