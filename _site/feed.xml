<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-27T08:39:38+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">월리의 탐구생활</title><subtitle>A (nearly) no-CSS, fast, minimalist Jekyll theme.
</subtitle><author><name>Wonjoon</name></author><entry><title type="html">가스비 절감의 효과를 갖는 솔리디티의 custom error</title><link href="http://localhost:4000/2023/08/22/blockchain-custom-error-solidity/" rel="alternate" type="text/html" title="가스비 절감의 효과를 갖는 솔리디티의 custom error" /><published>2023-08-22T00:00:00+09:00</published><updated>2023-08-22T00:00:00+09:00</updated><id>http://localhost:4000/2023/08/22/blockchain-custom-error-solidity</id><content type="html" xml:base="http://localhost:4000/2023/08/22/blockchain-custom-error-solidity/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커스텀-에러&quot;&gt;커스텀 에러&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ethereum/solidity/releases/tag/v0.8.4&quot;&gt;솔리디티 v0.8.4&lt;/a&gt;에서 소개된 방법으로, 기존의 에러 표현 방식에 비해 가스비를 줄이면서 에러 발생의 원인을 설명할 수 있다.&lt;br /&gt;
아래는 기존의 방식과 커스텀 에러 방식 각각을 예시로 표현한 내용이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Before
revert(&quot;Insufficient funds.&quot;); // 사용 (선언 없음)

# Custom errors
error Unauthorized(); // 선언
...
revert Unauthorized(); // 사용
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;가스비는 스마트 컨트랙트의 배포(deploy)에 영향을 주는데, 이 외에도 기존의 방식은 에러에 대한 정보를 동적으로 관리하기 어렵다는 단점이 있었다.&lt;br /&gt;
커스텀 에러는 ‘error’ 구문을 사용한다. 그리고 외부(인터페이스 또는 라이브러리)에서 선언한 에러를 스마트 컨트랙트에 불러와서 사용할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized(); // Custom error

contract VendingMachine {
    address payable owner = payable(msg.sender);

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();  // Using custom error with revert statement

        owner.transfer(address(this).balance);
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/contracts.html?color=dark#events&quot;&gt;이벤트(event)&lt;/a&gt;와 구문이 비슷한 것을 볼 수 있는데, 차이점은 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/control-structures.html?color=dark#revert-statement&quot;&gt;revert 구문&lt;/a&gt;과 같이 사용해야 한다는 것이다. revert를 사용하면 현재까지 진행되던 상태 변환 프로세스가 모두 중단되고 에러 메시지를 호출자에게 전달한다. &lt;a href=&quot;https://github.com/ethereum/solidity/issues/11278&quot;&gt;require 구문의 사용은 현재 포스팅 시점(2023.08.23)에는 제공되지 않고 있는데&lt;/a&gt;, 아래의 예시를 보면 이해가 쉬울 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This Error message with require statement 
require(condition, &quot;error message&quot;)

# Should be translated to
if (!condition) revert CustomError()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;파라미터를-추가한-커스텀-에러&quot;&gt;파라미터를 추가한 커스텀 에러&lt;/h2&gt;

&lt;p&gt;커스텀 에러는 파라미터를 추가할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

/// Insufficient balance for transfer. Needed `required` but only
/// `available` available.
/// @param available balance available.
/// @param required requested amount to transfer.
error InsufficientBalance(uint256 available, uint256 required);

contract TestToken {
    mapping(address =&amp;gt; uint) balance;
    function transfer(address to, uint256 amount) public {
        if (amount &amp;gt; balance[msg.sender])
            // Error call using named parameters. Equivalent to
            // revert InsufficientBalance(balance[msg.sender], amount);
            revert InsufficientBalance({
                available: balance[msg.sender],
                required: amount
            });
        balance[msg.sender] -= amount;
        balance[to] += amount;
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면 커스텀 에러를 아래와 같이 선언하고,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error InsufficientBalance(uint256 available, uint256 required);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;revert InsufficientBalance({
    available: balance[msg.sender],
    required: amount
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용 시점의 에러 데이터는 abi.encodeWithSignature(“InsufficientBalance(uint256,uint256)”, balance[msg.sender], amount)로 ABI 인코딩된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;실제로-얼마나-스마트-컨트랙트-사이즈가-줄어드는가&quot;&gt;실제로 얼마나 스마트 컨트랙트 사이즈가 줄어드는가?&lt;/h2&gt;

&lt;p&gt;위에서 예시로 든 VendingMachine 스마트 컨트랙트 기준으로 커스텀 에러 사용 여부에 따른 사이즈를 비교해보았다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized(); // Custom error

contract VendingMachine {
    address payable owner = payable(msg.sender);

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();  // 커스텀 에러 사용 시
            revert(&quot;Insufficient funds.&quot;); // 커스텀 에러 미사용 시

        owner.transfer(address(this).balance);
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/IoBuilders/truffle-contract-size&quot;&gt;truffle-contract-size&lt;/a&gt;를 사용하여 각 상황별로 스마트 컨트랙트 사이즈를 계산한 결과는 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;커스텀 에러 사용 : 0.33 KiB&lt;/li&gt;
  &lt;li&gt;커스텀 에러 미사용 : 0.46 KiB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단순한 에러라 할지라도 대략 0.13 KiB 정도의 차이가 나는 것을 보면, 복잡한 로직이 들어간 스마트 컨트랙트 일수록 커스텀 에러의 적용이 꽤 유의미한 가치를 가져올 수 있을 것이라고 생각된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;좀더-깊이-커스텀-에러-들여다보기&quot;&gt;좀더 깊이 커스텀 에러 들여다보기&lt;/h2&gt;

&lt;p&gt;파라미터를 포함하지 않는 기본적인 커스텀 에러 ‘revert Unauthorized()’를 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/yul.html&quot;&gt;Yul 코드&lt;/a&gt;로 확인해보면 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Yul 코드는 다양한 백엔드에서 바이트코트 형태로 컴파일될 수 있도록 하는 중간 언어(intermediate language)를 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# revert Unauthorized();
let free_mem_ptr := mload(64)
mstore(free_mem_ptr, 0x82b4290000000000000000000000000000000000000000000000000000000000)
revert(free_mem_ptr, 4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 0x82b42900은 Unauthourized() 커스텀 에러의 selector를 의미한다. 그렇다면 커스텀 에러를 사용하지 않고 revert(“Unauthorized”)와 같이 에러 메시지를 그대로 사용하면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# revert(&quot;Unauthorized&quot;);
let free_mem_ptr := mload(64)
mstore(free_mem_ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
mstore(add(free_mem_ptr, 4), 32)
mstore(add(free_mem_ptr, 36), 12)
mstore(add(free_mem_ptr, 68), &quot;Unauthorized&quot;)
revert(free_mem_ptr, 100)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;0x08c379a0 값은 Error(에러메시지 문자열)의 selector를 의미한다. 단순히 코드만 봐도 커스텀 에러를 사용할 때가 더 적은 가스비를 소모하는 것을 볼 수 있다. 런타임 시점의 가스비는 revert 조건을 만족하는 경우에 대해서만 연관이 있다는 것을 기억하자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커스텀-에러-확인하기&quot;&gt;커스텀 에러 확인하기&lt;/h2&gt;

&lt;p&gt;그렇다면 커스텀 에러는 어떻게 확인할 수 있을까? 가장 최근 버전의 ethers.js를 사용하면 커스텀 에러 메시지를 디코딩한 값을 확인할 수 있다.&lt;br /&gt;
아래 예시는 위의 InsufficientBalance 커스텀 에러를 확인하는 경우를 나타낸다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { ethers } from &apos;ethers&apos;

// As a workaround, we have a function with the
// same name and parameters as the error in the abi.
const abi = [
  &apos;function InsufficientBalance(uint256 available, uint256 required)&apos;,
]

const interface = new ethers.utils.Interface(abi)
const error_data =
  &apos;0xcf479181000000000000000000000000000000000000&apos; +
  &apos;0000000000000000000000000100000000000000000000&apos; +
  &apos;0000000000000000000000000000000000000100000000&apos;

const decoded = interface.decodeFunctionData(
  interface.functions[&apos;InsufficientBalance(uint256,uint256)&apos;],
  error_data
)
// Contents of decoded:
// [
//   BigNumber { _hex: &apos;0x0100&apos;, _isBigNumber: true },
//   BigNumber { _hex: &apos;0x0100000000&apos;, _isBigNumber: true },
//   available: BigNumber { _hex: &apos;0x0100&apos;, _isBigNumber: true },
//   required: BigNumber { _hex: &apos;0x0100000000&apos;, _isBigNumber: true }
// ]
console.log(
  &apos;Insufficient balance for transfer. &apos; +
    `Needed ${decoded.required.toString()} but only ` +
    `${decoded.available.toString()} available.`
)
// Insufficient balance for transfer. Needed 4294967296 but only 256 available.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;주의점&quot;&gt;주의점&lt;/h2&gt;

&lt;p&gt;스마트 컨트랙트를 컴파일해서 ABI 형태의 JSON 파일로 만드는 과정에서, 컴파일러는 해당 스마트 컨트랙트가 나타낼 수 있는(emit) 모든 에러를 해당 파일에 포함시킨다. 여기서 중요한 것은 이 과정에 &lt;u&gt;external call로 호출되는 에러 메시지들은 포함되지 않는다&lt;/u&gt;는 것이다. 
이러한 이유로 개발자들은 에러 마다 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/natspec-format.html?color=dark&quot;&gt;NatSpec&lt;/a&gt; 형식을 준수하는 설명을 달아놓기도 한다. NatSpec은 개발자와 사용자가 추가 비용없이 에러 메시지에 대해 서로 이해할 수 있도록 하는 좋은 방법 중 하나이다.&lt;/p&gt;

&lt;p&gt;어쨋든 에러 메시지의 출처를 추적할 수 없기 때문에, 에러 데이터는 신중하게 사용해야 한다. external call 호출 횟수가 계속 늘어날수록, 발생하는 에러 메시지가 어디서부터 온 것인지 추적하기 점점 어려워진다는 것을 의미한다. 게다가 실제 에러가 아님에도 불구하고 에러메시지(처럼 보이는 문구)를 호출하도록 악의적으로 스마트 컨트랙트를 작성할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://soliditylang.org/blog/2021/04/21/custom-errors/&quot;&gt;Custom Errors in Solidity - Soliditylang.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">스마트 컨트랙트의 사이즈를 줄이는 방법</title><link href="http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size/" rel="alternate" type="text/html" title="스마트 컨트랙트의 사이즈를 줄이는 방법" /><published>2023-08-21T00:00:00+09:00</published><updated>2023-08-21T00:00:00+09:00</updated><id>http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size</id><content type="html" xml:base="http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;eip-170&quot;&gt;EIP-170&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-170&quot;&gt;EIP-170&lt;/a&gt;은 2016년 11월 22일에 발생한 하드포크 &lt;a href=&quot;https://blog.ethereum.org/2016/11/18/hard-fork-no-4-spurious-dragon&quot;&gt;‘Suprious Dragon’&lt;/a&gt; 시기에 공개되었으며, DoS(Denial of Service) 공격으로부터 이더리움 네트워크를 보호하기 위해 스마트 컨트랙트의 사이즈를 24,576kb로 제한하는 규칙을 제안한 내용이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If block.number &amp;gt;= FORK_BLKNUM, then if contract creation initialization returns data with length of more than MAX_CODE_SIZE bytes, contract creation fails with an out of gas error.

- MAX_CODE_SIZE: 0x6000 (2**14 + 2**13)
- FORK_BLKNUM: 2,675,000
- CHAIN_ID: 1 (Mainnet)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이더리움 네트워크에서는 잠재적으로 최소 2번의 O(n) 만큼 가스가 사용될 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;디스크에서 읽어온 스마트 컨트랙트에 대한 코드를 VM 환경에서 실행하기 위해 전처리하는 과정에서 O(n)&lt;/li&gt;
  &lt;li&gt;블록의 유효성 증명을 위해 데이터를 머클 증명에 추가하는 과정의 O(n)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이를 이더리움에서는 2차 취약점(Quadratic Vulnerability) 이라고 언급하는데, 결국 스마트 컨트랙트 자체의 크기로 인하여 트랜잭션 처리 성능에 영향을 주는 경우가 발생하게 된다.&lt;br /&gt;
그리고 꼭 DoS가 아니더라도 굉장히 간단한 기능만을 사용하려는 사용자의 경우 단순히 &lt;u&gt;스마트 컨트랙트가 길다&lt;/u&gt;는 이유만으로 많은 가스비와 시간을 소비해야 할 수도 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스마트-컨트랙트의-사이즈를-확인하는-방법&quot;&gt;스마트 컨트랙트의 사이즈를 확인하는 방법&lt;/h2&gt;

&lt;p&gt;스마트 컨트랙트 바이트코드의 크기를 확인하려면 &lt;a href=&quot;https://github.com/IoBuilders/truffle-contract-size&quot;&gt;truffle-contract-size&lt;/a&gt;를 사용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;단계별로-스마트-컨트랙트의-사이즈를-줄이는-방법&quot;&gt;단계별로 스마트 컨트랙트의 사이즈를 줄이는 방법&lt;/h2&gt;

&lt;p&gt;본문에서는 3단계로 스마트 컨트랙트의 사이즈를 줄이는 방법을 제시한다.&lt;br /&gt;
1단계가 가장 큰 효과를 줄 수 있는(Big impact) 방법이고, 단계가 올라갈수록 소소하게 효과를 줄 수 있는 방법으로 보면 된다.&lt;/p&gt;

&lt;h3 id=&quot;1-big-impact&quot;&gt;1. Big impact&lt;/h3&gt;

&lt;h4 id=&quot;11-스마트-컨트랙트-분리하기&quot;&gt;1.1. 스마트 컨트랙트 분리하기&lt;/h4&gt;

&lt;p&gt;스마트 컨트랙트 분리의 첫걸음은 좋은 구조(Good Architecture)로부터 시작한다. 스마트 컨트랙트가 작아질수록 가독성은 높아진다.&lt;/p&gt;

&lt;p&gt;스마트 컨트랙트 분리 시 생각해보아야 하는 점들은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함께 동작하는 기능들은 모아두는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;상태(state)값을 확인 또는 변경하지 않는 기능은 분리해도 좋다.&lt;/li&gt;
  &lt;li&gt;스토리지(storage)에 접근하지 않는다면 분리해도 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;12-라이브러리-사용하기&quot;&gt;1.2. 라이브러리 사용하기&lt;/h4&gt;

&lt;p&gt;라이브러리를 사용하면 효율적으로 특정 기능들을 별도의 스마트 컨트랙트로 분리할 수 있다. 라이브러리는 다른 스마트 컨트랙트에서 컴파일 과정에 추가되어 사용되기 때문에 internal로 선언되어서는 안된다.&lt;br /&gt;
라이브러리를 사용할 때에는 &lt;a href=&quot;https://solidity.readthedocs.io/en/v0.6.10/contracts.html#using-for&quot;&gt;using for&lt;/a&gt;을 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity &amp;gt;=0.6.0 &amp;lt;0.7.0;

struct Data { mapping(uint =&amp;gt; bool) flags; }

library Set {
    function insert(Data storage self, uint value)
        public
        returns (bool)
    {
        if (self.flags[value])
            return false; // already there
        self.flags[value] = true;
        return true;
    }
    ...
}

contract C {
    using Set for Data; // this is the crucial change
    Data knownValues;

    function register(uint value) public {
        require(knownValues.insert(value));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약 public 함수로 외부에서 직접 사용할 수 있도록 선언하고자 한다면, 별도의 스마트 컨트랙트로 배포하는 것이 옳다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;13-프록시-적용하기&quot;&gt;1.3. 프록시 적용하기&lt;/h4&gt;

&lt;p&gt;본문에서는 프록시를 가장 진보한(advanced) 방법이라고 표현하는데, 다른 스마트 컨트랙트의 기능을 통해 본래 스마트 컨트랙트의 상태를 변경하는 delegatecall 호출 방식을 사용한다.&lt;br /&gt;
프록시 방법의 대표적인 예가 &lt;a href=&quot;https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2&quot;&gt;upgradable한 스마트 컨트랙트&lt;/a&gt;인데, 단점은 그만큼 코드가 복잡해진다는 것이다.&lt;br /&gt;
만약 단순히 스마트 컨트랙트의 사이즈만 줄이기 위해서는 사용을 권장하지 않는다고 한다.&lt;/p&gt;

&lt;h3 id=&quot;2-medium-impact&quot;&gt;2. Medium impact&lt;/h3&gt;

&lt;h4 id=&quot;21-함수-개수-줄이기&quot;&gt;2.1. 함수 개수 줄이기&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;External : 편리한 사용성을 위해 우리는 view 함수를 자주 작성하곤 한다. 스마트 컨트랙트 제한 크기 이하라면 전혀 상관이 없다만, 아니라면 가장 필요로하는 한개만 남긴다는 생각으로 함수를 줄이는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;Internal : 단발성으로 호출되는 internal 또는 private 함수를 줄이고, 이를 사용하는 함수 내부에 인라인 코드로 작성하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;22-새로운-변수-선언-줄이기&quot;&gt;2.2. 새로운 변수 선언 줄이기&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Before
function get(uint id) returns (address,address) {
    MyStruct memory myStruct = myStructs[id];
    return (myStruct.addr1, myStruct.addr2);
}

# After
function get(uint id) returns (address,address) {
    return (myStructs[id].addr1, myStructs[id].addr2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;별도의 변수를 선언하지 않았을 때, 무려(?) 0.28kb의 크기를 감소시킬 수 있다. 꼭 별도로 선언해야 하는 변수가 아니라면, 선언되어 있는 변수를 재활용하자.&lt;/p&gt;

&lt;h4 id=&quot;23-짧은-에러메시지&quot;&gt;2.3. 짧은 에러메시지&lt;/h4&gt;

&lt;p&gt;에러메시지의 길이 또한 스마트 컨트랙트의 크기를 변화시키는 요인이 된다. 에러 상황을 나타낼 때 메시지 보다는 코드를 사용할 것을 권장한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Before
require(msg.sender == owner, &quot;Only the owner of this contract can call this function&quot;);

# After
require(msg.sender == owner, &quot;OW1&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;24-커스텀-에러-사용하기&quot;&gt;2.4. 커스텀 에러 사용하기&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://soliditylang.org/blog/2021/04/21/custom-errors/&quot;&gt;솔리디티 0.8.4에서 소개된 커스텀 에러 방식&lt;/a&gt;은 스마트 컨트랙트의 사이즈를 줄일 수 있는 꽤나 효과적인 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error Unauthorized();

if (msg.sender != owner) {
    revert Unauthorized();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 방식이 커스텀 에러인데, 이처럼 선언하게 되면 해당 에러가 selector 형식으로 ABI 인코딩된다. 커스텀 에러 안에서도 다양한 방식이 있는데, 추후 포스팅하겠다.&lt;/p&gt;

&lt;h4 id=&quot;25-optimizer-수정하기&quot;&gt;2.5. Optimizer 수정하기&lt;/h4&gt;

&lt;p&gt;기본값 200은 것은 함수가 200번 호출될 경우를 대비한 바이트코드의 최적화를 의미한다. 만약 값을 1로 한다면 단일 호출인 경우에 대한 바이트코드 최적화를 의미하게 되는데, 다른 의미로 배포(deployment)를 나타내게 된다.&lt;br /&gt;
Optimizer에 사용되는 값이 증가할수록 가스비가 증가하므로, 배포된 이후 해당 컨트랙트를 직접 호출하는 경우가 없다면 값을 최소화하여 적용하는 방안을 고려하는 것을 권장한다.&lt;/p&gt;

&lt;h3 id=&quot;3-small-impact&quot;&gt;3. Small impact&lt;/h3&gt;

&lt;h4 id=&quot;31-함수-파라미터로-구조체-전달하지-않기&quot;&gt;3.1. 함수 파라미터로 구조체 전달하지 않기&lt;/h4&gt;

&lt;p&gt;ABIEncoderV2에서는 함수의 파라미터로 구조체를 전달할 수 있다. 편의성은 올라갈 수 있지만 스마트 컨트랙트의 사이즈는 증가한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Passing struct
function get(uint id) returns (address,address) {
    return _get(myStruct);
}

function _get(MyStruct memory myStruct) private view returns(address,address) {
    return (myStruct.addr1, myStruct.addr2);
}

# Passing variables
function get(uint id) returns(address,address) {
    return _get(myStructs[id].addr1, myStructs[id].addr2);
}

function _get(address addr1, address addr2) private view returns(address,address) {
    return (addr1, addr2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;구조체가 아닌 파라미터를 전달할 경우, 0.1kb의 크기가 차이난다.&lt;/p&gt;

&lt;h4 id=&quot;32-기능에-맞는-visibility-적용하기&quot;&gt;3.2. 기능에 맞는 visibility 적용하기&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;함수가 무조건 외부에서만 호출되는 경우 : public&lt;/li&gt;
  &lt;li&gt;함수가 다른 스마트 컨트랙트를 통해서만 호출되는 경우 : private 또는 internal&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;33-modifier-삭제하기&quot;&gt;3.3. Modifier 삭제하기&lt;/h4&gt;

&lt;p&gt;Modifier는 스마트 컨트랙트 사이즈에 큰 영향을 준다. 차라리 함수를 사용할 것을 권장한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Use modifier
modifier checkStuff() {}
function doSomething() checkStuff {}

# Use only functions
function checkStuff() private {}
function doSomething() { checkStuff(); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ethereum.org/en/developers/tutorials/downsizing-contracts-to-fight-the-contract-size-limit/&quot;&gt;DOWNSIZING CONTRACTS TO FIGHT THE CONTRACT SIZE LIMIT - ethereum.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">다자간 상대매매를 스마트 컨트랙트로 구성할 수 있을까?</title><link href="http://localhost:4000/2023/02/13/blockchain-mc-trade-contract/" rel="alternate" type="text/html" title="다자간 상대매매를 스마트 컨트랙트로 구성할 수 있을까?" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/2023/02/13/blockchain-mc-trade-contract</id><content type="html" xml:base="http://localhost:4000/2023/02/13/blockchain-mc-trade-contract/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;비상장주식과-거래-방법&quot;&gt;비상장주식과 거래 방법&lt;/h2&gt;

&lt;p&gt;비상장주식은 상장요건에 다소 미달하거나, 상장요건은 갖추었으나 회사의 사정에 의해 기업공개(IPO)를 하지 않아 거래소 및 코스닥 시장에 상장되지 않은 주식을 말한다 (출처: &lt;a href=&quot;https://www.myasset.com/myasset/static/trading/TR_1602000_P1T1.jsp&quot;&gt;유안타증권&lt;/a&gt;). 비상장주식의 거래는 크게 플랫폼, K-OTC(장외주식시장), 커뮤니티 게시판을 통해 이루어진다. 공식적으로는 플랫폼과 K-OTC를 증권계좌와 연계하여 계좌이체를 통해 거래하도록 되어있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218652134-4c3e6fba-e757-4878-ba06-e846382afd36.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 1 : 비상장주식 거래 방식 비교 - KVIC&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림을 보면, 비상장주식을 거래하는 방식은 크게 일대일 상대매매 또는 다대다(다자간) 상대매매로 구분된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일대일 상대매매&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;종목을 팔고자 하는 사람과 사고자 하는 사람이 일대일로 수량과 가격을 협의하여 거래&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;다자간 상대매매&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;종목에 대한 수량과 가격을 제시하고, 매도 호가와 매수 호가가 일치하는 경우 일치하는 수량 범위 내에서 자동으로 거래가 체결&lt;/li&gt;
  &lt;li&gt;동일 가격의 호가가 존재하면, 먼저 호가가 접수된 경우부터 진행&lt;/li&gt;
  &lt;li&gt;가격이 일치하지 않으면, 체결을 원하는 투자자가 상대호가를 보고 자신의 호가를 정정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 글에서 알 수 있듯이, 다자간 상대매매는 현재 증권 시스템에서 사용하고 있는 일반적인 거래 방식을 의미한다. 일대일 상대매매는 다른 표현으로 게시판 거래라고도 말하는데, 구매하고자 하는 종목을 발견하면, 구매 가능한 수량과 가격은 두 거래 당사자가 협의하고 정하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;다자간-상대매매&quot;&gt;다자간 상대매매&lt;/h2&gt;

&lt;p&gt;다자간 상대매매를 조금 더 이해하기 쉽게 그림으로 표현하면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218661781-0b4eec96-6dea-4980-a9f5-0da42df89a6c.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 2 : Alice와 Bob이 각각 월리전자 주식을 매도 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림에서 가운데는 월리전자라는 주식의 현재 매도 또는 매수 요청된 내역을 보여준다. Alice는 1주당 11000원의 가격으로 2주를, Bob은 1주당 10000원의 가격으로 3주를 매도신청한 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218661835-8a1e5571-cbe6-4ad4-acdc-5a9042e1db21.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 3 : Chris가 월리전자 주식을 매수 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Chris는 10000원으로 매도 신청 되어있는 월리전자의 주식 3주를 매수 신청한다. 그러면 10000원에 매도 요청되어 있던 상품은 모두 매수되어 없어진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218661894-0a9f5c02-b566-46e0-8f46-286c9f3ed040.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 4 : Alice가 월리전자 주식을 매수 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;10000원에 월리전자 주식을 매도한 Alice가 갑자기 오르기 시작하는 주식 가격을 보고 무지성 매수를 다시 하기 시작했다고 하자. 11000원에 매도 요청되어있는 주식 중 1개만 우선 구매하기로 가정했다고 하자. 그러면 위와 같이 11000원에 매도 요청되어있는 주식 중 Alice가 요청한 1주에 대한 매수만 이루어지며, 이전에 Bob이 매도요청한 2개 중 1개는 계속 남아있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218661962-2da07c07-6740-41f1-a776-35d695689df4.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 5 : Chris가 월리전자 주식을 매도 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Chris가 이익을 남기고자 10000원에 구매한 월리전자 주식 3주를 모두 12000원에 매도 요청한다. Alice는 또 다시 무지성 매수를 하기로 마음먹고 12000원에 총 4주를 매수하고자 한다. 하지만 12000원에 형성되어 있는 주식의 총 개수는 3개이므로, Alice는 우선 3주만 매수가 확정된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218662003-0aad3d27-8b7c-4811-9a62-1d2d18a3669c.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 6 : Bob이 월리전자 주식을 매도 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이후 Bob이 본인이 11000원에 매도 신청했던 내역을 취소하고 12000원으로 정정하여 매도를 신청한다. 그러면 이전에 매수신청을 했던 Alice의 차례가 왔을 때, 해당 주식이 매수처리된다.&lt;/p&gt;

&lt;p&gt;위 그림들을 정리하여 다자간 상대매매 방식을 요약해보면 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;매도자와 매수자 간 원하는 가격이 일치하는 경우 거래가 발생한다.&lt;/li&gt;
  &lt;li&gt;해당 가격대에 형성된 매도 요청 수량보다 매수 요청 수량이 작거나 같으면, 매수 요청한 수량만큼 거래가 발생한다.&lt;/li&gt;
  &lt;li&gt;해당 가격대에 형성된 매도 요청 수량보다 매수 요청 수량이 많은 경우, 거래 가능한 매수 요청 수량만큼 매수가 발생하고 남은 개수는 추가적인 매도 요청 수량이 들어왔을 때 순차적으로 완료된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스마트-컨트랙트로-구현할-수-있을까&quot;&gt;스마트 컨트랙트로 구현할 수 있을까?&lt;/h2&gt;

&lt;p&gt;결론부터 말하면, 가능하다. 거래가 발생할 수 있는 중요도 순으로 정리해보면 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;거래하고자 하는 종목&lt;/li&gt;
  &lt;li&gt;매도 또는 매수하고자 하는 가격대&lt;/li&gt;
  &lt;li&gt;매도 또는 매수하고자 하는 주식량&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;중요한 것은, 스마트 컨트랙트로 구현하게 될 경우 토큰 증권화 된 주식과 이를 1:1로 거래하기 위한 별도의 유틸리티 토큰(이더리움의 경우 일반적으로 ERC-20으로 이루어진)이 필요하다. 만약 유틸리티 토큰의 종류가 K은행토큰, S은행토큰과 같이 여러개라고 가정하자. 그렇다면 1과 2 사이에 토큰 증권화 되어있는 주식을 거래할 수 있는 유틸리티 토큰의 종류가 포함되어야 할 것이다. 위의 중요도 순으로 맵을 구성하여 토큰 증권 별 형성된 거래 내역을 정리하면 될 것이다.&lt;/p&gt;

&lt;h3 id=&quot;1-순차적으로-거래되어야-하는-조건&quot;&gt;1. 순차적으로 거래되어야 하는 조건&lt;/h3&gt;

&lt;p&gt;하지만 가장 중요한 점이 있는데, 다자간 상대매매는 &lt;u&gt;순차적으로 거래&lt;/u&gt;된다는 것이다. 맵은 순서를 보장하지 않는다. 그렇다면 사용할 수 있는 방법은 리스트(LinkedList)일텐데, 아쉽게도 솔리디티에서는 이를 지원하지 않는다. 그렇다면? 별도로 만들어서 사용해야 할 것이다.&lt;/p&gt;

&lt;p&gt;하지만 솔리디티는 함수 내에서 진행되는 코드의 라인별로 gas를 측정한다. 퍼블릭이 아닌 프라이빗 환경에서 Quorum과 같은 플랫폼으로 이더리움을 구성하면 gas는 무시되기도 하지만, 그렇다고 해도 이더리움이 자체적으로 너무 많은 gas를 소모하는 경우에 프로그램을 정지시키기도 한다. 이러한 경우 수많은 거래 내역을 순차적으로 돌아다녀도 일치하는 거래 조건을 찾지 못하게되면 프로그램은 정지될 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;2-프로그램이-정지될-확률이-존재하는지-확인할-필요&quot;&gt;2. 프로그램이 정지될 확률이 존재하는지 확인할 필요&lt;/h3&gt;

&lt;p&gt;그렇기 때문에 루프가 어느정도까지 돌았을 때 프로그램이 정지할 수 있는지에 대한 선행 학습이 필요하다. 그 이후에 거래 전 미리 정지될 확률을 확인하고 거래를 진행하는 것이 좋다. 이를 위해서는 &lt;u&gt;해당 토큰증권을 특정 유틸리티 토큰으로 거래하기 위해 요청된 전체 내역의 수&lt;/u&gt;를 각각 가지고 있는 것이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;3-스마트-컨트랙트로-개발할-경우의-이점은&quot;&gt;3. 스마트 컨트랙트로 개발할 경우의 이점은?&lt;/h3&gt;

&lt;p&gt;우선, 토큰증권을 적용할 수 있는 플랫폼은 상식적으로 퍼블릭 환경에서 구성되지 않을 가능성이 높다. 이미 &lt;a href=&quot;https://www.fsc.go.kr/no010101/79386?srchCtgry=&amp;amp;curPage=&amp;amp;srchKey=&amp;amp;srchText=&amp;amp;srchBeginDt=&amp;amp;srchEndDt=&quot;&gt;금융위원회의 보도자료&lt;/a&gt;에서도 보면, 퍼블릭 형태의 블록체인이 아닌 여러 협의체가 함꼐(컨소시움 형태로) 노드를 구성하는 프라이빗 블록체인의 형태를 지향하고 있음을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 블록체인은 100% P2P 거래방식보다는, 별도의 인증된 어플리케이션에서 트랜잭션을 발생시키고, 이를 블록체인으로 2차 전달할 가능성이 높다. 굳이 빈번하게 발생하는 거래를 모두 블록체인에서 처리하기보단, 어플리케이션에서 이를 1차 처리하는 방법이 속도면에서는 더욱 유리할 것이다.&lt;/p&gt;

&lt;p&gt;하지만 현재 장외시장거래의 특성상 거래가 빈번하지 않음을 고려한다면, 스마트 컨트랙트로 다자간 상대매매를 진행하는 이점이 없다고만 할 수는 없다. 스마트 컨트랙트를 통해 배포된 프로그램은 임의로 조작하거나 재배포할 수 없기 때문에, 그 자체로도 부정적인 공격 또는 위변조로부터 보호받을 수 있다. 완전하진 않지만, 컨소시움으로 구성된 협의체 간은 공유되는 내용이기 때문에 어느 한 협의체에서 이를 임의대로 조작할 수도 없다.&lt;/p&gt;

&lt;p&gt;스마트 컨트랙트로 구성하는 것이 가장 불편해지는 상황은 바로 ‘속도(TPS)’이다. 단순히 트랜잭션 하나 당 처리되는 시간이 아니라, 시간 별로 처리(블록체인의 블록에 confirm되는)되는 시간이 더 빠르게 요구될 수록 블록체인은 사용성이 매우 낮아진다. 일반적인 증권거래에서는 아직 블록체인을 100% 활용할 수 없는 가장 큰 이유인데, 장외시장의 경우에는 거래량이 크지 않기 떄문에 블록체인만을 가지고 거래를 할 경우 어떠한 또 다른 이점이 있는지 확인해볼 수 있는 좋은 기회가 될 수 있을 것이라고 본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.fsc.go.kr/no010101/79386?srchCtgry=&amp;amp;curPage=&amp;amp;srchKey=&amp;amp;srchText=&amp;amp;srchBeginDt=&amp;amp;srchEndDt=&quot;&gt;보도자료:토큰 증권(Security Token) 발행·유통 규율체계 정비방안 - 금융위원회&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://news.mt.co.kr/mtview.php?no=2021102013545118652&quot;&gt;뜨겁지만 위험한 비상장주식 투자…거래 플랫폼별로 살펴보니 - 머니투데이&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kvicnewsletter.co.kr/page/view.php?idx=430&quot;&gt;안전한 비상장주식의 거래방법이 궁금하다면? - KVIC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;file:///Users/ssbc/Downloads/(%EC%B2%A8%EB%B6%802)K_OTC_Full+Version.pdf&quot;&gt;K-OTC의 이해 - 금융투자협회&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">아파치 카프카에 대해 매우 간략하게 알아보기</title><link href="http://localhost:4000/2022/12/23/tool-kafka/" rel="alternate" type="text/html" title="아파치 카프카에 대해 매우 간략하게 알아보기" /><published>2022-12-23T15:00:00+09:00</published><updated>2022-12-23T15:00:00+09:00</updated><id>http://localhost:4000/2022/12/23/tool-kafka</id><content type="html" xml:base="http://localhost:4000/2022/12/23/tool-kafka/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;카프카는-왜-주목받기-시작했는가&quot;&gt;카프카는 왜 주목받기 시작했는가?&lt;/h2&gt;

&lt;p&gt;데이터를 송신(Source)하는 어플리케이션과 수신(Target)하는 어플리케이션이 많아지면서 이를 위한 데이터 라인이 점점 복잡해지고 이를 통해 효과적인 데이터 처리 시스템이 필요해지기 시작했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517275-c2b158c6-01d8-47f1-b15f-a01e1201f57d.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 1 : 어플리케이션의 다양화로 인하여 복잡해진 데이터 라인&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같이 데이터 라인이 많아지면 아래와 같은 문제점이 발생할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;배포 단계가 복잡하고 어려워진다.&lt;/li&gt;
  &lt;li&gt;장애가 발생하면 원인 지점을 파악하는 것이 어려워진다.&lt;/li&gt;
  &lt;li&gt;어플리케이션마다 프로토콜이 다양해지면서, 처리 작업이 많이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209498379-9f169a13-7c74-4575-af84-71e5049b29d7.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;@그림 2 : 아파치 카프카는 다양한 앱을 하나의 플랫폼에서 간편하게 구독, 처리할 수 있도록 하는 플랫폼이다 - 출처 : &lt;a href=&quot;https://www.youtube.com/watch?v=waw0XXNX-uQ&amp;amp;t=87s&quot;&gt;데브원영&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;카프카는 &lt;a href=&quot;https://engineering.linkedin.com/teams/data/data-infrastructure/streams/kafka&quot;&gt;링크드인(LinkedIn)&lt;/a&gt;에서 만든 오픈소스로, 링크드인에 적용된 카프카에 대해 자세히 알고싶다면 &lt;a href=&quot;https://engineering.linkedin.com/blog/topic/kafka&quot;&gt;이곳(Kafka Ecosystem at LinkedIn)&lt;/a&gt;을 참조하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517445-4d67d84c-0da9-4d47-847b-85dd2e8c89c2.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 3 : 아파치 카프카를 통해 데이터를 송수신하는 구조&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;결국 카프카의 가장 큰 목적은 ‘송신 어플리케이션과 수신 어플리케이션 간 커플링을 최대한 약하게’하는 것인데, &lt;u&gt;송신 어플리케이션은 카프카에 데이터를 전송하기만 하면되고, 수신 어플리케이션이 카프카로부터 데이터를 가져오는 형태&lt;/u&gt;가 된다. 예를 들어 쇼핑몰이 있다고 가정하면, 송신 어플리케이션에서는 상품을 클릭하거나 구매할 때 로그를 발생하고 타겟 어플리케이션에서 이러한 로그를 적재하고 처리할 수 있도록 만든 후 카프카를 이용해 효과적으로 데이터 라인을 구성할 수 있게 된다. 여기서 송신 어플리케이션의 경우 json, tsv, avro 등 데이터 포멧에 대한 제한 없이 대부분을 처리할 수 있도록 지원한다.&lt;/p&gt;

&lt;p&gt;결국 카프카를 이용함으로써 얻는 장점은 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;고가용성(Fault Tolerant)을 지원하여, 갑작스런 서버 중단 또는 장애에도 데이터를 손실없이 복구할 수 있다.&lt;/li&gt;
  &lt;li&gt;낮은 지연(latency), 높은 처리량(throughput)을 통한 수많은 데이터의 빠른 처리가 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;AMQP(Advanced Message Queue Protocol)와 비교되기도 하는데, 자세한 내용은 포스팅하지 않고 하단에 참고자료로 첨부한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;토픽topic&quot;&gt;토픽(Topic)&lt;/h2&gt;

&lt;p&gt;카프카 내부에 존재하는 모든 데이터는 토픽이라는 큐 형태의 공간에 들어가게 된다. 카프카의 프로듀서가 데이터를 카프카에 송신하면 카프카의 컨슈머가 카프카로부터 원하는 데이터 형태에 맞는 토픽을 가져오는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517498-68e12f8b-092d-47a7-ac92-9a85a3bb9e94.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 4 : 카프카에서 데이터 처리에 사용되는 큐, 토픽&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림과 같이 토픽은 카프카 내에서 여러개 생성할 수 있다. 토픽은 데이터베이스의 테이블 또는 파일시스템 폴더와 유사하다고 볼 수 있으며, 각 토픽은 ‘click_product_log’, ‘pay_product_log’등과 같은 이름을 가질 수 있다. 그렇기 때문에 해당 토픽이 하는 역할을 명확하게 표현해주는 이름을 붙여주면, 추후에 유지보수하는데 큰 도움이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517559-f91efd2b-8c6a-4271-9b1c-add89e7087a6.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 5 : 토픽의 파티션&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;토픽에는 파티션이라는 추가 단위가 존재한다. 프로듀서가 카프카로 데이터를 보내면, 해당 데이터는 설정된 토픽 내에 있는 특정 파티션으로 들어가게 된다. 앞에서 설명한 것 처럼 토픽은 큐 형태로 존재하며, 데이터는 큐 안에 순서대로 쌓이게 된다. 컨슈머가 원하는 데이터를 포함하는 토픽과 파티션으로부터 데이터를 순서대로 가져오며, 데이터를 다 읽고 나면 새로운 데이터가 들어올 때 까지 대기하게 된다.&lt;/p&gt;

&lt;p&gt;여기서 중요한 것은 &lt;u&gt;데이터를 가져온다고 해서 파티션 내부에 있는 데이터가 삭제되지는 않는다&lt;/u&gt;는 것이다. 왜 카프카는 데이터를 바로 지우지 않는 것일까? 이유는 새로운 컨슈머가 토픽의 이전 데이터를 호출할 수도 있기 때문이다. 단 무조건 가능한 것은 아니며, 컨슈머의 그룹이 달라야 하며 특정 설정값에 대한 요건(auto.offset.reset = earliest)이 만족되어야 한다. 이러한 특징을 통해 얻을 수 있는 장점이 무엇일까? 먼저 위에서 설명한 것 처럼 서버에 갑작스런 이슈가 발생하였을 경우, 장애가 발생한 시점부터의 데이터를 복구하여 고가용성을 보장받을 수 있다. 또한 같은 데이터를 여러개의 서로 다른 플랫폼(예를 들어 한 쪽에서는 엘라스틱서치에서 처리를, 또 다른곳에서는 하둡에 데이터를 저장하고자 할 때)에 적재 할 수도 있다.&lt;/p&gt;

&lt;p&gt;파티션 내의 데이터는 옵션에 따라 삭제되는 시점을 정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;log.retention.ms : 최대 record(데이터) 보존 시간&lt;/li&gt;
  &lt;li&gt;log.retention.byte : 최대 record(데이터) 보존 크기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 그림처럼 파티션이 2개 이상인 경우, 데이터는 어느 파티션으로 들어가게될까? 데이터마다 키가 존재하고, 이를 기반으로 다양한 옵션을 설정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;키가 null, 기본 파티션 사용 : 라운드 로빈(round robin) 기준으로 파티션에 할당&lt;/li&gt;
  &lt;li&gt;키가 존재, 기본 파티션 사용 : 키의 해시값을 이름으로 갖는 특정 파티션에 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 파티션은 마음대로 늘일 수 있을까? 늘이는 것은 언제든지 가능하지만 반대로 줄이는 것은 불가능하다. 그렇기 때문에 파티션을 추가할 때에는 꼭 신중하게 진행하는 것이 좋다. 그렇다면 파티션은 언제 늘이는 것이 좋을까? 파티션을 늘이면 이를 구독할 수 있는 컨슈머의 갯수를 늘일 수 있기 때문에, 데이터 처리를 여러 컨슈머로 분산시킬 수 있다. 그렇기 때문에 컨슈머의 양이 증가되어야 하는 시점에 파티션을 동일하게 늘여주는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;고가용성을-위한-replication복제&quot;&gt;고가용성을 위한 Replication(복제)&lt;/h2&gt;

&lt;p&gt;카프카에는 브로커(broker)라는 개념이 존재하는데, 브로커는 카프카가 설치되어 있는 서버 단위를 의미하며 일반적으로 하나의 카프카 시스템에는 최소 3개의 브로커를 구성하는 것을 권장한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;브로커는 크게 메시지 브로커와 이벤트 브로커로 구분할 수 있는데, 카프카에서 사용하는 브로커는 이벤트 브로커이다. 둘 간의 차이는 수집된 데이터의 즉각적인 삭제 여부이다. 메시지 브로커는 데이터를 보내고 처리하고 삭제하지만, 이벤트 브로커는 서비스에서 나온 이벤트를 큐에 저장해서 발생한 이벤트를 보관한다. 이를 통해 장애가 발생하더라도 해당 이벤트를 복구해서 다시 확인할 수 있거나, 많은 양의 실시간 스트림 데이터를 효과적으로 처리할 수 있는 등의 장점을 얻을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;각 토픽마다 특정 파티션은 브로커에 하나씩 구성할 수 있으며, 이러한 파티션을 브로커마다 복제하는 것을 Replication이라고 부른다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Replication 1개인 토픽 -&amp;gt; n개의 브로커 중 1대에 토픽이 저장됨&lt;/li&gt;
  &lt;li&gt;Replication 3개인 토픽 -&amp;gt; n개의 브로커 중 3대에 토픽이 저장됨.
    &lt;ul&gt;
      &lt;li&gt;단 위에서 언급한 것 처럼, 각 파티션은 브로커 마다 한개씩만 존재해야 하기 때문에 브로커의 수보다 파티션이 많아서는 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517629-d3b2010d-ef03-4fc8-ac67-f934bad93890.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 6 : 고가용성을 위한 ISR(In Sync Replica) 구조&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 하나의 파티션이 총 3개로 복제되었다면 각 파티션은 뭐라고 부를 수 있을까? 원본은 leader, 복제된 각 파티션은 follower라고 부른다. 즉 3개의 파티션중 원본 1개는 leader, 복제로부터 만들어진 2개는 follower가 된다. 그리고 이 모든 파티션을 합쳐서 ISR(In Sync Replica)라고 부른다(위 그림에서 노란색으로 칠해진 부분).&lt;/p&gt;

&lt;p&gt;실제로 카프카 프로듀서가 데이터를 보내면, 이를 leader 파티션이 받아서 follower 파티션에게 전달하게 된다. 이 과정에서 ack라는 옵션을 사용하여 데이터 전달 과정에서 성능 또는 안정성 중 하나에 대한 중요도를 더욱 높일 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ack&lt;/th&gt;
      &lt;th&gt;특징&lt;/th&gt;
      &lt;th&gt;속도&lt;/th&gt;
      &lt;th&gt;데이터 유실 가능성&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;- leader에게 정상적으로 데이터가 전송되었는지 응답값 못받음&lt;br /&gt;- follower에게 데이터가 제대로 복제되었는지 응답값 못받음&lt;/td&gt;
      &lt;td&gt;속도가 매우 빠름&lt;/td&gt;
      &lt;td&gt;데이터 유실 가능성 제일 높음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;- leader에게 정상적으로 데이터가 전송되었는지 응답값 받음&lt;br /&gt;- follower에게 데이터가 제대로 복제되었는지 응답값 못받음&lt;/td&gt;
      &lt;td&gt;일반적인 속도&lt;/td&gt;
      &lt;td&gt;Leader 파티션이 데이터를 받은 이후 브로커에 장애가 발생할 경우, 나머지 follower에 데이터가 전송되지 못해 데이터 유실가능성이 존재&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;all&lt;/td&gt;
      &lt;td&gt;- leader에게 정상적으로 데이터가 전송되었는지 응답값 받음&lt;br /&gt;- follower에게 데이터가 제대로 복제되었는지 응답값 받음&lt;/td&gt;
      &lt;td&gt;가장 느린 속도&lt;/td&gt;
      &lt;td&gt;데이터의 정상적인 복제를 모두 확인하여 유실 가능성이 거의 없음&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그렇다면 replication 갯수가 많으면 무조건 좋은것일까? 복제해야 하는 서버가 늘어난다는 것은 리소스의 증가 또한 비례한다는 것을 의미한다. 그렇기 때문에 카프카에 들어오는 데이터양과 저장시간(retention time)을 기준으로 총 복제 수를 정하는 것이 좋다. 일반적으로 3개 이상의 브로커를 사용할 때 replication을 3으로 두는 것을 권장한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로듀서의-partitioner란&quot;&gt;프로듀서의 Partitioner란?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209518144-06a6f576-a118-49f3-b9f8-dc803ea95ea3.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 7 : 프로듀서에서 생성한 데이터의 파티션 위치를 결정하는 파티셔너&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;프로듀서의 파티셔너(Partitioner)는 레코드에 포함되어 있는 메시지 키 또는 메시지 값에 따라 해당 데이터를 토픽 내 어떠한 파티션으로 할당할지를 결정한다. 프로듀서 사용시점에 파티션을 특정하지 않았을 경우, 기본적으로 UniformStickyPartitioner으로 설정이 된다. 이 때 메시지 키의 설정 여부에 따라 동작 방식이 달라지게 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메시지 키&lt;br /&gt;여부&lt;/th&gt;
      &lt;th&gt;동작 방식&lt;/th&gt;
      &lt;th&gt;특징&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;- 파티셔너는 메시지 키를 이용하여 해시값 생성&lt;br /&gt;- 해시값 기준으로 파티션 결정&lt;/td&gt;
      &lt;td&gt;순차적인 데이터 처리 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;- 라운드 로빈형태로 파티션 결정&lt;br /&gt;- 프로듀서가 배치 형태로 레코드를 최대한 많이 묶음화한 후, 이를 파티션으로 보냄&lt;/td&gt;
      &lt;td&gt;파티션마다 적절하게 레코드가 분배됨&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;결국 동일한 메시지 키는 동일한 해시값을 만들기 때문에, 항상 동일한 파티션에 데이터가 그룹화되어 할당되고 이를 통해 데이터를 할당된 순서대로 처리할 수 있게 된다. 예를 들어 날씨에 대한 로그를 분석하는 컨슈머의 경우 프로듀서가 메시지 키에 ‘서울’이라는 값을 넣게 되면, 해당 데이터가 동일한 파티션에만 순서대로 적재되기 때문에 컨슈머는 원활하게 데이터를 순서대로 처리할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;추가로 카프카에서는 사용자가 커스텀 파티셔너를 만들 수 있도록 Partitioner 인터페이스를 제공한다. 이를 이용하면 메시지 키, 메시지 값, 토픽 이름에 따라 파티션을 결정할 수 있는데, 예시로 VIP 고객의 데이터를 더 빠르게 처리하고 싶다면, 이러한 커스텀 파티셔너를 이용하여 처리할 컨슈머의 양을 고정적으로 증가시키는 방법을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;컨슈머-랙lag은-무엇이고-어떻게-확인할-수-있을까&quot;&gt;컨슈머 랙(Lag)은 무엇이고 어떻게 확인할 수 있을까?&lt;/h2&gt;

&lt;p&gt;컨슈머 랙은 프로듀서가 파티션에 데이터를 넣어주는 속도가 컨슈머가 파티션으로부터 데이터를 가져가는 속도보다 빠른 경우에 발생한다. 일반적으로 컨슈머에서 성능 저하가 생기거나 비정상적인 동작이 생기는 경우 발생할 수 있는데, &lt;u&gt;각 파티션 별로 프로듀서가 넣은 데이터의 오프셋과 컨슈머가 가져가는 데이터의 오프셋 사이의 차이&lt;/u&gt;라고 이해하면 된다. 
파티션 기준이기 때문에, &lt;u&gt;토픽 내에 존재하는 파티션의 수에 따라 컨슈머 랙 또한 여러 개 존재할 수 있다&lt;/u&gt;. 예를 들어 2개의 파티션과 1개의 컨슈머 그룹이 존재하는 경우, 발생 가능한 컨슈머 랙은 최대 2개가 된다. 이처럼 여러 개의 컨슈머 랙이 존재하는 경우, 이들 중 가장 높은 숫자의 랙은 records-lag-max로 부른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209518167-0daa77dd-cfe5-4f6e-83a5-9c7ecd444717.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 8 : 프로듀서와 컨슈머 사이의 데이터 처리량 차이에서 발생하는 컨슈머 랙&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 컨슈머 랙은 어떻게 모니터링할 수 있을까? 컨슈머 랙이 컨슈머를 통해 발생하기 때문에, 자연스럽게 컨슈머 단위로 이를 모니터링해야겠다는 생각이 들것이다. 하지만 이러한 방법은 컨슈머 상태에 매우 의존적이기 때문에, 굉장히 위험한 접근방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만약 컨슈머에 장애가 발생해서 더이상 동작하지 않게되면, 컨슈머에서는 발생하는 랙 정보를 더이상 보낼 수 없기 때문에 정보의 수집이 불가능해진다.&lt;/li&gt;
  &lt;li&gt;컨슈머가 추가로 개발될때마다 해당 컨슈머에서 컨슈머 랙을 수집하는 로직이 추가로 개발되어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 이유로 링크드인에서는 컨슈머 랙을 효과적으로 모니터링할 수 있는 별도의 어플리케이션인 &lt;a href=&quot;https://github.com/linkedin/Burrow&quot;&gt;Burrow&lt;/a&gt;를 제공한다. Burrow는 3가지 큰 특징을 가지고 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;여러개의 카프카 클러스터가 존재하더라도, 단일 Burrow 어플리케이션으로 모든 클러스터에서 발생하는 컨슈머 랙의 모니터링이 가능하다.&lt;/li&gt;
  &lt;li&gt;Sliding window를 통해 컨슈머의 상태를 ERROR, WARNING, OK와 같이 간단하게 확인할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;WARNING: 데이터양이 일시적으로 증가하여 컨슈머 오프셋이 증가되는 경우&lt;/li&gt;
      &lt;li&gt;ERROR: 데이터양이 계속해서 증가하지만 컨슈머에서 데이터를 더이상 수집하지 않는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP API를 제공하여 멀티플랫폼에서 Burrow 적용이 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.inflearn.com/course/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%9E%85%EB%AC%B8/dashboard&quot;&gt;아파치 카프카 for beginner - 데브원영&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://engineering.linkedin.com/blog/topic/kafka&quot;&gt;Kafka Ecosystem - LinkedIn&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%82%B0_%EC%84%9C%EB%B9%84%EC%8A%A4&quot;&gt;DDS(Data Distribution Service) - 위키백과&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90_%EB%AC%B8%EC%A0%9C&quot;&gt;프로듀서-컨슈머(Producer-Consumer) - 위키백과&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/AMQP&quot;&gt;AMQP - 위키백과&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.skby.net/amqp-advanced-message-queue-protocol/&quot;&gt;AMQP(Advanced Message Queue Protocol) - 도리의 디지털라이프&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/linkedin/Burrow&quot;&gt;Burrow - Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">이더리움에서의 재진입성(Reentrancy) 공격에 대한 이해</title><link href="http://localhost:4000/2022/10/26/blockchain-eth-reentrancy/" rel="alternate" type="text/html" title="이더리움에서의 재진입성(Reentrancy) 공격에 대한 이해" /><published>2022-10-26T00:00:00+09:00</published><updated>2022-10-26T00:00:00+09:00</updated><id>http://localhost:4000/2022/10/26/blockchain-eth-reentrancy</id><content type="html" xml:base="http://localhost:4000/2022/10/26/blockchain-eth-reentrancy/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;재진입성-공격이란&quot;&gt;재진입성 공격이란?&lt;/h2&gt;

&lt;p&gt;재진입이라는 용어는 ‘외부의 악의적인 컨트랙트가 취약한 컨트랙트의 함수를 호출하면서 실행경로가 그 안으로 재진입하는’ 방법이라고 표현한다. 사실 이렇게만 보면 어려운데, 이더리움과 스마트 컨트랙트의 특징을 먼저 살펴보면 좋을 것 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;이더리움은 ‘다른 사용자 주소로 이더를 전송’ 한다.&lt;/li&gt;
  &lt;li&gt;이더리움에서 스마트 컨트랙트는 다른 외부의 스마트 컨트랙트를 호출하고, 그 내부의 기능을 활용할 수 있다.&lt;/li&gt;
  &lt;li&gt;단순히 이더를 전송하거나 존재하지 않는 외부의 스마트 컨트랙트 내 기능을 호출하는 경우, 콜백을 포함한 다양한 대체 코드를 실행할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;재진입성 공격은 &lt;u&gt;컨트랙트가 알 수 없는 주소(스마트 컨트랙트)로 이더를 전송하는 경우&lt;/u&gt; 발생할 수 있다. 내부 fallback 함수에 악성코드를 심어놓은 스마트 컨트랙트로 이더를 전송하게 되면, 악의적인 코드가 실행되면서 발생하는 공격이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fallback 함수 : 이름이 없는 함수로, 스마트 컨트랙트 내에 존재하지 않는 함수를 호출하면 대신 호출되는 함수.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가장 유명한 사례로는 &lt;a href=&quot;https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/&quot;&gt;The DAO 해킹&lt;/a&gt;이 있다. 대략 1억 5천만 달러 이상의 잔액을 보유하고 있던 컨트랙트를 공격하였으며, 이 공격을 통해 이더리움에서 이더리움 클래식이 하드포크 되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;여기 이더를 보관 및 인출해주는 은행 컨트랙트(Bank)와 이를 공격하기 위한 컨트랙트(Attack)가 있다고 하자.&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 은행 컨트랙트
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;payable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Attack&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bankAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_bankAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attackBank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;payable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;ether&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;ether&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;payable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;ether&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;ether&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;공격자(Attacker)가 단일 트랜잭션만으로 Bank 컨트랙트에서 1이더만 남기고 모두 출금하는 과정을 그림으로 표현하면 아래와 같다. 단, Bank 컨트랙트에는 어느정도의 이더가 이미 존재하고 있다고 가정한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/wnjoon/post/6502c25e-0cd0-4d45-89f8-a8e6cbfce390/image.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;@그림 1: 공격자가 Attack 컨트랙트를 이용하여 Bank 컨트랙트를 공격&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;공격자가 Attack 컨트랙트의 attackBank 함수를 실행한다.&lt;/li&gt;
  &lt;li&gt;attackBank 함수가 Bank 컨트랙트의 deposit 함수를 호출하여 1 이더를 입금한다.&lt;/li&gt;
  &lt;li&gt;attackBank 함수가 Bank 컨트랙트의 withdraw 함수를 호출하여 1 이더를 인출한다.&lt;/li&gt;
  &lt;li&gt;Bank 컨트랙트의 withdraw 함수 내부에서 msg.sender(Attack 컨트랙트)에게 1 이더를 전송한다. Attack 컨트랙트의 fallback 함수가 이를 처리한다.&lt;/li&gt;
  &lt;li&gt;Attack 컨트랙트의 fallback 함수 내부에서 다시 Bank 컨트랙트의 withdraw를 호출한다. Bank 컨트랙트의 잔액이 1 이더만 남을때까지 이 과정은 계속 반복된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;어떻게-막을-수-있을까&quot;&gt;어떻게 막을 수 있을까?&lt;/h2&gt;

&lt;p&gt;재진입 공격을 막기 위한 방법은 현재까지 3가지 정도 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;1-transfer-함수-사용&quot;&gt;1. transfer 함수 사용&lt;/h3&gt;

&lt;p&gt;transfer 함수는 외부 컨트랙트 호출에 대해 총 2300개의 가스만 사용할 수 있도록 되어있다. 이는 이더 전송을 위한 단일 트랜잭션은 가능하나, 외부의 다른 컨트랙트를 호출하기에는 적은 양이다.&lt;/p&gt;

&lt;h3 id=&quot;2-엄격한-상태-변수-변경&quot;&gt;2. 엄격한 상태 변수 변경&lt;/h3&gt;

&lt;p&gt;컨트랙트 또는 외부의 다른 컨트랙트에서의 호출을 통해 이더가 전송되기 전 상태변수를 변경하는 방식이다. 이를 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern&quot;&gt;체크 효과 상호작용 패턴(checks-effects-interactions pattern)&lt;/a&gt; 이라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Bank 컨트랙트 예시
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 아래 두 코드의 위치를 변경해서,
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 알 수 없는 주소로의 외부 호출을 수행하는 코드를 
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 지역함수 또는 코드 실행 부분의 
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 가장 마지막에 진행해야 한다.
&lt;/span&gt;        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-뮤텍스mutex-사용&quot;&gt;3. 뮤텍스(mutex) 사용&lt;/h3&gt;

&lt;p&gt;코드가 실행되는 동안에는 컨트랙트를 잠궈주는 상태 변수를 추가하여 재진입을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;개선된-코드&quot;&gt;개선된 코드&lt;/h2&gt;

&lt;p&gt;개선된 Bank 컨트랙트의 코드를 살펴보면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 개선된 은행 컨트랙트
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 1. 뮤텍스 추가
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;payable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 2. 뮤텍스 확인
&lt;/span&gt;        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        
        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 3. 상태 변수 우선 변경
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 4. 외부 호출 이전에 뮤텍스 설정
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 5. call 대신 transfer 사용
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 6. 외부 호출 이후 뮤텍스 해제
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/proofer-tech/%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8-%EB%B3%B4%EC%95%88-%EC%9D%B4%EC%8A%88-1-re-entrancy-%EC%9E%AC%EC%A7%84%EC%9E%85%EC%84%B1-7d4caf24803c&quot;&gt;스마트 컨트랙트 보안::Re-entrancy - PROOFER&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://brunch.co.kr/@ashhan/26&quot;&gt;The DAO 해킹 그리고 사망 - 브런치&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/&quot;&gt;Analysis of the DAO exploit - Hacking,Distributed&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry></feed>