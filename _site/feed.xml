<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-06-09T08:04:45+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">월리의 탐구생활</title><subtitle>A (nearly) no-CSS, fast, minimalist Jekyll theme.
</subtitle><author><name>Wonjoon</name></author><entry><title type="html">인터페이스 기반 설계의 중요성과 go언어를 이용한 구현 방법</title><link href="http://localhost:4000/2023/12/02/go-interface-architecture/" rel="alternate" type="text/html" title="인터페이스 기반 설계의 중요성과 go언어를 이용한 구현 방법" /><published>2023-12-02T00:00:00+09:00</published><updated>2023-12-02T00:00:00+09:00</updated><id>http://localhost:4000/2023/12/02/go-interface-architecture</id><content type="html" xml:base="http://localhost:4000/2023/12/02/go-interface-architecture/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;왜-우리는-인터페이스-기반으로-설계해야-할까&quot;&gt;왜 우리는 인터페이스 기반으로 설계해야 할까?&lt;/h2&gt;

&lt;p&gt;우리가 사용하고 있는 여러 서비스들을 포함한 일반적인 프로그램은 다양한 모듈로 구성되어 있다. 그리고 이러한 &lt;u&gt;모듈간의 유연한 연결&lt;/u&gt;을 위하여 인터페이스 기반의 설계를 권장한다.&lt;/p&gt;

&lt;p&gt;넷플릭스를 예로 들어보자. 넷플릭스라는 하나의 서비스안에는 비디오 스트리밍 뿐만 아니라 회원관리, 구독권 결재, 추천, 광고 등 수많은 세부 서비스들이 존재한다.&lt;/p&gt;

&lt;p&gt;그리고 당연히, 이 수많은 서비스들을 개발하기 위한 수많은 팀들이 존재한다. 심지어 소규모의 스타트업에서도 (일반적으로는) 각 기능(모듈)을 개발하기 위한 팀, 아니 적어도 사람이 별도로 구성된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;비록 아닌 곳들 또한 많이 있지만, 오늘 하고싶은 이야기의 주제와는 조금 벗어나기 때문에 넘어간다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다시 돌아와서 결국 수많은 기능들이 개발됨으로써 넷플릭스라는 하나의 서비스가 사용자에게 제공되는 것인데, 이 과정에서 수많은 팀들이 각자의 계획과 일정에 맞게 개발을 진행하기 때문에 의사소통과 협업에 문제가 발생하기 마련이다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위한 가장 좋은 방법이 인터페이스 기반으로 설계하고 개발하는 것이다. 간단하게 예시로 표현해보면 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;회원관리를 개발하는 A팀과 결제시스템을 개발하는 B팀이 있다. A팀에서 개발하는 기능 중 회원권 구매 기능이 있고, 이 기능은 B팀에서 개발중인 PG 연동 기능을 포함해야 한다.&lt;/li&gt;
  &lt;li&gt;B팀에서 개발중인 다른 기능들이 있기 때문에, PG 연동 기능을 바로 개발하기 어렵다. 그렇다고 A팀은 B팀의 업무가 끝날때까지 기다리고만 있을수는 없다.&lt;/li&gt;
  &lt;li&gt;B팀은 A팀에게 인터페이스 형태의 PG 연동 기능을 제공한다. 실제 동작하는 부분은 개발하지 않았지만 어떤 형태로 만들어질지에 대한 추상적인 형태는 제공할 수 있다.&lt;/li&gt;
  &lt;li&gt;A팀은 B팀으로부터 제공받은 인터페이스를 기반으로 Mock 기반의 구현체를 만들고, 이를 이용하여 회원권 구매 기능 개발을 진행한다.&lt;/li&gt;
  &lt;li&gt;추후 B팀에서 PG 연동 기능 개발이 완료되면, 기존의 Mock 기반 구현체를 실제 동작이 포함된 구현체로 교체한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mock : 실제 구현체와 통신하지 않고 얻을 수 있는 가짜 또는 샘플데이터&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 인터페이스 기반으로 설계하고 개발하면 &lt;u&gt;각 모듈간 의존성을 최소화시키고 독립적인 개발이 가능&lt;/u&gt;하다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인터페이스-기반-설계의-어려움&quot;&gt;인터페이스 기반 설계의 어려움&lt;/h2&gt;

&lt;p&gt;하지만 인터페이스 기반의 설계는 쉽지 않다. 가장 큰 이유로 인터페이스는 결국 &lt;u&gt;명확한 업무 설계&lt;/u&gt;를 기반으로 만들어지기 때문이다. 대부분의 개발자의 경우 머리보다 손이 먼저나가는 경우가 많은데, 이는 업무에 대한 명확한 분석이 먼저가 아니라 개발 과정에서 업무의 분석이 이루어지기 마련이다.&lt;/p&gt;

&lt;p&gt;이렇게 되면, 위에서 설명한 A팀과 B팀의 예시로 볼 때, A팀이 B팀에서 제공받은 인터페이스를 기반으로 개발한 내용들이 향후에 변경될 요지가 존재한다는 것이고 이는 인터페이스 기반의 설계와 개발로부터 얻을 수 있는 장점을 완전히 벗어나게 된다. 그러므로 실제 개발을 시작하는 시간은 좀 늦어질지라도, 업무에 대한 많은 고민과 분석을 통해 인터페이스를 먼저 설계하고 이를 기반으로 구현체를 개발하는 것이 무엇보다 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;go언어를-이용한-인터페이스-설계&quot;&gt;Go언어를 이용한 인터페이스 설계&lt;/h2&gt;

&lt;p&gt;Go언어는 다른 언어와 비교하여 적극적으로 인터페이스 형태의 설계를 권장하고 있고, 실제로 인터페이스 방식으로 설계하기가 매우 편리하다. 별도의 인터페이스를 위한 파일을 만들 필요도 없으며, 해당 인터페이스를 사용하겠다는 명시적인 선언도 필요없다. 단지 인터페이스의 모든 기능을 모듈 내에 포함시키면 된다.&lt;/p&gt;

&lt;p&gt;Go언어에서 인터페이스를 설계할 경우 권장하는 사항이 하나 있는데, 인터페이스 이름을 동작을 수행하는 객체 형태로 짓는 것이다. 예를 들어 어떠한 결과를 출력하기 위한 인터페이스의 경우 Printer, 결과를 파일로 저장하는 경우 Writer와 같이 뒤에 -er 접미사를 붙여서 작성하는 것을 권장한다.&lt;/p&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;

&lt;p&gt;서명된 이더리움 트랜잭션을 네트워크에 전송하는 인터페이스를 만들어보자.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SendTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이더리움으로 트랜잭션을 전송하기 위한 두가지 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이더리움 네트워크로 전송된 트랜잭션이 블록에 마이닝될때까지 기다렸다가 결과를 반환해주는 동기 처리방식&lt;/li&gt;
  &lt;li&gt;이더리움 네트워크로 트랜잭션을 전송하고 결과는 반환받지 않는 비동기 처리방식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이더리움 네트워크로 트랜잭션을 전송하는 것은 동일하기 때문에, 위에서 선언한 Sender 인터페이스를 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TxManager&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// TxManager라는 구현체가 Sender 인터페이스를 사용할 것이라고 선언했다. &lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Sender 인터페이스를 가진 구현체를 만든다.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxManager&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;동기 처리 방식을 제공하는 모듈과 비동기 처리 방식을 제공하는 모듈은 각각 아래와 같다. 둘다 Sender 인터페이스에 포함된 기능을 포함하고 있다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// SyncTxManager&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SyncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewSyncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SyncTxManager&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SyncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SendTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// AsyncTxManager&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsyncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewAsyncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsyncTxManager&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsyncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SendTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인터페이스를 실제 구현체에 주입할 때는 아래와 같이 진행하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;syncTxManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewSyncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;asyncTxManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewAsyncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;c&quot;&gt;// 동기 방식&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;txm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;c&quot;&gt;// 비동기 방식&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;txm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asyncTxManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://appmaster.io/blog/interface-implementation-go&quot;&gt;Interface in Go - AppMaster&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">가스비 절감의 효과를 갖는 솔리디티의 custom error</title><link href="http://localhost:4000/2023/08/22/blockchain-custom-error-solidity/" rel="alternate" type="text/html" title="가스비 절감의 효과를 갖는 솔리디티의 custom error" /><published>2023-08-22T00:00:00+09:00</published><updated>2023-08-22T00:00:00+09:00</updated><id>http://localhost:4000/2023/08/22/blockchain-custom-error-solidity</id><content type="html" xml:base="http://localhost:4000/2023/08/22/blockchain-custom-error-solidity/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커스텀-에러&quot;&gt;커스텀 에러&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ethereum/solidity/releases/tag/v0.8.4&quot;&gt;솔리디티 v0.8.4&lt;/a&gt;에서 소개된 방법으로, 기존의 에러 표현 방식에 비해 가스비를 줄이면서 에러 발생의 원인을 설명할 수 있다.&lt;br /&gt;
아래는 기존의 방식과 커스텀 에러 방식 각각을 예시로 표현한 내용이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Before
revert(&quot;Insufficient funds.&quot;); // 사용 (선언 없음)

# Custom errors
error Unauthorized(); // 선언
...
revert Unauthorized(); // 사용
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;가스비는 스마트 컨트랙트의 배포(deploy)에 영향을 주는데, 이 외에도 기존의 방식은 에러에 대한 정보를 동적으로 관리하기 어렵다는 단점이 있었다.&lt;br /&gt;
커스텀 에러는 ‘error’ 구문을 사용한다. 그리고 외부(인터페이스 또는 라이브러리)에서 선언한 에러를 스마트 컨트랙트에 불러와서 사용할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized(); // Custom error

contract VendingMachine {
    address payable owner = payable(msg.sender);

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();  // Using custom error with revert statement

        owner.transfer(address(this).balance);
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/contracts.html?color=dark#events&quot;&gt;이벤트(event)&lt;/a&gt;와 구문이 비슷한 것을 볼 수 있는데, 차이점은 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/control-structures.html?color=dark#revert-statement&quot;&gt;revert 구문&lt;/a&gt;과 같이 사용해야 한다는 것이다. revert를 사용하면 현재까지 진행되던 상태 변환 프로세스가 모두 중단되고 에러 메시지를 호출자에게 전달한다. &lt;a href=&quot;https://github.com/ethereum/solidity/issues/11278&quot;&gt;require 구문의 사용은 현재 포스팅 시점(2023.08.23)에는 제공되지 않고 있는데&lt;/a&gt;, 아래의 예시를 보면 이해가 쉬울 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This Error message with require statement 
require(condition, &quot;error message&quot;)

# Should be translated to
if (!condition) revert CustomError()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;파라미터를-추가한-커스텀-에러&quot;&gt;파라미터를 추가한 커스텀 에러&lt;/h2&gt;

&lt;p&gt;커스텀 에러는 파라미터를 추가할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

/// Insufficient balance for transfer. Needed `required` but only
/// `available` available.
/// @param available balance available.
/// @param required requested amount to transfer.
error InsufficientBalance(uint256 available, uint256 required);

contract TestToken {
    mapping(address =&amp;gt; uint) balance;
    function transfer(address to, uint256 amount) public {
        if (amount &amp;gt; balance[msg.sender])
            // Error call using named parameters. Equivalent to
            // revert InsufficientBalance(balance[msg.sender], amount);
            revert InsufficientBalance({
                available: balance[msg.sender],
                required: amount
            });
        balance[msg.sender] -= amount;
        balance[to] += amount;
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면 커스텀 에러를 아래와 같이 선언하고,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error InsufficientBalance(uint256 available, uint256 required);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;revert InsufficientBalance({
    available: balance[msg.sender],
    required: amount
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용 시점의 에러 데이터는 abi.encodeWithSignature(“InsufficientBalance(uint256,uint256)”, balance[msg.sender], amount)로 ABI 인코딩된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;실제로-얼마나-스마트-컨트랙트-사이즈가-줄어드는가&quot;&gt;실제로 얼마나 스마트 컨트랙트 사이즈가 줄어드는가?&lt;/h2&gt;

&lt;p&gt;위에서 예시로 든 VendingMachine 스마트 컨트랙트 기준으로 커스텀 에러 사용 여부에 따른 사이즈를 비교해보았다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized(); // Custom error

contract VendingMachine {
    address payable owner = payable(msg.sender);

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();  // 커스텀 에러 사용 시
            revert(&quot;Insufficient funds.&quot;); // 커스텀 에러 미사용 시

        owner.transfer(address(this).balance);
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/IoBuilders/truffle-contract-size&quot;&gt;truffle-contract-size&lt;/a&gt;를 사용하여 각 상황별로 스마트 컨트랙트 사이즈를 계산한 결과는 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;커스텀 에러 사용 : 0.33 KiB&lt;/li&gt;
  &lt;li&gt;커스텀 에러 미사용 : 0.46 KiB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단순한 에러라 할지라도 대략 0.13 KiB 정도의 차이가 나는 것을 보면, 복잡한 로직이 들어간 스마트 컨트랙트 일수록 커스텀 에러의 적용이 꽤 유의미한 가치를 가져올 수 있을 것이라고 생각된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;좀더-깊이-커스텀-에러-들여다보기&quot;&gt;좀더 깊이 커스텀 에러 들여다보기&lt;/h2&gt;

&lt;p&gt;파라미터를 포함하지 않는 기본적인 커스텀 에러 ‘revert Unauthorized()’를 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/yul.html&quot;&gt;Yul 코드&lt;/a&gt;로 확인해보면 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Yul 코드는 다양한 백엔드에서 바이트코트 형태로 컴파일될 수 있도록 하는 중간 언어(intermediate language)를 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# revert Unauthorized();
let free_mem_ptr := mload(64)
mstore(free_mem_ptr, 0x82b4290000000000000000000000000000000000000000000000000000000000)
revert(free_mem_ptr, 4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 0x82b42900은 Unauthourized() 커스텀 에러의 selector를 의미한다. 그렇다면 커스텀 에러를 사용하지 않고 revert(“Unauthorized”)와 같이 에러 메시지를 그대로 사용하면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# revert(&quot;Unauthorized&quot;);
let free_mem_ptr := mload(64)
mstore(free_mem_ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
mstore(add(free_mem_ptr, 4), 32)
mstore(add(free_mem_ptr, 36), 12)
mstore(add(free_mem_ptr, 68), &quot;Unauthorized&quot;)
revert(free_mem_ptr, 100)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;0x08c379a0 값은 Error(에러메시지 문자열)의 selector를 의미한다. 단순히 코드만 봐도 커스텀 에러를 사용할 때가 더 적은 가스비를 소모하는 것을 볼 수 있다. 런타임 시점의 가스비는 revert 조건을 만족하는 경우에 대해서만 연관이 있다는 것을 기억하자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커스텀-에러-확인하기&quot;&gt;커스텀 에러 확인하기&lt;/h2&gt;

&lt;p&gt;그렇다면 커스텀 에러는 어떻게 확인할 수 있을까? 가장 최근 버전의 ethers.js를 사용하면 커스텀 에러 메시지를 디코딩한 값을 확인할 수 있다.&lt;br /&gt;
아래 예시는 위의 InsufficientBalance 커스텀 에러를 확인하는 경우를 나타낸다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { ethers } from &apos;ethers&apos;

// As a workaround, we have a function with the
// same name and parameters as the error in the abi.
const abi = [
  &apos;function InsufficientBalance(uint256 available, uint256 required)&apos;,
]

const interface = new ethers.utils.Interface(abi)
const error_data =
  &apos;0xcf479181000000000000000000000000000000000000&apos; +
  &apos;0000000000000000000000000100000000000000000000&apos; +
  &apos;0000000000000000000000000000000000000100000000&apos;

const decoded = interface.decodeFunctionData(
  interface.functions[&apos;InsufficientBalance(uint256,uint256)&apos;],
  error_data
)
// Contents of decoded:
// [
//   BigNumber { _hex: &apos;0x0100&apos;, _isBigNumber: true },
//   BigNumber { _hex: &apos;0x0100000000&apos;, _isBigNumber: true },
//   available: BigNumber { _hex: &apos;0x0100&apos;, _isBigNumber: true },
//   required: BigNumber { _hex: &apos;0x0100000000&apos;, _isBigNumber: true }
// ]
console.log(
  &apos;Insufficient balance for transfer. &apos; +
    `Needed ${decoded.required.toString()} but only ` +
    `${decoded.available.toString()} available.`
)
// Insufficient balance for transfer. Needed 4294967296 but only 256 available.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;주의점&quot;&gt;주의점&lt;/h2&gt;

&lt;p&gt;스마트 컨트랙트를 컴파일해서 ABI 형태의 JSON 파일로 만드는 과정에서, 컴파일러는 해당 스마트 컨트랙트가 나타낼 수 있는(emit) 모든 에러를 해당 파일에 포함시킨다. 여기서 중요한 것은 이 과정에 &lt;u&gt;external call로 호출되는 에러 메시지들은 포함되지 않는다&lt;/u&gt;는 것이다. 
이러한 이유로 개발자들은 에러 마다 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/natspec-format.html?color=dark&quot;&gt;NatSpec&lt;/a&gt; 형식을 준수하는 설명을 달아놓기도 한다. NatSpec은 개발자와 사용자가 추가 비용없이 에러 메시지에 대해 서로 이해할 수 있도록 하는 좋은 방법 중 하나이다.&lt;/p&gt;

&lt;p&gt;어쨋든 에러 메시지의 출처를 추적할 수 없기 때문에, 에러 데이터는 신중하게 사용해야 한다. external call 호출 횟수가 계속 늘어날수록, 발생하는 에러 메시지가 어디서부터 온 것인지 추적하기 점점 어려워진다는 것을 의미한다. 게다가 실제 에러가 아님에도 불구하고 에러메시지(처럼 보이는 문구)를 호출하도록 악의적으로 스마트 컨트랙트를 작성할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://soliditylang.org/blog/2021/04/21/custom-errors/&quot;&gt;Custom Errors in Solidity - Soliditylang.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">스마트 컨트랙트의 사이즈를 줄이는 방법</title><link href="http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size/" rel="alternate" type="text/html" title="스마트 컨트랙트의 사이즈를 줄이는 방법" /><published>2023-08-21T00:00:00+09:00</published><updated>2023-08-21T00:00:00+09:00</updated><id>http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size</id><content type="html" xml:base="http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;eip-170&quot;&gt;EIP-170&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-170&quot;&gt;EIP-170&lt;/a&gt;은 2016년 11월 22일에 발생한 하드포크 &lt;a href=&quot;https://blog.ethereum.org/2016/11/18/hard-fork-no-4-spurious-dragon&quot;&gt;‘Suprious Dragon’&lt;/a&gt; 시기에 공개되었으며, DoS(Denial of Service) 공격으로부터 이더리움 네트워크를 보호하기 위해 스마트 컨트랙트의 사이즈를 24,576kb로 제한하는 규칙을 제안한 내용이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If block.number &amp;gt;= FORK_BLKNUM, then if contract creation initialization returns data with length of more than MAX_CODE_SIZE bytes, contract creation fails with an out of gas error.

- MAX_CODE_SIZE: 0x6000 (2**14 + 2**13)
- FORK_BLKNUM: 2,675,000
- CHAIN_ID: 1 (Mainnet)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이더리움 네트워크에서는 잠재적으로 최소 2번의 O(n) 만큼 가스가 사용될 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;디스크에서 읽어온 스마트 컨트랙트에 대한 코드를 VM 환경에서 실행하기 위해 전처리하는 과정에서 O(n)&lt;/li&gt;
  &lt;li&gt;블록의 유효성 증명을 위해 데이터를 머클 증명에 추가하는 과정의 O(n)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이를 이더리움에서는 2차 취약점(Quadratic Vulnerability) 이라고 언급하는데, 결국 스마트 컨트랙트 자체의 크기로 인하여 트랜잭션 처리 성능에 영향을 주는 경우가 발생하게 된다.&lt;br /&gt;
그리고 꼭 DoS가 아니더라도 굉장히 간단한 기능만을 사용하려는 사용자의 경우 단순히 &lt;u&gt;스마트 컨트랙트가 길다&lt;/u&gt;는 이유만으로 많은 가스비와 시간을 소비해야 할 수도 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스마트-컨트랙트의-사이즈를-확인하는-방법&quot;&gt;스마트 컨트랙트의 사이즈를 확인하는 방법&lt;/h2&gt;

&lt;p&gt;스마트 컨트랙트 바이트코드의 크기를 확인하려면 &lt;a href=&quot;https://github.com/IoBuilders/truffle-contract-size&quot;&gt;truffle-contract-size&lt;/a&gt;를 사용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;단계별로-스마트-컨트랙트의-사이즈를-줄이는-방법&quot;&gt;단계별로 스마트 컨트랙트의 사이즈를 줄이는 방법&lt;/h2&gt;

&lt;p&gt;본문에서는 3단계로 스마트 컨트랙트의 사이즈를 줄이는 방법을 제시한다.&lt;br /&gt;
1단계가 가장 큰 효과를 줄 수 있는(Big impact) 방법이고, 단계가 올라갈수록 소소하게 효과를 줄 수 있는 방법으로 보면 된다.&lt;/p&gt;

&lt;h3 id=&quot;1-big-impact&quot;&gt;1. Big impact&lt;/h3&gt;

&lt;h4 id=&quot;11-스마트-컨트랙트-분리하기&quot;&gt;1.1. 스마트 컨트랙트 분리하기&lt;/h4&gt;

&lt;p&gt;스마트 컨트랙트 분리의 첫걸음은 좋은 구조(Good Architecture)로부터 시작한다. 스마트 컨트랙트가 작아질수록 가독성은 높아진다.&lt;/p&gt;

&lt;p&gt;스마트 컨트랙트 분리 시 생각해보아야 하는 점들은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함께 동작하는 기능들은 모아두는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;상태(state)값을 확인 또는 변경하지 않는 기능은 분리해도 좋다.&lt;/li&gt;
  &lt;li&gt;스토리지(storage)에 접근하지 않는다면 분리해도 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;12-라이브러리-사용하기&quot;&gt;1.2. 라이브러리 사용하기&lt;/h4&gt;

&lt;p&gt;라이브러리를 사용하면 효율적으로 특정 기능들을 별도의 스마트 컨트랙트로 분리할 수 있다. 라이브러리는 다른 스마트 컨트랙트에서 컴파일 과정에 추가되어 사용되기 때문에 internal로 선언되어서는 안된다.&lt;br /&gt;
라이브러리를 사용할 때에는 &lt;a href=&quot;https://solidity.readthedocs.io/en/v0.6.10/contracts.html#using-for&quot;&gt;using for&lt;/a&gt;을 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity &amp;gt;=0.6.0 &amp;lt;0.7.0;

struct Data { mapping(uint =&amp;gt; bool) flags; }

library Set {
    function insert(Data storage self, uint value)
        public
        returns (bool)
    {
        if (self.flags[value])
            return false; // already there
        self.flags[value] = true;
        return true;
    }
    ...
}

contract C {
    using Set for Data; // this is the crucial change
    Data knownValues;

    function register(uint value) public {
        require(knownValues.insert(value));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약 public 함수로 외부에서 직접 사용할 수 있도록 선언하고자 한다면, 별도의 스마트 컨트랙트로 배포하는 것이 옳다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;13-프록시-적용하기&quot;&gt;1.3. 프록시 적용하기&lt;/h4&gt;

&lt;p&gt;본문에서는 프록시를 가장 진보한(advanced) 방법이라고 표현하는데, 다른 스마트 컨트랙트의 기능을 통해 본래 스마트 컨트랙트의 상태를 변경하는 delegatecall 호출 방식을 사용한다.&lt;br /&gt;
프록시 방법의 대표적인 예가 &lt;a href=&quot;https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2&quot;&gt;upgradable한 스마트 컨트랙트&lt;/a&gt;인데, 단점은 그만큼 코드가 복잡해진다는 것이다.&lt;br /&gt;
만약 단순히 스마트 컨트랙트의 사이즈만 줄이기 위해서는 사용을 권장하지 않는다고 한다.&lt;/p&gt;

&lt;h3 id=&quot;2-medium-impact&quot;&gt;2. Medium impact&lt;/h3&gt;

&lt;h4 id=&quot;21-함수-개수-줄이기&quot;&gt;2.1. 함수 개수 줄이기&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;External : 편리한 사용성을 위해 우리는 view 함수를 자주 작성하곤 한다. 스마트 컨트랙트 제한 크기 이하라면 전혀 상관이 없다만, 아니라면 가장 필요로하는 한개만 남긴다는 생각으로 함수를 줄이는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;Internal : 단발성으로 호출되는 internal 또는 private 함수를 줄이고, 이를 사용하는 함수 내부에 인라인 코드로 작성하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;22-새로운-변수-선언-줄이기&quot;&gt;2.2. 새로운 변수 선언 줄이기&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Before
function get(uint id) returns (address,address) {
    MyStruct memory myStruct = myStructs[id];
    return (myStruct.addr1, myStruct.addr2);
}

# After
function get(uint id) returns (address,address) {
    return (myStructs[id].addr1, myStructs[id].addr2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;별도의 변수를 선언하지 않았을 때, 무려(?) 0.28kb의 크기를 감소시킬 수 있다. 꼭 별도로 선언해야 하는 변수가 아니라면, 선언되어 있는 변수를 재활용하자.&lt;/p&gt;

&lt;h4 id=&quot;23-짧은-에러메시지&quot;&gt;2.3. 짧은 에러메시지&lt;/h4&gt;

&lt;p&gt;에러메시지의 길이 또한 스마트 컨트랙트의 크기를 변화시키는 요인이 된다. 에러 상황을 나타낼 때 메시지 보다는 코드를 사용할 것을 권장한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Before
require(msg.sender == owner, &quot;Only the owner of this contract can call this function&quot;);

# After
require(msg.sender == owner, &quot;OW1&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;24-커스텀-에러-사용하기&quot;&gt;2.4. 커스텀 에러 사용하기&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://soliditylang.org/blog/2021/04/21/custom-errors/&quot;&gt;솔리디티 0.8.4에서 소개된 커스텀 에러 방식&lt;/a&gt;은 스마트 컨트랙트의 사이즈를 줄일 수 있는 꽤나 효과적인 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error Unauthorized();

if (msg.sender != owner) {
    revert Unauthorized();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 방식이 커스텀 에러인데, 이처럼 선언하게 되면 해당 에러가 selector 형식으로 ABI 인코딩된다. 커스텀 에러 안에서도 다양한 방식이 있는데, 추후 포스팅하겠다.&lt;/p&gt;

&lt;h4 id=&quot;25-optimizer-수정하기&quot;&gt;2.5. Optimizer 수정하기&lt;/h4&gt;

&lt;p&gt;기본값 200은 것은 함수가 200번 호출될 경우를 대비한 바이트코드의 최적화를 의미한다. 만약 값을 1로 한다면 단일 호출인 경우에 대한 바이트코드 최적화를 의미하게 되는데, 다른 의미로 배포(deployment)를 나타내게 된다.&lt;br /&gt;
Optimizer에 사용되는 값이 증가할수록 가스비가 증가하므로, 배포된 이후 해당 컨트랙트를 직접 호출하는 경우가 없다면 값을 최소화하여 적용하는 방안을 고려하는 것을 권장한다.&lt;/p&gt;

&lt;h3 id=&quot;3-small-impact&quot;&gt;3. Small impact&lt;/h3&gt;

&lt;h4 id=&quot;31-함수-파라미터로-구조체-전달하지-않기&quot;&gt;3.1. 함수 파라미터로 구조체 전달하지 않기&lt;/h4&gt;

&lt;p&gt;ABIEncoderV2에서는 함수의 파라미터로 구조체를 전달할 수 있다. 편의성은 올라갈 수 있지만 스마트 컨트랙트의 사이즈는 증가한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Passing struct
function get(uint id) returns (address,address) {
    return _get(myStruct);
}

function _get(MyStruct memory myStruct) private view returns(address,address) {
    return (myStruct.addr1, myStruct.addr2);
}

# Passing variables
function get(uint id) returns(address,address) {
    return _get(myStructs[id].addr1, myStructs[id].addr2);
}

function _get(address addr1, address addr2) private view returns(address,address) {
    return (addr1, addr2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;구조체가 아닌 파라미터를 전달할 경우, 0.1kb의 크기가 차이난다.&lt;/p&gt;

&lt;h4 id=&quot;32-기능에-맞는-visibility-적용하기&quot;&gt;3.2. 기능에 맞는 visibility 적용하기&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;함수가 무조건 외부에서만 호출되는 경우 : public&lt;/li&gt;
  &lt;li&gt;함수가 다른 스마트 컨트랙트를 통해서만 호출되는 경우 : private 또는 internal&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;33-modifier-삭제하기&quot;&gt;3.3. Modifier 삭제하기&lt;/h4&gt;

&lt;p&gt;Modifier는 스마트 컨트랙트 사이즈에 큰 영향을 준다. 차라리 함수를 사용할 것을 권장한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Use modifier
modifier checkStuff() {}
function doSomething() checkStuff {}

# Use only functions
function checkStuff() private {}
function doSomething() { checkStuff(); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ethereum.org/en/developers/tutorials/downsizing-contracts-to-fight-the-contract-size-limit/&quot;&gt;DOWNSIZING CONTRACTS TO FIGHT THE CONTRACT SIZE LIMIT - ethereum.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">다자간 상대매매를 스마트 컨트랙트로 구성할 수 있을까?</title><link href="http://localhost:4000/2023/02/13/blockchain-mc-trade-contract/" rel="alternate" type="text/html" title="다자간 상대매매를 스마트 컨트랙트로 구성할 수 있을까?" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/2023/02/13/blockchain-mc-trade-contract</id><content type="html" xml:base="http://localhost:4000/2023/02/13/blockchain-mc-trade-contract/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;비상장주식과-거래-방법&quot;&gt;비상장주식과 거래 방법&lt;/h2&gt;

&lt;p&gt;비상장주식은 상장요건에 다소 미달하거나, 상장요건은 갖추었으나 회사의 사정에 의해 기업공개(IPO)를 하지 않아 거래소 및 코스닥 시장에 상장되지 않은 주식을 말한다 (출처: &lt;a href=&quot;https://www.myasset.com/myasset/static/trading/TR_1602000_P1T1.jsp&quot;&gt;유안타증권&lt;/a&gt;). 비상장주식의 거래는 크게 플랫폼, K-OTC(장외주식시장), 커뮤니티 게시판을 통해 이루어진다. 공식적으로는 플랫폼과 K-OTC를 증권계좌와 연계하여 계좌이체를 통해 거래하도록 되어있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218652134-4c3e6fba-e757-4878-ba06-e846382afd36.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 1 : 비상장주식 거래 방식 비교 - KVIC&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림을 보면, 비상장주식을 거래하는 방식은 크게 일대일 상대매매 또는 다대다(다자간) 상대매매로 구분된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일대일 상대매매&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;종목을 팔고자 하는 사람과 사고자 하는 사람이 일대일로 수량과 가격을 협의하여 거래&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;다자간 상대매매&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;종목에 대한 수량과 가격을 제시하고, 매도 호가와 매수 호가가 일치하는 경우 일치하는 수량 범위 내에서 자동으로 거래가 체결&lt;/li&gt;
  &lt;li&gt;동일 가격의 호가가 존재하면, 먼저 호가가 접수된 경우부터 진행&lt;/li&gt;
  &lt;li&gt;가격이 일치하지 않으면, 체결을 원하는 투자자가 상대호가를 보고 자신의 호가를 정정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 글에서 알 수 있듯이, 다자간 상대매매는 현재 증권 시스템에서 사용하고 있는 일반적인 거래 방식을 의미한다. 일대일 상대매매는 다른 표현으로 게시판 거래라고도 말하는데, 구매하고자 하는 종목을 발견하면, 구매 가능한 수량과 가격은 두 거래 당사자가 협의하고 정하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;다자간-상대매매&quot;&gt;다자간 상대매매&lt;/h2&gt;

&lt;p&gt;다자간 상대매매를 조금 더 이해하기 쉽게 그림으로 표현하면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218661781-0b4eec96-6dea-4980-a9f5-0da42df89a6c.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 2 : Alice와 Bob이 각각 월리전자 주식을 매도 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림에서 가운데는 월리전자라는 주식의 현재 매도 또는 매수 요청된 내역을 보여준다. Alice는 1주당 11000원의 가격으로 2주를, Bob은 1주당 10000원의 가격으로 3주를 매도신청한 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218661835-8a1e5571-cbe6-4ad4-acdc-5a9042e1db21.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 3 : Chris가 월리전자 주식을 매수 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Chris는 10000원으로 매도 신청 되어있는 월리전자의 주식 3주를 매수 신청한다. 그러면 10000원에 매도 요청되어 있던 상품은 모두 매수되어 없어진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218661894-0a9f5c02-b566-46e0-8f46-286c9f3ed040.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 4 : Alice가 월리전자 주식을 매수 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;10000원에 월리전자 주식을 매도한 Alice가 갑자기 오르기 시작하는 주식 가격을 보고 무지성 매수를 다시 하기 시작했다고 하자. 11000원에 매도 요청되어있는 주식 중 1개만 우선 구매하기로 가정했다고 하자. 그러면 위와 같이 11000원에 매도 요청되어있는 주식 중 Alice가 요청한 1주에 대한 매수만 이루어지며, 이전에 Bob이 매도요청한 2개 중 1개는 계속 남아있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218661962-2da07c07-6740-41f1-a776-35d695689df4.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 5 : Chris가 월리전자 주식을 매도 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Chris가 이익을 남기고자 10000원에 구매한 월리전자 주식 3주를 모두 12000원에 매도 요청한다. Alice는 또 다시 무지성 매수를 하기로 마음먹고 12000원에 총 4주를 매수하고자 한다. 하지만 12000원에 형성되어 있는 주식의 총 개수는 3개이므로, Alice는 우선 3주만 매수가 확정된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/218662003-0aad3d27-8b7c-4811-9a62-1d2d18a3669c.png&quot; alt=&quot;image&quot; /&gt; 
&lt;em&gt;@그림 6 : Bob이 월리전자 주식을 매도 신청&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이후 Bob이 본인이 11000원에 매도 신청했던 내역을 취소하고 12000원으로 정정하여 매도를 신청한다. 그러면 이전에 매수신청을 했던 Alice의 차례가 왔을 때, 해당 주식이 매수처리된다.&lt;/p&gt;

&lt;p&gt;위 그림들을 정리하여 다자간 상대매매 방식을 요약해보면 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;매도자와 매수자 간 원하는 가격이 일치하는 경우 거래가 발생한다.&lt;/li&gt;
  &lt;li&gt;해당 가격대에 형성된 매도 요청 수량보다 매수 요청 수량이 작거나 같으면, 매수 요청한 수량만큼 거래가 발생한다.&lt;/li&gt;
  &lt;li&gt;해당 가격대에 형성된 매도 요청 수량보다 매수 요청 수량이 많은 경우, 거래 가능한 매수 요청 수량만큼 매수가 발생하고 남은 개수는 추가적인 매도 요청 수량이 들어왔을 때 순차적으로 완료된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스마트-컨트랙트로-구현할-수-있을까&quot;&gt;스마트 컨트랙트로 구현할 수 있을까?&lt;/h2&gt;

&lt;p&gt;결론부터 말하면, 가능하다. 거래가 발생할 수 있는 중요도 순으로 정리해보면 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;거래하고자 하는 종목&lt;/li&gt;
  &lt;li&gt;매도 또는 매수하고자 하는 가격대&lt;/li&gt;
  &lt;li&gt;매도 또는 매수하고자 하는 주식량&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;중요한 것은, 스마트 컨트랙트로 구현하게 될 경우 토큰 증권화 된 주식과 이를 1:1로 거래하기 위한 별도의 유틸리티 토큰(이더리움의 경우 일반적으로 ERC-20으로 이루어진)이 필요하다. 만약 유틸리티 토큰의 종류가 K은행토큰, S은행토큰과 같이 여러개라고 가정하자. 그렇다면 1과 2 사이에 토큰 증권화 되어있는 주식을 거래할 수 있는 유틸리티 토큰의 종류가 포함되어야 할 것이다. 위의 중요도 순으로 맵을 구성하여 토큰 증권 별 형성된 거래 내역을 정리하면 될 것이다.&lt;/p&gt;

&lt;h3 id=&quot;1-순차적으로-거래되어야-하는-조건&quot;&gt;1. 순차적으로 거래되어야 하는 조건&lt;/h3&gt;

&lt;p&gt;하지만 가장 중요한 점이 있는데, 다자간 상대매매는 &lt;u&gt;순차적으로 거래&lt;/u&gt;된다는 것이다. 맵은 순서를 보장하지 않는다. 그렇다면 사용할 수 있는 방법은 리스트(LinkedList)일텐데, 아쉽게도 솔리디티에서는 이를 지원하지 않는다. 그렇다면? 별도로 만들어서 사용해야 할 것이다.&lt;/p&gt;

&lt;p&gt;하지만 솔리디티는 함수 내에서 진행되는 코드의 라인별로 gas를 측정한다. 퍼블릭이 아닌 프라이빗 환경에서 Quorum과 같은 플랫폼으로 이더리움을 구성하면 gas는 무시되기도 하지만, 그렇다고 해도 이더리움이 자체적으로 너무 많은 gas를 소모하는 경우에 프로그램을 정지시키기도 한다. 이러한 경우 수많은 거래 내역을 순차적으로 돌아다녀도 일치하는 거래 조건을 찾지 못하게되면 프로그램은 정지될 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;2-프로그램이-정지될-확률이-존재하는지-확인할-필요&quot;&gt;2. 프로그램이 정지될 확률이 존재하는지 확인할 필요&lt;/h3&gt;

&lt;p&gt;그렇기 때문에 루프가 어느정도까지 돌았을 때 프로그램이 정지할 수 있는지에 대한 선행 학습이 필요하다. 그 이후에 거래 전 미리 정지될 확률을 확인하고 거래를 진행하는 것이 좋다. 이를 위해서는 &lt;u&gt;해당 토큰증권을 특정 유틸리티 토큰으로 거래하기 위해 요청된 전체 내역의 수&lt;/u&gt;를 각각 가지고 있는 것이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;3-스마트-컨트랙트로-개발할-경우의-이점은&quot;&gt;3. 스마트 컨트랙트로 개발할 경우의 이점은?&lt;/h3&gt;

&lt;p&gt;우선, 토큰증권을 적용할 수 있는 플랫폼은 상식적으로 퍼블릭 환경에서 구성되지 않을 가능성이 높다. 이미 &lt;a href=&quot;https://www.fsc.go.kr/no010101/79386?srchCtgry=&amp;amp;curPage=&amp;amp;srchKey=&amp;amp;srchText=&amp;amp;srchBeginDt=&amp;amp;srchEndDt=&quot;&gt;금융위원회의 보도자료&lt;/a&gt;에서도 보면, 퍼블릭 형태의 블록체인이 아닌 여러 협의체가 함꼐(컨소시움 형태로) 노드를 구성하는 프라이빗 블록체인의 형태를 지향하고 있음을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 블록체인은 100% P2P 거래방식보다는, 별도의 인증된 어플리케이션에서 트랜잭션을 발생시키고, 이를 블록체인으로 2차 전달할 가능성이 높다. 굳이 빈번하게 발생하는 거래를 모두 블록체인에서 처리하기보단, 어플리케이션에서 이를 1차 처리하는 방법이 속도면에서는 더욱 유리할 것이다.&lt;/p&gt;

&lt;p&gt;하지만 현재 장외시장거래의 특성상 거래가 빈번하지 않음을 고려한다면, 스마트 컨트랙트로 다자간 상대매매를 진행하는 이점이 없다고만 할 수는 없다. 스마트 컨트랙트를 통해 배포된 프로그램은 임의로 조작하거나 재배포할 수 없기 때문에, 그 자체로도 부정적인 공격 또는 위변조로부터 보호받을 수 있다. 완전하진 않지만, 컨소시움으로 구성된 협의체 간은 공유되는 내용이기 때문에 어느 한 협의체에서 이를 임의대로 조작할 수도 없다.&lt;/p&gt;

&lt;p&gt;스마트 컨트랙트로 구성하는 것이 가장 불편해지는 상황은 바로 ‘속도(TPS)’이다. 단순히 트랜잭션 하나 당 처리되는 시간이 아니라, 시간 별로 처리(블록체인의 블록에 confirm되는)되는 시간이 더 빠르게 요구될 수록 블록체인은 사용성이 매우 낮아진다. 일반적인 증권거래에서는 아직 블록체인을 100% 활용할 수 없는 가장 큰 이유인데, 장외시장의 경우에는 거래량이 크지 않기 떄문에 블록체인만을 가지고 거래를 할 경우 어떠한 또 다른 이점이 있는지 확인해볼 수 있는 좋은 기회가 될 수 있을 것이라고 본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.fsc.go.kr/no010101/79386?srchCtgry=&amp;amp;curPage=&amp;amp;srchKey=&amp;amp;srchText=&amp;amp;srchBeginDt=&amp;amp;srchEndDt=&quot;&gt;보도자료:토큰 증권(Security Token) 발행·유통 규율체계 정비방안 - 금융위원회&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://news.mt.co.kr/mtview.php?no=2021102013545118652&quot;&gt;뜨겁지만 위험한 비상장주식 투자…거래 플랫폼별로 살펴보니 - 머니투데이&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kvicnewsletter.co.kr/page/view.php?idx=430&quot;&gt;안전한 비상장주식의 거래방법이 궁금하다면? - KVIC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;file:///Users/ssbc/Downloads/(%EC%B2%A8%EB%B6%802)K_OTC_Full+Version.pdf&quot;&gt;K-OTC의 이해 - 금융투자협회&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">아파치 카프카에 대해 매우 간략하게 알아보기</title><link href="http://localhost:4000/2022/12/23/tool-kafka/" rel="alternate" type="text/html" title="아파치 카프카에 대해 매우 간략하게 알아보기" /><published>2022-12-23T15:00:00+09:00</published><updated>2022-12-23T15:00:00+09:00</updated><id>http://localhost:4000/2022/12/23/tool-kafka</id><content type="html" xml:base="http://localhost:4000/2022/12/23/tool-kafka/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;카프카는-왜-주목받기-시작했는가&quot;&gt;카프카는 왜 주목받기 시작했는가?&lt;/h2&gt;

&lt;p&gt;데이터를 송신(Source)하는 어플리케이션과 수신(Target)하는 어플리케이션이 많아지면서 이를 위한 데이터 라인이 점점 복잡해지고 이를 통해 효과적인 데이터 처리 시스템이 필요해지기 시작했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517275-c2b158c6-01d8-47f1-b15f-a01e1201f57d.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 1 : 어플리케이션의 다양화로 인하여 복잡해진 데이터 라인&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같이 데이터 라인이 많아지면 아래와 같은 문제점이 발생할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;배포 단계가 복잡하고 어려워진다.&lt;/li&gt;
  &lt;li&gt;장애가 발생하면 원인 지점을 파악하는 것이 어려워진다.&lt;/li&gt;
  &lt;li&gt;어플리케이션마다 프로토콜이 다양해지면서, 처리 작업이 많이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209498379-9f169a13-7c74-4575-af84-71e5049b29d7.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;@그림 2 : 아파치 카프카는 다양한 앱을 하나의 플랫폼에서 간편하게 구독, 처리할 수 있도록 하는 플랫폼이다 - 출처 : &lt;a href=&quot;https://www.youtube.com/watch?v=waw0XXNX-uQ&amp;amp;t=87s&quot;&gt;데브원영&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;카프카는 &lt;a href=&quot;https://engineering.linkedin.com/teams/data/data-infrastructure/streams/kafka&quot;&gt;링크드인(LinkedIn)&lt;/a&gt;에서 만든 오픈소스로, 링크드인에 적용된 카프카에 대해 자세히 알고싶다면 &lt;a href=&quot;https://engineering.linkedin.com/blog/topic/kafka&quot;&gt;이곳(Kafka Ecosystem at LinkedIn)&lt;/a&gt;을 참조하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517445-4d67d84c-0da9-4d47-847b-85dd2e8c89c2.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 3 : 아파치 카프카를 통해 데이터를 송수신하는 구조&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;결국 카프카의 가장 큰 목적은 ‘송신 어플리케이션과 수신 어플리케이션 간 커플링을 최대한 약하게’하는 것인데, &lt;u&gt;송신 어플리케이션은 카프카에 데이터를 전송하기만 하면되고, 수신 어플리케이션이 카프카로부터 데이터를 가져오는 형태&lt;/u&gt;가 된다. 예를 들어 쇼핑몰이 있다고 가정하면, 송신 어플리케이션에서는 상품을 클릭하거나 구매할 때 로그를 발생하고 타겟 어플리케이션에서 이러한 로그를 적재하고 처리할 수 있도록 만든 후 카프카를 이용해 효과적으로 데이터 라인을 구성할 수 있게 된다. 여기서 송신 어플리케이션의 경우 json, tsv, avro 등 데이터 포멧에 대한 제한 없이 대부분을 처리할 수 있도록 지원한다.&lt;/p&gt;

&lt;p&gt;결국 카프카를 이용함으로써 얻는 장점은 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;고가용성(Fault Tolerant)을 지원하여, 갑작스런 서버 중단 또는 장애에도 데이터를 손실없이 복구할 수 있다.&lt;/li&gt;
  &lt;li&gt;낮은 지연(latency), 높은 처리량(throughput)을 통한 수많은 데이터의 빠른 처리가 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;AMQP(Advanced Message Queue Protocol)와 비교되기도 하는데, 자세한 내용은 포스팅하지 않고 하단에 참고자료로 첨부한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;토픽topic&quot;&gt;토픽(Topic)&lt;/h2&gt;

&lt;p&gt;카프카 내부에 존재하는 모든 데이터는 토픽이라는 큐 형태의 공간에 들어가게 된다. 카프카의 프로듀서가 데이터를 카프카에 송신하면 카프카의 컨슈머가 카프카로부터 원하는 데이터 형태에 맞는 토픽을 가져오는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517498-68e12f8b-092d-47a7-ac92-9a85a3bb9e94.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 4 : 카프카에서 데이터 처리에 사용되는 큐, 토픽&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림과 같이 토픽은 카프카 내에서 여러개 생성할 수 있다. 토픽은 데이터베이스의 테이블 또는 파일시스템 폴더와 유사하다고 볼 수 있으며, 각 토픽은 ‘click_product_log’, ‘pay_product_log’등과 같은 이름을 가질 수 있다. 그렇기 때문에 해당 토픽이 하는 역할을 명확하게 표현해주는 이름을 붙여주면, 추후에 유지보수하는데 큰 도움이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517559-f91efd2b-8c6a-4271-9b1c-add89e7087a6.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 5 : 토픽의 파티션&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;토픽에는 파티션이라는 추가 단위가 존재한다. 프로듀서가 카프카로 데이터를 보내면, 해당 데이터는 설정된 토픽 내에 있는 특정 파티션으로 들어가게 된다. 앞에서 설명한 것 처럼 토픽은 큐 형태로 존재하며, 데이터는 큐 안에 순서대로 쌓이게 된다. 컨슈머가 원하는 데이터를 포함하는 토픽과 파티션으로부터 데이터를 순서대로 가져오며, 데이터를 다 읽고 나면 새로운 데이터가 들어올 때 까지 대기하게 된다.&lt;/p&gt;

&lt;p&gt;여기서 중요한 것은 &lt;u&gt;데이터를 가져온다고 해서 파티션 내부에 있는 데이터가 삭제되지는 않는다&lt;/u&gt;는 것이다. 왜 카프카는 데이터를 바로 지우지 않는 것일까? 이유는 새로운 컨슈머가 토픽의 이전 데이터를 호출할 수도 있기 때문이다. 단 무조건 가능한 것은 아니며, 컨슈머의 그룹이 달라야 하며 특정 설정값에 대한 요건(auto.offset.reset = earliest)이 만족되어야 한다. 이러한 특징을 통해 얻을 수 있는 장점이 무엇일까? 먼저 위에서 설명한 것 처럼 서버에 갑작스런 이슈가 발생하였을 경우, 장애가 발생한 시점부터의 데이터를 복구하여 고가용성을 보장받을 수 있다. 또한 같은 데이터를 여러개의 서로 다른 플랫폼(예를 들어 한 쪽에서는 엘라스틱서치에서 처리를, 또 다른곳에서는 하둡에 데이터를 저장하고자 할 때)에 적재 할 수도 있다.&lt;/p&gt;

&lt;p&gt;파티션 내의 데이터는 옵션에 따라 삭제되는 시점을 정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;log.retention.ms : 최대 record(데이터) 보존 시간&lt;/li&gt;
  &lt;li&gt;log.retention.byte : 최대 record(데이터) 보존 크기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 그림처럼 파티션이 2개 이상인 경우, 데이터는 어느 파티션으로 들어가게될까? 데이터마다 키가 존재하고, 이를 기반으로 다양한 옵션을 설정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;키가 null, 기본 파티션 사용 : 라운드 로빈(round robin) 기준으로 파티션에 할당&lt;/li&gt;
  &lt;li&gt;키가 존재, 기본 파티션 사용 : 키의 해시값을 이름으로 갖는 특정 파티션에 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 파티션은 마음대로 늘일 수 있을까? 늘이는 것은 언제든지 가능하지만 반대로 줄이는 것은 불가능하다. 그렇기 때문에 파티션을 추가할 때에는 꼭 신중하게 진행하는 것이 좋다. 그렇다면 파티션은 언제 늘이는 것이 좋을까? 파티션을 늘이면 이를 구독할 수 있는 컨슈머의 갯수를 늘일 수 있기 때문에, 데이터 처리를 여러 컨슈머로 분산시킬 수 있다. 그렇기 때문에 컨슈머의 양이 증가되어야 하는 시점에 파티션을 동일하게 늘여주는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;고가용성을-위한-replication복제&quot;&gt;고가용성을 위한 Replication(복제)&lt;/h2&gt;

&lt;p&gt;카프카에는 브로커(broker)라는 개념이 존재하는데, 브로커는 카프카가 설치되어 있는 서버 단위를 의미하며 일반적으로 하나의 카프카 시스템에는 최소 3개의 브로커를 구성하는 것을 권장한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;브로커는 크게 메시지 브로커와 이벤트 브로커로 구분할 수 있는데, 카프카에서 사용하는 브로커는 이벤트 브로커이다. 둘 간의 차이는 수집된 데이터의 즉각적인 삭제 여부이다. 메시지 브로커는 데이터를 보내고 처리하고 삭제하지만, 이벤트 브로커는 서비스에서 나온 이벤트를 큐에 저장해서 발생한 이벤트를 보관한다. 이를 통해 장애가 발생하더라도 해당 이벤트를 복구해서 다시 확인할 수 있거나, 많은 양의 실시간 스트림 데이터를 효과적으로 처리할 수 있는 등의 장점을 얻을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;각 토픽마다 특정 파티션은 브로커에 하나씩 구성할 수 있으며, 이러한 파티션을 브로커마다 복제하는 것을 Replication이라고 부른다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Replication 1개인 토픽 -&amp;gt; n개의 브로커 중 1대에 토픽이 저장됨&lt;/li&gt;
  &lt;li&gt;Replication 3개인 토픽 -&amp;gt; n개의 브로커 중 3대에 토픽이 저장됨.
    &lt;ul&gt;
      &lt;li&gt;단 위에서 언급한 것 처럼, 각 파티션은 브로커 마다 한개씩만 존재해야 하기 때문에 브로커의 수보다 파티션이 많아서는 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209517629-d3b2010d-ef03-4fc8-ac67-f934bad93890.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 6 : 고가용성을 위한 ISR(In Sync Replica) 구조&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 하나의 파티션이 총 3개로 복제되었다면 각 파티션은 뭐라고 부를 수 있을까? 원본은 leader, 복제된 각 파티션은 follower라고 부른다. 즉 3개의 파티션중 원본 1개는 leader, 복제로부터 만들어진 2개는 follower가 된다. 그리고 이 모든 파티션을 합쳐서 ISR(In Sync Replica)라고 부른다(위 그림에서 노란색으로 칠해진 부분).&lt;/p&gt;

&lt;p&gt;실제로 카프카 프로듀서가 데이터를 보내면, 이를 leader 파티션이 받아서 follower 파티션에게 전달하게 된다. 이 과정에서 ack라는 옵션을 사용하여 데이터 전달 과정에서 성능 또는 안정성 중 하나에 대한 중요도를 더욱 높일 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ack&lt;/th&gt;
      &lt;th&gt;특징&lt;/th&gt;
      &lt;th&gt;속도&lt;/th&gt;
      &lt;th&gt;데이터 유실 가능성&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;- leader에게 정상적으로 데이터가 전송되었는지 응답값 못받음&lt;br /&gt;- follower에게 데이터가 제대로 복제되었는지 응답값 못받음&lt;/td&gt;
      &lt;td&gt;속도가 매우 빠름&lt;/td&gt;
      &lt;td&gt;데이터 유실 가능성 제일 높음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;- leader에게 정상적으로 데이터가 전송되었는지 응답값 받음&lt;br /&gt;- follower에게 데이터가 제대로 복제되었는지 응답값 못받음&lt;/td&gt;
      &lt;td&gt;일반적인 속도&lt;/td&gt;
      &lt;td&gt;Leader 파티션이 데이터를 받은 이후 브로커에 장애가 발생할 경우, 나머지 follower에 데이터가 전송되지 못해 데이터 유실가능성이 존재&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;all&lt;/td&gt;
      &lt;td&gt;- leader에게 정상적으로 데이터가 전송되었는지 응답값 받음&lt;br /&gt;- follower에게 데이터가 제대로 복제되었는지 응답값 받음&lt;/td&gt;
      &lt;td&gt;가장 느린 속도&lt;/td&gt;
      &lt;td&gt;데이터의 정상적인 복제를 모두 확인하여 유실 가능성이 거의 없음&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그렇다면 replication 갯수가 많으면 무조건 좋은것일까? 복제해야 하는 서버가 늘어난다는 것은 리소스의 증가 또한 비례한다는 것을 의미한다. 그렇기 때문에 카프카에 들어오는 데이터양과 저장시간(retention time)을 기준으로 총 복제 수를 정하는 것이 좋다. 일반적으로 3개 이상의 브로커를 사용할 때 replication을 3으로 두는 것을 권장한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로듀서의-partitioner란&quot;&gt;프로듀서의 Partitioner란?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209518144-06a6f576-a118-49f3-b9f8-dc803ea95ea3.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 7 : 프로듀서에서 생성한 데이터의 파티션 위치를 결정하는 파티셔너&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;프로듀서의 파티셔너(Partitioner)는 레코드에 포함되어 있는 메시지 키 또는 메시지 값에 따라 해당 데이터를 토픽 내 어떠한 파티션으로 할당할지를 결정한다. 프로듀서 사용시점에 파티션을 특정하지 않았을 경우, 기본적으로 UniformStickyPartitioner으로 설정이 된다. 이 때 메시지 키의 설정 여부에 따라 동작 방식이 달라지게 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메시지 키&lt;br /&gt;여부&lt;/th&gt;
      &lt;th&gt;동작 방식&lt;/th&gt;
      &lt;th&gt;특징&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;- 파티셔너는 메시지 키를 이용하여 해시값 생성&lt;br /&gt;- 해시값 기준으로 파티션 결정&lt;/td&gt;
      &lt;td&gt;순차적인 데이터 처리 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;- 라운드 로빈형태로 파티션 결정&lt;br /&gt;- 프로듀서가 배치 형태로 레코드를 최대한 많이 묶음화한 후, 이를 파티션으로 보냄&lt;/td&gt;
      &lt;td&gt;파티션마다 적절하게 레코드가 분배됨&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;결국 동일한 메시지 키는 동일한 해시값을 만들기 때문에, 항상 동일한 파티션에 데이터가 그룹화되어 할당되고 이를 통해 데이터를 할당된 순서대로 처리할 수 있게 된다. 예를 들어 날씨에 대한 로그를 분석하는 컨슈머의 경우 프로듀서가 메시지 키에 ‘서울’이라는 값을 넣게 되면, 해당 데이터가 동일한 파티션에만 순서대로 적재되기 때문에 컨슈머는 원활하게 데이터를 순서대로 처리할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;추가로 카프카에서는 사용자가 커스텀 파티셔너를 만들 수 있도록 Partitioner 인터페이스를 제공한다. 이를 이용하면 메시지 키, 메시지 값, 토픽 이름에 따라 파티션을 결정할 수 있는데, 예시로 VIP 고객의 데이터를 더 빠르게 처리하고 싶다면, 이러한 커스텀 파티셔너를 이용하여 처리할 컨슈머의 양을 고정적으로 증가시키는 방법을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;컨슈머-랙lag은-무엇이고-어떻게-확인할-수-있을까&quot;&gt;컨슈머 랙(Lag)은 무엇이고 어떻게 확인할 수 있을까?&lt;/h2&gt;

&lt;p&gt;컨슈머 랙은 프로듀서가 파티션에 데이터를 넣어주는 속도가 컨슈머가 파티션으로부터 데이터를 가져가는 속도보다 빠른 경우에 발생한다. 일반적으로 컨슈머에서 성능 저하가 생기거나 비정상적인 동작이 생기는 경우 발생할 수 있는데, &lt;u&gt;각 파티션 별로 프로듀서가 넣은 데이터의 오프셋과 컨슈머가 가져가는 데이터의 오프셋 사이의 차이&lt;/u&gt;라고 이해하면 된다. 
파티션 기준이기 때문에, &lt;u&gt;토픽 내에 존재하는 파티션의 수에 따라 컨슈머 랙 또한 여러 개 존재할 수 있다&lt;/u&gt;. 예를 들어 2개의 파티션과 1개의 컨슈머 그룹이 존재하는 경우, 발생 가능한 컨슈머 랙은 최대 2개가 된다. 이처럼 여러 개의 컨슈머 랙이 존재하는 경우, 이들 중 가장 높은 숫자의 랙은 records-lag-max로 부른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39115630/209518167-0daa77dd-cfe5-4f6e-83a5-9c7ecd444717.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;@그림 8 : 프로듀서와 컨슈머 사이의 데이터 처리량 차이에서 발생하는 컨슈머 랙&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 컨슈머 랙은 어떻게 모니터링할 수 있을까? 컨슈머 랙이 컨슈머를 통해 발생하기 때문에, 자연스럽게 컨슈머 단위로 이를 모니터링해야겠다는 생각이 들것이다. 하지만 이러한 방법은 컨슈머 상태에 매우 의존적이기 때문에, 굉장히 위험한 접근방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만약 컨슈머에 장애가 발생해서 더이상 동작하지 않게되면, 컨슈머에서는 발생하는 랙 정보를 더이상 보낼 수 없기 때문에 정보의 수집이 불가능해진다.&lt;/li&gt;
  &lt;li&gt;컨슈머가 추가로 개발될때마다 해당 컨슈머에서 컨슈머 랙을 수집하는 로직이 추가로 개발되어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 이유로 링크드인에서는 컨슈머 랙을 효과적으로 모니터링할 수 있는 별도의 어플리케이션인 &lt;a href=&quot;https://github.com/linkedin/Burrow&quot;&gt;Burrow&lt;/a&gt;를 제공한다. Burrow는 3가지 큰 특징을 가지고 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;여러개의 카프카 클러스터가 존재하더라도, 단일 Burrow 어플리케이션으로 모든 클러스터에서 발생하는 컨슈머 랙의 모니터링이 가능하다.&lt;/li&gt;
  &lt;li&gt;Sliding window를 통해 컨슈머의 상태를 ERROR, WARNING, OK와 같이 간단하게 확인할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;WARNING: 데이터양이 일시적으로 증가하여 컨슈머 오프셋이 증가되는 경우&lt;/li&gt;
      &lt;li&gt;ERROR: 데이터양이 계속해서 증가하지만 컨슈머에서 데이터를 더이상 수집하지 않는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP API를 제공하여 멀티플랫폼에서 Burrow 적용이 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.inflearn.com/course/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%9E%85%EB%AC%B8/dashboard&quot;&gt;아파치 카프카 for beginner - 데브원영&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://engineering.linkedin.com/blog/topic/kafka&quot;&gt;Kafka Ecosystem - LinkedIn&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%82%B0_%EC%84%9C%EB%B9%84%EC%8A%A4&quot;&gt;DDS(Data Distribution Service) - 위키백과&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90_%EB%AC%B8%EC%A0%9C&quot;&gt;프로듀서-컨슈머(Producer-Consumer) - 위키백과&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/AMQP&quot;&gt;AMQP - 위키백과&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.skby.net/amqp-advanced-message-queue-protocol/&quot;&gt;AMQP(Advanced Message Queue Protocol) - 도리의 디지털라이프&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/linkedin/Burrow&quot;&gt;Burrow - Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">칭찬받는 REST API를 작성하는 방법 15가지</title><link href="http://localhost:4000/2022/11/08/swe-restapi_design/" rel="alternate" type="text/html" title="칭찬받는 REST API를 작성하는 방법 15가지" /><published>2022-11-08T15:00:00+09:00</published><updated>2022-11-08T15:00:00+09:00</updated><id>http://localhost:4000/2022/11/08/swe-restapi_design</id><content type="html" xml:base="http://localhost:4000/2022/11/08/swe-restapi_design/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rest-api란-무엇일까&quot;&gt;REST API란 무엇일까?&lt;/h2&gt;

&lt;p&gt;REST는 Representational State Transfer의 약자로, 웹에서 데이터를 전송하고 처리하는 방법을 정의한 하나의 인터페이스를 말한다. REST는 일반적으로 6가지 정도의 특징을 갖는데, 이를 간략하게(?) 정리하면 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 웹 표준을 사용
    &lt;ul&gt;
      &lt;li&gt;URL 형식으로 표현되기 때문에, 어느 플랫폼에서나 사용 가능&lt;/li&gt;
      &lt;li&gt;HTTP의 캐시 기능 사용 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;들어온 요청을 단순히 처리만 하는 구조이기 때문에, 세션이나 쿠키 정보를 저장하는 구현 없이 서버가 단순해짐
    &lt;ul&gt;
      &lt;li&gt;클라이언트와 서버 간 역할이 명확하게 구분되고, 서로 간 의존성 감소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;REST 메시지만 보고도 기능을 쉽게 알 수 있음 (이렇게 만들기 위한 디자인 패턴이 필요)&lt;/li&gt;
  &lt;li&gt;여러개의 계층으로 구성될 수 있는데, 이는 계층 별로 기능(보안, 로드밸런싱, 암호화 등)을 추가하거나 프록시, 게이트웨이 등의 중간매체를 사용할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결론적으로 REST API를 사용하면 서버와 클라이언트가 &lt;u&gt;서로 최대한 의존하지 않고&lt;/u&gt;, &lt;u&gt;이해하기 쉬운 HTTP 형태로&lt;/u&gt;, &lt;u&gt;원하는 기능을 다양하게 추가할 수 있는&lt;/u&gt; 개발이 가능하다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/practicaldev/image/fetch/s--YTDTEgpk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/ekawmj3rafdtn06hzj79.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;@그림 1 : REST API의 개략적인 구조 - &lt;a href=&quot;https://res.cloudinary.com/practicaldev/image/fetch/s--YTDTEgpk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/ekawmj3rafdtn06hzj79.png&quot;&gt;cloudinary&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rest-api-디자인하기&quot;&gt;REST API 디자인하기&lt;/h2&gt;

&lt;p&gt;그렇다면 REST API를 어떻게 작성하면 좋을까? 코드와 마찬가지로, REST API 또한 많은 사람들이 좋다고 생각해 온 방법들이 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;1-엔드포인트의-이름-규칙명사-하이픈-소문자-등을-지키자&quot;&gt;1. 엔드포인트의 이름 규칙(명사, 하이픈, 소문자 등)을 지키자.&lt;/h3&gt;

&lt;p&gt;“Make sure to use nouns in endpoint paths”&lt;/p&gt;

&lt;p&gt;책을 검색하거나 등록(또는 삭제)하는 API를 만든다고 하자. 이 때 우리가 다루려는 ‘책’이라는 명사를 경로 이름으로 사용하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;HTTP 요청 메소드는 기본적으로 동사로 되어있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GET : 요청 내역을 가져옴&lt;/li&gt;
  &lt;li&gt;POST : 서버로 새로운 데이터를 전송&lt;/li&gt;
  &lt;li&gt;PUT/PATCH : 존재하는 데이터를 변경&lt;/li&gt;
  &lt;li&gt;DELETE : 데이터 삭제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 책을 검색하고자 한다면 어떻게 작성하면 좋을까? 두가지 예시가 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;GET /books&lt;/li&gt;
  &lt;li&gt;GET /get-books&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위에서 권장한 방법대로라면, 1번이 옳은 것이다. 이미 GET이라는 HTTP 메소드가 해당 API의 역할을 충분히 설명하고 있기 때문에, 마지막 경로에 동사를 넣게 되면 중복된 설명이 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;작성된 API를 소리내어 읽어보자. 1번은 책을 가져오다가 되겠지만, 2번은 책을 가져오기를 가져오다가 될 것이다. 어색하지 않은가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;추가로 1번을 보면 book이 아니라 books 복수형으로 표현하고 있다. 이에 대해서는 ‘&lt;a href=&quot;https://stackoverflow.com/questions/6845772/should-i-use-singular-or-plural-name-convention-for-rest-resources&quot;&gt;StackOverflow - Should I use Singular or Plural name convention for REST resources?&lt;/a&gt;‘에서도 많은 논쟁이 있었는데, 가장 많은 추천을 받은 곳에서는 아래와 같이 설명하고 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DB 상에서 book이라는 테이블을 사용한다고 가정해보자.
- 특정 책 하나를 가져오는 요청은 여러 책 중에서 하나를 가져오는 것 이므로, GET /books:id
- 책 전체를 가져오는 요청은 여러 책들의 리스트를 가져오는 것 이므로, GET /books
- 책 한권을 등록하는 요청은 여러 책 안에 한 권의 책을 임의의 ID를 부여하면서 추가하는 것 이므로, POST /books
- 특정 책의 내용을 변경하는 요청은 여러 책 안에 있는 한 권의 책을 변경하는 것 이므로, PUT /books:id
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 StackOverflow를 보더라도, 꼭 복수를 써야한다는 의견만 있는 것은 아니다. 다만 &lt;u&gt;복수를 쓰기로 했으면 복수만, 단수를 쓰기로 했으면 단수만 쓸 것. 혼용하는 것은 지양할 것&lt;/u&gt;이라는 의견에는 모두가 같은 생각임을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;또한 엔드포인트의 이름이 길어지면 하이픈(-)을 사용하는 것이 가독성에 좋다. 밑줄도 좋은 방법이지만, 간혹 URL 주소에 밑줄이 이미 들어가있는 경우들이 존재한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /books/fantasycategory -&amp;gt; GET /books/fantasy-category
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 지금까지 잘 보셨겠지만, 일반적으로 URI 경로에서는 소문자를 사용한다. URL에서 프로토콜과 호스트주소는 대소문자를 구별하지 않지만, 리소스의 경로 부분은 운영체제에 따라 구분되는 경우가 존재한다. 예를 들어 윈도우에서는 구분하지 않지만, 리눅스에서는 이를 구분하고 있다. 이에 대한 혼란을 막기 위해서라도 소문자로 통일하는 것이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;2-데이터-송수신-포멧으로는-json을-사용하자&quot;&gt;2. 데이터 송수신 포멧으로는 JSON을 사용하자.&lt;/h3&gt;

&lt;p&gt;예전에는 XML을 이용했지만, 최근에는 JSON(JavaScript Object Notation)가 API 데이터 송수신 표준 형식이 되었다.&lt;/p&gt;

&lt;p&gt;JSON의 장점을 간략하게 설명하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인간이 읽을 수 있는 텍스트로, 사용이 편리함&lt;/li&gt;
  &lt;li&gt;최소한의 정보를 함축적으로 표현(XML에 비해 적은 용량으로 빠르게 통신 가능)&lt;/li&gt;
  &lt;li&gt;언어에 독립적&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 제공되는 form-data는 클라이언트가 텍스트 또는 숫자 형식의 데이터를 보낼 때는 적합하지 않고, 어차피 대부분의 프레임워크에서 클라이언트가 데이터를 전송할 때 JSON을 사용할 수 있도록 기능을 제공하고 있다. 간단하게 헤더의 Content-Type 부분을 application/json으로 설정하기만 하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;3-http-상태코드를-적극적으로-활용하자&quot;&gt;3. HTTP 상태코드를 적극적으로 활용하자.&lt;/h3&gt;

&lt;p&gt;HTTP에는 이미 수많은 사람들이 사용하고 있는 상태 코드들이 정의되어 있다. API 처리가 정상적으로 이루어졌는지, 혹 아니라면 무슨 이유인지 명확하게 표현하기에 가장 적합하다.&lt;/p&gt;

&lt;p&gt;상태 코드에는 대표적으로 아래와 같은 종류가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200 : 클라이언트의 요청이 정상적으로 수행되었음&lt;/li&gt;
  &lt;li&gt;201 : 클라이언트가 생성과 관련된 요청을 하였고, 이 요청이 정상적으로 완료됨(POST)&lt;/li&gt;
  &lt;li&gt;301 : 클라이언트가 요청한 데이터의 URI가 변경되었을 경우&lt;/li&gt;
  &lt;li&gt;400 : 클라이언트의 요청이 부적절한 경우&lt;/li&gt;
  &lt;li&gt;401 : 클라이언트가 인증과정(로그인 등)을 거치지 않은 상태에서 보안된 데이터에 접근하려고 하는 경우&lt;/li&gt;
  &lt;li&gt;403 : 클라이언트가 인증과 관련 없이, 존재는 하지만 응답할 수 없는 데이터를 요청한 경우 (일반적으로 사용 X)&lt;/li&gt;
  &lt;li&gt;404 : 클라이언트가 인증과 관련 없이, 응답할 수 없는 데이터를 요청한 경우 (일반적으로 사용 O)&lt;/li&gt;
  &lt;li&gt;405 : 클라이언트가 요청한 데이터에 해당 메소드가 존재하지 않거나 사용 불가능 상태인 경우&lt;/li&gt;
  &lt;li&gt;500 : 서버에 문제가 있을 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 외에도 수많은 상태 코드들이 있는데, 중요한 것은 ‘가장 최소한의 개수를 사용’하여 클라이언트가 API 요청 또는 응답에 적절한 상태 코드를 부여할 수 있도록 하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;4-응답-메시지는-표준화-된-내용으로-반환하자&quot;&gt;4. 응답 메시지는 표준화 된 내용으로 반환하자.&lt;/h3&gt;

&lt;p&gt;어떠한 요청에 대한 데이터라 하더라도, 서버로부터 항상 유사한 형태의 표준화된 응답 구조를 사용해야 한다. 그렇게 해야 클라이언트는 동일한 구조 내에서 원하는 값을 예측해서 가져올 수 있게 된다. 만약 아래와 같은 구조가 존재한다고 하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ 
  { 
     bookId: 1, 
     name: &quot;Harry Potter&quot; 
  }, 
  { 
     bookId: 2, 
     name: &quot;Avatar&quot; 
  } 
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 아래와 같이 조금 더 중첩된 구조를 가질 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ 
   &quot;data&quot;: [ 
     { 
       &quot;bookId&quot;: 1, 
       &quot;name&quot;: &quot;Harry Potter&quot; 
     }, 
     { 
       &quot;bookId&quot;: 2, 
       &quot;name&quot;: &quot;Avatar&quot; 
     } 
   ], 
   &quot;totalDocs&quot;: 200, 
   &quot;nextPageId&quot; : 3 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 새로운 책을 추가한다고 하자. 성공했을 경우 권장하는 응답 메시지는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// POST /books 
{ 
     &quot;bookId&quot;: 3, 
     &quot;name&quot;: &quot;Toy Story&quot; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 여기서 ‘책이 성공적으로 등록되었습니다’ 라는 메시지를 추가하면 어떨까? 답은 ‘불필요하다’이다. 우리는 위에서 상태코드를 통해 해당 요청이 정상적으로 완료되었는지 혹은 문제가 생겼는지를 확인하자고 했다. 추가적인 메시지는 중복된 내용을 포함하는 꼴만 만들게 된다.&lt;/p&gt;

&lt;p&gt;오히려 문제가 발생한 경우에 대해서는 무슨 오류가 있었는지에 대한 메시지를 적어주는 것이 좋다. 그렇게 해야 클라이언트가 해당 문제를 빠르게 확인하고 조치를 취할 수 있기 때문이다. 아래와 같은 응답이 적절한 예시가 될 수 있을 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ 
  &quot;code&quot;: &quot;book/not_found&quot;,  // 또는 일련의 숫자 또는 코드형태
  &quot;message&quot;: &quot;ID가 4인 책을 찾을 수 없습니다.&quot; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;응답 메시지에 HTTP 상태 코드를 포함할 필요까지는 없지만, 그래도 사용자 또는 클라이언트가 해당 오류에 대해 빠르게 확인할 수 있도록 오류를 매핑한 코드와 이를 간략하게 설명한 메시지 정도는 정의해두는 것이 좋다. 물론 운영환경에서는 불필요한 보안 정보를 노출하게 될 수 있기 때문에, 개발 단계에서만 이를 노출하는 것이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;5-페이징-기법을-활용헤서-컬렉션으로-받은-많은-데이터를-효율적으로-처리하자&quot;&gt;5. 페이징 기법을 활용헤서 컬렉션으로 받은 많은 데이터를 효율적으로 처리하자.&lt;/h3&gt;

&lt;p&gt;데이터가 많아질수록, 데이터를 어떻게 반환해서 보여줄지가 굉장히 중요해진다. 위에서 정의한 API 중, 등록된 전체 책의 개수를 반환하려고 한다고 가정하자. 책의 개수가 적을 때는 문제가 없겠지만, 수백만권 혹은 수천만권의 책이 있다고 한다면 해당 API를 호출하는 것은 성능이나 대역폭 측면에서 좋지 못한 선택이 될 수 있다.&lt;/p&gt;

&lt;p&gt;페이징 기법(Pagination)을 사용하는 방법으로는 크게 skip, limit 또는 keyset이 있다. 일반적으로 skip, limit을 사용하지만, 페이징 기법을 위해서라도 keyset을 사용하는 것을 권장한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;skip : 출력할 데이터의 시작부분을 설정한다. 입력값으로 들어온 값 + 1부터 출력한다.&lt;/li&gt;
  &lt;li&gt;limit : 출력할 데이터의 개수를 제한한다. 입력값으로 들어온 값 만큼만 반환한다.&lt;/li&gt;
  &lt;li&gt;keyset : 식별자 또는 ID를 참조 값으로 받아서 테이블을 별도로 스캔하지 않고 조건에 맞게 페이징하여 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;추가로 API의 결과 값을 필터링 또는 정렬할 수 있는 기능도 필요하다. 성능을 향상시키기 위해 DB 인덱스에 &lt;a href=&quot;https://goodbyeanma.tistory.com/41&quot;&gt;Access 패턴&lt;/a&gt;을 적용하기도 하는데, 결론적으로 API 호출에 필요한 필터와 정렬은 쿼리 파라미터에 정의되어야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# fantasy 범주에 속하는 책 20권을 조회한다고 가정하는 API
GET /books?limit=20&amp;amp;category=fantasy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-put-보다는-patch를-사용하자&quot;&gt;6. PUT 보다는 PATCH를 사용하자.&lt;/h3&gt;

&lt;p&gt;PUT과 PATCH의 가장 큰 차이는 ‘데이터 내에 변경되는 요소의 범위’이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PUT : 데이터 내 모든 요소를 수정&lt;/li&gt;
  &lt;li&gt;PATCH : 데이터 내 요소 중 일부만 수정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 데이터 내에 있는 모든 요소를 한번에 변경하는 일은 거의 발생하지 않는다. 추가로 의도하지 않게 변경해서는 안되는 요소마저도 변경될 소지가 존재한다. 그렇기 때문에 되도록이면 PATCH를 권장하며, PUT을 절대 사용해서는 안되는 것은 아니다.&lt;/p&gt;

&lt;h3 id=&quot;7-extended-옵션을-사용해서-선택적으로-결과-값을-반환하자&quot;&gt;7. Extended 옵션을 사용해서 선택적으로 결과 값을 반환하자.&lt;/h3&gt;

&lt;p&gt;시스템이 커질수록 데이터 내 요소들도 증가할 수 밖에 없다. 문제는 모든 클라이언트에서도 증가한 요소들을 전부 사용하진 않는다는 것이다.&lt;br /&gt;
이를 해결하기 위해 extended라는 옵션을 사용한다. 아래는 extended 옵션의 유무에 따른 결과 값의 차이를 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /books/:id
{
   &quot;bookId&quot;: 1,
   &quot;name&quot;: &quot;Harry Potter&quot;
}
GET /books/:id?extended=true
{
   &quot;bookId&quot;: 1,
   &quot;name&quot;: &quot;Harry Potter&quot;
   &quot;tags&quot;: [&quot;fantasy&quot;, &quot;magic&quot;, &quot;UK&quot;],
   &quot;author&quot;: {
      &quot;id&quot;: 1,
      &quot;name&quot;: &quot;J.K.Rowling&quot;
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;8-적절하게-엔드포인트의-크기를-나눠주자&quot;&gt;8. 적절하게 엔드포인트의 크기를 나눠주자.&lt;/h3&gt;

&lt;p&gt;API의 기본 사상은 ‘주어진 하나의 일을 잘 수행하자’ 이다. 한번에 여러 작업을 해결할 수 있는 것 보다, 한 눈에 사용 가능한 기능을 확인할 수 있는 작은 단위의 API 설계가 중요하다(어찌보면 books이라는 엔드포인트는 어떻게보면 굉장히 큰 단위일 수 있다). 그리고 이러한 작은 단위의 API를 적절하게 통합하여 클라이언트가 쉽게 기능을 예측하고 이해할 수 있도록 돕는 것이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;9-정확한-api-문서를-제공하자&quot;&gt;9. 정확한 API 문서를 제공하자.&lt;/h3&gt;

&lt;p&gt;API의 궁극적인 목적은 ‘클라이언트가 원하는 기능을 한눈에 알아보고 적절하게 프로그램 상에 배치해서 기능을 수행할 수 있도록 하는 것’이다. 이를 위해서는 API에 대해 잘 정리된 문서가 중요하다.&lt;/p&gt;

&lt;p&gt;문서에는 각 엔드포인트의 목적과 이를 실행하기 위한 권한, 호출하였을 때의 응답 예시, 그리고 실패하였을 때의 오류 메시지가 꼭 명시되어야 한다. 그리고 API의 버전이 변경됨에 따라 내부 기능의 변화 과정을 문서에 꼭 작성해야 한다. 기본적으로 Swagger와 같이 API의 개발과 문서 작성을 동시에 해주는 도구가 있다. 혹은 Postman으로 API를 테스트하고, 이를 문서화 된 파일로 저장해주는 도구도 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;10-보안을-위한-기능을-꼭-적용하자&quot;&gt;10. 보안을 위한 기능을 꼭 적용하자.&lt;/h3&gt;

&lt;p&gt;가장 일반적인 방법으로 SSL을 서버에 적용하면, 클라이언트-서버 간 안전한 통신을 보장하면서 잠재적으로 발생 가능한 공격을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;웹 상에서는 Origin이라는 개념이 존재하는데, 이는 URL 상에서 프로토콜, 도메인, 포트 번호를 합친 부분을 말한다. 접속중인 웹사이트의 Origin은 window.location.origin 명령어를 통해 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://wnjoon.github.io:8545/posts/123 
- 프로토콜(Scheme) : https://
- 도메인 : wnjoon.github.io
- 포트번호 : 8545
- Origin : https://wnjoon.github.io:8545/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;웹 브라우저는 보안 때문에 같은 Origin끼리 통신할 수 있도록 하는 SOP(Same Origin Policy)와 다른 Origin으로도 요청을 보낼 수 있도록 예외를 허용하는 CORS(Cross Origin Resource Sharing) 정책이 존재한다. API의 특성 상 서로 다른 Origin 간 통신은 당연히 발생하기 때문에, CORS를 이용하여 적절하게 HTTP 통신을 제한할 수 있는 기능을 지원해야 한다.&lt;/p&gt;

&lt;p&gt;CORS 프로토콜은 브라우저가 사전 요청(preflight request)을 서버에 보내고, 이를 승인 받은 경우에만 통신할 수 있도록 한다. 이 사전 요청은 HTTP 요청 중 OPTION 메소드를 사용하는데, 이를 위해서는 아래의 사항을 선택적으로 응답 헤더에 넣어야 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Access-Control-Allow-Methods&lt;/li&gt;
  &lt;li&gt;Access-Control-Allow-Headers&lt;/li&gt;
  &lt;li&gt;Access-Control-Allow-Origin&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;11-api-버전을-명시하자&quot;&gt;11. API 버전을 명시하자.&lt;/h3&gt;

&lt;p&gt;개발 과정이 되었든 운영 중에 API 엔드포인트를 변경하거나 내부 구조를 변경하였든, API와 관련된 어느것이라도 변경이 발생하였다면 이를 버전화해야 한다. 클라이언트가 모르는 상태로 갑자기 API의 엔드포인트를 변경해서는 안된다. API는 어떠한 변경이 발생하더라도, 이전의 통신 상태에까지 영향을 주어서는 안된다. 즉, 기존의 방법대로 통신하는 어플리케이션이 하나라도 존재한다면, 해당 기능을 임의대로 정지해서는 안된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://.../v1/book
http://.../v2/book
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;12-캐시-데이터를-사용해서-성능을-향상시키자&quot;&gt;12. 캐시 데이터를 사용해서 성능을 향상시키자.&lt;/h3&gt;

&lt;p&gt;빈번하게 사용되면서 동시에 변경이 거의 발생하지 않는 데이터는 캐싱하는 것이 좋다. 인메모리(in-memory) 또는 캐시 데이터베이스(cached-database)를 이용하는 것이 메인 데이터베이스를 접근하는 것보다 훨씬 좋은 성능을 보인다.&lt;/p&gt;

&lt;p&gt;다만 캐싱된 데이터의 경우 만료기간이 존재할 수 있기 때문에, 적절한 시기에 이를 업데이트 할 수 있도록 구현하는 것이 중요하다. 캐시된 데이터를 사용할 때에는 반드시 HTTP 헤더에 Cache-Control를 포함해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;13-표준-utc를-사용하자&quot;&gt;13. 표준 UTC를 사용하자.&lt;/h3&gt;

&lt;p&gt;API는 시간 또는 공간에 상관없이 어디에서나 호출될 수 있다. 그렇기 때문에 동일한 날짜 표준 방식을 통해 일관성 있는 출력을 보여줄 필요가 있다. ISO8601은 날짜/시간 데이터의 국제 표준 방식으로, 날짜는 Z 또는 UTC 형식이어야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;createdAt&quot;: &quot;2022-11-08T15:00:00Z&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;14-주기적인-헬스체크를-해주자&quot;&gt;14. 주기적인 헬스체크를 해주자.&lt;/h3&gt;

&lt;p&gt;API에 문제가 생겨서 시스템을 정지해야 할 경우, 해당 API는 어쩔 수 없이 복구가 될 때까지는 사용이 불가능하다. 이를 위해 API 호출 시점에 해당 API가 정상적으로 사용 가능한지 확인할 수 있는 헬스체크(Health-check) 시스템이 엔드포인트 상에 적용되어야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /health
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반적으로 이러한 헬스체크 기능은 로드밸런서 등에서 호출될 수 있으며, API의 동작 여부 뿐만 아니라 유지 보수 기간에 대한 개략적인 기준을 제시할 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;15-api-key-인증을-허용하자&quot;&gt;15. API Key 인증을 허용하자.&lt;/h3&gt;

&lt;p&gt;API Key로 인증하게 되면, 3rd party 어플리케이션에서 해당 API를 손쉽게 사용하도록 만들 수 있다. 이를 위해서는 X-Api-Key 또는 Api-Key와 같은 커스텀 HTTP 헤더를 사용해야 한다. 특히 Key의 사용 기한을 정해서 만료일이 있도록 해야 보안상 문제가 발생하였을 경우 이를 무효화할 수 있다는 것을 염두하자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@liams_o/15-fundamental-tips-on-rest-api-design-9a05bcd42920&quot;&gt;15 fundamental tips on REST API design - Williams O&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.freecodecamp.org/news/rest-api-best-practices-rest-endpoint-design-examples/&quot;&gt;REST API Best Practices:REST Endpoint Design Examples - Kolade Chris&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.incodom.kr/REST&quot;&gt;REST (Representational State Transfer) - 인코덤&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://meetup.toast.com/posts/92&quot;&gt;REST API 제대로 알고 사용하기 - NHN Cloud Meetup&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.pumpkin-raccoon.com/115&quot;&gt;REST API URL 주고 컨벤션 - 호박너구리 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6845772/should-i-use-singular-or-plural-name-convention-for-rest-resources&quot;&gt;Should I use Singular or Plural name convention for REST resources? - StackOverflow&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goodbyeanma.tistory.com/41&quot;&gt;SQL SERVER 액세스 패턴 - goodbyeanma&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://it-eldorado.tistory.com/163&quot;&gt;CORS (Cross Origin Resource Sharing) 이해하기 - 피그브라더&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry><entry><title type="html">이더리움에서의 재진입성(Reentrancy) 공격에 대한 이해</title><link href="http://localhost:4000/2022/10/26/blockchain-eth-reentrancy/" rel="alternate" type="text/html" title="이더리움에서의 재진입성(Reentrancy) 공격에 대한 이해" /><published>2022-10-26T00:00:00+09:00</published><updated>2022-10-26T00:00:00+09:00</updated><id>http://localhost:4000/2022/10/26/blockchain-eth-reentrancy</id><content type="html" xml:base="http://localhost:4000/2022/10/26/blockchain-eth-reentrancy/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;재진입성-공격이란&quot;&gt;재진입성 공격이란?&lt;/h2&gt;

&lt;p&gt;재진입이라는 용어는 ‘외부의 악의적인 컨트랙트가 취약한 컨트랙트의 함수를 호출하면서 실행경로가 그 안으로 재진입하는’ 방법이라고 표현한다. 사실 이렇게만 보면 어려운데, 이더리움과 스마트 컨트랙트의 특징을 먼저 살펴보면 좋을 것 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;이더리움은 ‘다른 사용자 주소로 이더를 전송’ 한다.&lt;/li&gt;
  &lt;li&gt;이더리움에서 스마트 컨트랙트는 다른 외부의 스마트 컨트랙트를 호출하고, 그 내부의 기능을 활용할 수 있다.&lt;/li&gt;
  &lt;li&gt;단순히 이더를 전송하거나 존재하지 않는 외부의 스마트 컨트랙트 내 기능을 호출하는 경우, 콜백을 포함한 다양한 대체 코드를 실행할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;재진입성 공격은 &lt;u&gt;컨트랙트가 알 수 없는 주소(스마트 컨트랙트)로 이더를 전송하는 경우&lt;/u&gt; 발생할 수 있다. 내부 fallback 함수에 악성코드를 심어놓은 스마트 컨트랙트로 이더를 전송하게 되면, 악의적인 코드가 실행되면서 발생하는 공격이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fallback 함수 : 이름이 없는 함수로, 스마트 컨트랙트 내에 존재하지 않는 함수를 호출하면 대신 호출되는 함수.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가장 유명한 사례로는 &lt;a href=&quot;https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/&quot;&gt;The DAO 해킹&lt;/a&gt;이 있다. 대략 1억 5천만 달러 이상의 잔액을 보유하고 있던 컨트랙트를 공격하였으며, 이 공격을 통해 이더리움에서 이더리움 클래식이 하드포크 되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;여기 이더를 보관 및 인출해주는 은행 컨트랙트(Bank)와 이를 공격하기 위한 컨트랙트(Attack)가 있다고 하자.&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 은행 컨트랙트
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;payable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Attack&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bankAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_bankAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attackBank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;payable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;ether&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;ether&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;payable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;ether&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;ether&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;공격자(Attacker)가 단일 트랜잭션만으로 Bank 컨트랙트에서 1이더만 남기고 모두 출금하는 과정을 그림으로 표현하면 아래와 같다. 단, Bank 컨트랙트에는 어느정도의 이더가 이미 존재하고 있다고 가정한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/wnjoon/post/6502c25e-0cd0-4d45-89f8-a8e6cbfce390/image.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;@그림 1: 공격자가 Attack 컨트랙트를 이용하여 Bank 컨트랙트를 공격&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;공격자가 Attack 컨트랙트의 attackBank 함수를 실행한다.&lt;/li&gt;
  &lt;li&gt;attackBank 함수가 Bank 컨트랙트의 deposit 함수를 호출하여 1 이더를 입금한다.&lt;/li&gt;
  &lt;li&gt;attackBank 함수가 Bank 컨트랙트의 withdraw 함수를 호출하여 1 이더를 인출한다.&lt;/li&gt;
  &lt;li&gt;Bank 컨트랙트의 withdraw 함수 내부에서 msg.sender(Attack 컨트랙트)에게 1 이더를 전송한다. Attack 컨트랙트의 fallback 함수가 이를 처리한다.&lt;/li&gt;
  &lt;li&gt;Attack 컨트랙트의 fallback 함수 내부에서 다시 Bank 컨트랙트의 withdraw를 호출한다. Bank 컨트랙트의 잔액이 1 이더만 남을때까지 이 과정은 계속 반복된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;어떻게-막을-수-있을까&quot;&gt;어떻게 막을 수 있을까?&lt;/h2&gt;

&lt;p&gt;재진입 공격을 막기 위한 방법은 현재까지 3가지 정도 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;1-transfer-함수-사용&quot;&gt;1. transfer 함수 사용&lt;/h3&gt;

&lt;p&gt;transfer 함수는 외부 컨트랙트 호출에 대해 총 2300개의 가스만 사용할 수 있도록 되어있다. 이는 이더 전송을 위한 단일 트랜잭션은 가능하나, 외부의 다른 컨트랙트를 호출하기에는 적은 양이다.&lt;/p&gt;

&lt;h3 id=&quot;2-엄격한-상태-변수-변경&quot;&gt;2. 엄격한 상태 변수 변경&lt;/h3&gt;

&lt;p&gt;컨트랙트 또는 외부의 다른 컨트랙트에서의 호출을 통해 이더가 전송되기 전 상태변수를 변경하는 방식이다. 이를 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern&quot;&gt;체크 효과 상호작용 패턴(checks-effects-interactions pattern)&lt;/a&gt; 이라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Bank 컨트랙트 예시
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 아래 두 코드의 위치를 변경해서,
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 알 수 없는 주소로의 외부 호출을 수행하는 코드를 
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 지역함수 또는 코드 실행 부분의 
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 가장 마지막에 진행해야 한다.
&lt;/span&gt;        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-뮤텍스mutex-사용&quot;&gt;3. 뮤텍스(mutex) 사용&lt;/h3&gt;

&lt;p&gt;코드가 실행되는 동안에는 컨트랙트를 잠궈주는 상태 변수를 추가하여 재진입을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;개선된-코드&quot;&gt;개선된 코드&lt;/h2&gt;

&lt;p&gt;개선된 Bank 컨트랙트의 코드를 살펴보면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 개선된 은행 컨트랙트
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bank&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 1. 뮤텍스 추가
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;payable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 2. 뮤텍스 확인
&lt;/span&gt;        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        
        &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 3. 상태 변수 우선 변경
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 4. 외부 호출 이전에 뮤텍스 설정
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 5. call 대신 transfer 사용
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 6. 외부 호출 이후 뮤텍스 해제
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/proofer-tech/%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8-%EB%B3%B4%EC%95%88-%EC%9D%B4%EC%8A%88-1-re-entrancy-%EC%9E%AC%EC%A7%84%EC%9E%85%EC%84%B1-7d4caf24803c&quot;&gt;스마트 컨트랙트 보안::Re-entrancy - PROOFER&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://brunch.co.kr/@ashhan/26&quot;&gt;The DAO 해킹 그리고 사망 - 브런치&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/&quot;&gt;Analysis of the DAO exploit - Hacking,Distributed&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wonjoon</name></author><category term="개발" /><summary type="html"></summary></entry></feed>