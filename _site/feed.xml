<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-08-04T08:00:31+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">//TODO: Write Blog</title><subtitle>A (nearly) no-CSS, fast, minimalist Jekyll theme.
</subtitle><author><name>Wonjoon</name></author><entry><title type="html">채권 가격과 금리의 관계: 왜 반대로 움직일까?</title><link href="http://localhost:4000/2025/08/03/interest-rate-bonds/" rel="alternate" type="text/html" title="채권 가격과 금리의 관계: 왜 반대로 움직일까?" /><published>2025-08-03T00:00:00+09:00</published><updated>2025-08-03T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/03/interest-rate-bonds</id><content type="html" xml:base="http://localhost:4000/2025/08/03/interest-rate-bonds/"><![CDATA[<p><strong>결론: 채권의 수요가 증가하면, 채권 가격이 상승하고 시장 금리가 하락합니다.</strong></p>

<h3 id="채권의-특징">채권의 특징</h3>

<p>채권 시장을 보다 보면 이런 말을 자주 듣게 됩니다. 주식처럼 가격이 오르면 좋은 것 아닌가? 싶은데, 왜 금리는 반대로 움직이는 걸까요? 이 원리를 알기 위해선 먼저 채권의 기본 특징 한 가지를 이해해야 합니다.</p>

<p>채권은 정부(국채)나 회사(회사채)가 자금을 조달하기 위해 발행하는 일종의 ‘차용증서’입니다. 정부는 일반적으로 매달 정기적으로 경쟁입찰을 통해 국채를 발행하고, 회사는 자금이 필요한 시기에 이사회의 결정을 거쳐 비정기적으로 회사채를 발행합니다.</p>

<p>채권의 대표적인 특징은 아래와 같습니다.</p>

<ul>
  <li><strong>채권은 발행 시점에 이자와 총량이 고정</strong>된다는 점입니다.</li>
  <li><strong>한번 발행된 채권은 만기가 되기 전까지 주식처럼 시장에서 자유롭게 거래됩니다.</strong></li>
  <li>채권은 발행될 때 지급하기로 약속한<strong>표면 이자율과 이자액이 절대 변하지 않습니다</strong>.</li>
</ul>

<p>특히 마지막 특징인 ‘변하지 않는 표면 이자율과 이자액’이 어떻게 채권 가격과 금리를 반대로 움직이게 만드는지 구체적인 예시로 살펴보겠습니다.</p>

<h3 id="고정된-이자-vs-변동하는-가격">고정된 이자 vs 변동하는 가격</h3>

<p>여기, A회사가 발행한 채권이 있다고 가정해 봅시다.</p>

<ul>
  <li><strong>채권 가격(발행가):</strong> 10,000원</li>
  <li><strong>표면 이자율:</strong> 연 5% (매년 500원의 이자를 지급하기로 약속)</li>
</ul>

<p>이 채권을 발행가인 10,000원에 샀다면, 투자 수익률은 약속 그대로 연 5%입니다.</p>

<p>그런데 이 A회사가 유망하다는 소문이 나면서 채권을 사려는 사람(수요)이 몰렸습니다. 한정된 채권을 사기 위한 경쟁이 붙으면서, 시장 가격이 <strong>10,000원에서 12,000원으로 올랐습니다.</strong></p>

<p>이때 채권의 시장 가격은 12,000원으로 올랐지만, A회사가 지급하기로 약속한 <strong>이자액은 여전히 500원으로 고정</strong>되어 있습니다.</p>

<p>그렇다면 지금 12,000원을 주고 이 채권을 산 사람의 실제 수익률은 어떻게 될까요?</p>

<ul>
  <li><strong>발행 시점 수익률:</strong> 500원 ÷ 10,000원 = <strong>5%</strong></li>
  <li><strong>가격 상승 후 수익률:</strong> 500원 ÷ 12,000원 = <strong>약 4.16%</strong></li>
</ul>

<p>이처럼 채권 가격이 오르니, 투자금 대비 실제 얻게 되는 <strong>‘수익률’은 오히려 떨어졌습니다.</strong> 경제 뉴스에서 말하는 시장 금리는 바로 채권의 실제 수익률을 의미하는 경우가 많습니다. 즉 채권 가격이 오르면서, <strong>금리가 하락(5% → 4.16%)했다고 평가하게 됩니다.</strong></p>]]></content><author><name>Wonjoon</name></author><category term="economy" /><summary type="html"><![CDATA[채권 가격이 오르면 왜 시장 금리는 하락하는지, 그 역학 관계를 설명합니다.]]></summary></entry><entry><title type="html">Go 에러 처리: fmt.Errorf는 언제, 어떻게 사용해야 할까요?</title><link href="http://localhost:4000/2025/06/23/fmt-error-handling/" rel="alternate" type="text/html" title="Go 에러 처리: fmt.Errorf는 언제, 어떻게 사용해야 할까요?" /><published>2025-06-23T00:00:00+09:00</published><updated>2025-06-23T00:00:00+09:00</updated><id>http://localhost:4000/2025/06/23/fmt-error-handling</id><content type="html" xml:base="http://localhost:4000/2025/06/23/fmt-error-handling/"><![CDATA[<h2 id="핵심-요약-tldr">핵심 요약 (TL;DR)</h2>

<ul>
  <li><strong>언제 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 쓰면 안 되나요?</strong>
    <ul>
      <li>라이브러리(예: <code class="language-plaintext highlighter-rouge">backoff.Retry</code>)가 에러의 종류를 파악해야 할 때. <strong>원본 에러를 그대로 반환</strong>해야 라이브러리와의 ‘약속’을 지킬 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>언제 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 써야 하나요?</strong>
    <ul>
      <li>모든 재시도 등 정책적 판단이 끝난 후, 최종적으로 에러를 반환하는 시점. <strong>“재시도 끝에 실패”와 같은 명확한 맥락(Context)을 추가</strong>하기 위해 사용합니다.</li>
    </ul>
  </li>
  <li><strong>가장 중요한 원칙은 무엇인가요?</strong>
    <ul>
      <li><strong>역할 분리</strong>. 에러를 발생시키는 ‘실무자’ 함수와, 그 에러를 받아 정책을 결정하는 ‘매니저’ 함수로 역할을 나누고 각 계층에 맞는 책임을 부여하는 것입니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="질문-1-fmterrorf를-무조건-사용하면-왜-안-되나요">질문 1: <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 무조건 사용하면 왜 안 되나요?</h2>

<p>많은 Go 개발자가 외부 API 호출과 같은 불안정한 작업을 처리할 때 <code class="language-plaintext highlighter-rouge">cenk/backoff</code> 같은 라이브러리로 재시도 로직을 구현합니다. 이때 모든 에러를 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>로 감싸는 실수를 하곤 합니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">doRetry</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span><span class="n">Client</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ...</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">backoff</span><span class="o">.</span><span class="n">Retry</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
		<span class="n">bs</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span> <span class="c">// &lt;-- 여기서는 원본 에러를 그대로 반환</span>
	<span class="p">},</span> <span class="o">...</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="c">// &lt;-- 여기서는 컨텍스트를 추가하여 반환</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"failed after retries %w"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bs</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>결론부터 말하면, <strong>라이브러리가 에러의 종류를 보고 특정 행동(예: 재시도 중단)을 결정해야 할 때, <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>로 에러를 감싸면 원본 에러의 정보가 가려져 라이브러리가 올바르게 동작하지 못하기 때문입니다.</strong></p>

<h2 id="질문-2-어떻게-역할을-분리해야-하나요">질문 2: 어떻게 역할을 분리해야 하나요?</h2>

<p>견고한 에러 처리는 함수의 역할을 ‘실무자’와 ‘매니저’로 명확히 나누는 것에서 시작합니다.</p>

<ul>
  <li>실무자 (<code class="language-plaintext highlighter-rouge">do</code> 함수): 실제 작업을 딱 한 번 수행하고, 그 결과를 가공하지 않은 원본 에러 그대로 보고하는 역할만 합니다.</li>
  <li>매니저 (<code class="language-plaintext highlighter-rouge">doRetry</code> 함수): 실무자의 보고(원본 에러)를 받아 정책적 결정을 내립니다. 예를 들어 ‘일시적 오류’는 재시도, ‘영구적 오류’는 즉시 중단 같은 결정을 합니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">backoff.Retry</code> 라이브러리는 매니저의 ‘비서’와 같습니다. 비서는 실무자가 제출한 원본 에러 보고서에 <code class="language-plaintext highlighter-rouge">backoff.PermanentError</code> 같은 특정 도장이 찍혀 있는지 확인합니다. 만약 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>라는 별도의 봉투에 담아 보고하면, 비서는 중요한 도장을 보지 못하고 재시도하면 안 되는 일에 불필요한 노력을 쏟게 됩니다.</p>

<p>이것이 <code class="language-plaintext highlighter-rouge">backoff.Retry</code> 안에서는 원본 에러(<code class="language-plaintext highlighter-rouge">return err</code>)를 그대로 반환해야 하는 이유입니다. 라이브러리와의 약속(Contract)을 지키는 것이죠.</p>

<h2 id="질문-3-에러에-컨텍스트는-언제-추가해야-가장-좋은가요">질문 3: 에러에 컨텍스트는 언제 추가해야 가장 좋은가요?</h2>

<p>“재시도 끝에 실패했다”와 같은 구체적인 맥락은 <strong>매니저가 모든 정책적 판단을 끝낸 시점</strong>에 추가하는 것이 가장 좋습니다.</p>

<p><code class="language-plaintext highlighter-rouge">doRetry</code> 함수는 <code class="language-plaintext highlighter-rouge">backoff.Retry</code>가 최종적으로 실패했을 때, 비로소 <code class="language-plaintext highlighter-rouge">fmt.Errorf("failed after retries %w", err)</code>를 통해 더 자세한 컨텍스트를 담은 최종 에러를 생성하여 상위 호출자에게 반환합니다.</p>

<blockquote>
  <p><strong>Go 에러 처리 철학</strong>: 에러가 발생한 가장 낮은 수준에서는 원본을 유지하고, 계층을 따라 올라오며 각 계층의 역할에 맞는 컨텍스트를 추가합니다.</p>
</blockquote>

<h2 id="질문-4-defer를-사용할-때-에러는-어떻게-처리해야-하나요">질문 4: <code class="language-plaintext highlighter-rouge">defer</code>를 사용할 때 에러는 어떻게 처리해야 하나요?</h2>

<p><code class="language-plaintext highlighter-rouge">defer</code>로 리소스를 정리할 때 발생하는 에러를 놓치지 않으면서, 더 중요한 원인 에러를 덮어쓰지 않는 것이 중요합니다. 아래는 매우 실용적인 Go의 표준 패턴(idiomatic Go)입니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">do</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="n">bs</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">st</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="c">// &lt;-- 1. 반환 값을 'err'로 명명</span>
    <span class="c">// ...</span>
    <span class="c">// http 요청 등 주요 로직</span>
    <span class="c">// ...</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">closeErr</span> <span class="o">:=</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">();</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="c">// &lt;-- 2. 기존 에러가 없을 때만</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">closeErr</span> <span class="c">// &lt;-- 3. 뒷정리 에러를 최종 에러로 할당</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="c">// ...</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 패턴의 핵심은 <code class="language-plaintext highlighter-rouge">if err == nil</code> 조건입니다.</p>

<ul>
  <li>주요 로직에서 에러가 없었을 경우 (<code class="language-plaintext highlighter-rouge">err</code>가 <code class="language-plaintext highlighter-rouge">nil</code>일 때): defer문에서 발생한 뒷정리 에러(<code class="language-plaintext highlighter-rouge">closeErr</code>)를 최종 반환 에러로 삼습니다.</li>
  <li>주요 로직에서 이미 에러가 발생했을 경우 (<code class="language-plaintext highlighter-rouge">err</code>가 <code class="language-plaintext highlighter-rouge">nil</code>이 아닐 때): 덜 중요한 뒷정리 에러는 무시하고, 더 중요한 최초의 원인 에러를 그대로 보존하여 반환합니다.</li>
</ul>

<p>이는 “함수가 실패했다면, 그 최초의 원인을 보존하라”는 Go의 중요한 에러 처리 철학을 잘 보여줍니다</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Go 언어에서 fmt.Errorf를 올바르게 사용하는 방법을 알아봅니다. 모든 에러를 fmt.Errorf로 감싸는 것이 왜 안티 패턴인지, 재시도 로직과 에러 래핑(wrapping)의 모범 사례를 실제 코드를 통해 명확히 설명합니다.]]></summary></entry><entry><title type="html">Using labels while looping in Rust: Breaking or Continuing Exactly Where You Mean To</title><link href="http://localhost:4000/2025/03/22/expression-block-closure/" rel="alternate" type="text/html" title="Using labels while looping in Rust: Breaking or Continuing Exactly Where You Mean To" /><published>2025-03-22T00:00:00+09:00</published><updated>2025-03-22T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/22/expression-block-closure</id><content type="html" xml:base="http://localhost:4000/2025/03/22/expression-block-closure/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#why-use-loop-labels-in-rust">Why Use Loop Labels in Rust?</a></li>
  <li><a href="#using-loop-with-labels">Using loop with labels</a></li>
  <li><a href="#using-while-with-labels">Using while with labels</a></li>
  <li><a href="#using-for-with-labels">Using for with labels</a></li>
  <li><a href="#using-continue-with-labels">Using continue with labels</a></li>
  <li><a href="#summary">Summary</a></li>
</ul>

<h2 id="why-use-loop-labels-in-rust">Why Use Loop Labels in Rust?</h2>

<p>When you have nested loops, calling <code class="language-plaintext highlighter-rouge">break</code> or <code class="language-plaintext highlighter-rouge">continue</code> may only affect the nearest loop.
If you want to target an outer loop, Rust lets you assign a label using the <code class="language-plaintext highlighter-rouge">label_name:</code> syntax.</p>

<h2 id="using-loop-with-labels">Using loop with labels</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nv">'counting_up</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"count = {count}"</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">remaining</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"remaining = {remaining}"</span><span class="p">);</span>
            
            <span class="k">if</span> <span class="n">remaining</span> <span class="o">==</span> <span class="mi">9</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span> <span class="c1">// exits this inner loop only</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="k">break</span> <span class="nv">'counting_up</span><span class="p">;</span> <span class="c1">// exits the labeled outer loop</span>
            <span class="p">}</span>

            <span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"End count = {count}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">break</code> exits the inner loop</li>
  <li><code class="language-plaintext highlighter-rouge">break 'counting_up</code> exits the outer labeled loop</li>
  <li>You can apply labels to any loop, not just loop blocks</li>
</ul>

<h2 id="using-while-with-labels">Using while with labels</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nv">'outer</span><span class="p">:</span> <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="k">break</span> <span class="nv">'outer</span><span class="p">;</span> <span class="c1">// exits the outer while loop</span>
            <span class="p">}</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Done: i = {i}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="using-for-with-labels">Using for with labels</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nv">'outer</span><span class="p">:</span> <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="k">break</span> <span class="nv">'outer</span><span class="p">;</span> <span class="c1">// exits the outer for loop</span>
            <span class="p">}</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"x = {x}, y = {y}"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="using-continue-with-labels">Using continue with labels</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">'outer</span><span class="p">:</span> <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">continue</span> <span class="nv">'outer</span><span class="p">;</span> <span class="c1">// skips rest of inner loop and moves to next outer iteration</span>
        <span class="p">}</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"x = {x}, y = {y}"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>break</td>
      <td>Exits the nearest loop</td>
    </tr>
    <tr>
      <td>break ‘label</td>
      <td>Exits the specific loop with the given label</td>
    </tr>
    <tr>
      <td>continue ‘label</td>
      <td>Skips to the next iteration of the labeled loop</td>
    </tr>
    <tr>
      <td>Label works on</td>
      <td><code class="language-plaintext highlighter-rouge">loop</code>, <code class="language-plaintext highlighter-rouge">while</code>, <code class="language-plaintext highlighter-rouge">for</code>, and <code class="language-plaintext highlighter-rouge">continue</code></td>
    </tr>
  </tbody>
</table>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Rust allows you to label loops and precisely control break and continue flow — even across nested loop, while, and for blocks. Learn how to avoid confusion in complex loop structures with simple, powerful labels.]]></summary></entry><entry><title type="html">Expression Blocks vs Closures in Rust – What’s the Difference?</title><link href="http://localhost:4000/2025/03/22/add-label-in-loop/" rel="alternate" type="text/html" title="Expression Blocks vs Closures in Rust – What’s the Difference?" /><published>2025-03-22T00:00:00+09:00</published><updated>2025-03-22T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/22/add-label-in-loop</id><content type="html" xml:base="http://localhost:4000/2025/03/22/add-label-in-loop/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#expression-blocks-vs-closures">Expression Blocks vs Closures</a>
    <ul>
      <li><a href="#key-differences">Key Differences</a></li>
      <li><a href="#expression-blocks-inline-one-time-calculations">Expression Blocks: Inline One-Time Calculations</a></li>
      <li><a href="#closures-anonymous-functions-for-reuse-and-flexibility">Closures: Anonymous Functions for Reuse and Flexibility</a></li>
    </ul>
  </li>
  <li><a href="#comparison-with-go">Comparison with Go</a></li>
  <li><a href="#summary-when-to-use-what">Summary: When to Use What?</a></li>
</ul>

<h2 id="expression-blocks-vs-closures">Expression Blocks vs Closures</h2>

<h3 id="key-differences">Key Differences</h3>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Expression Block</th>
      <th>Closure</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>What it is</td>
      <td>Inline calculation block</td>
      <td>Anonymous function</td>
    </tr>
    <tr>
      <td>Execution timing</td>
      <td>Immediately</td>
      <td>When called</td>
    </tr>
    <tr>
      <td>Parameters</td>
      <td>Not allowed</td>
      <td>Allowed</td>
    </tr>
    <tr>
      <td>Captures outer variables</td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Reusable</td>
      <td>One-time</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Passable to other funcs</td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Return value</td>
      <td>Last expression</td>
      <td>Last expression</td>
    </tr>
  </tbody>
</table>

<h3 id="expression-blocks-inline-one-time-calculations">Expression Blocks: Inline One-Time Calculations</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
<span class="p">};</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{y}"</span><span class="p">);</span> <span class="c1">// 15</span>
</code></pre></div></div>

<ul>
  <li>Block used just for computing a value</li>
  <li>Executed immediately</li>
  <li>Returns the last expression (no semicolon)</li>
  <li>Does not take parameters or capture external variables</li>
  <li>Great for one-off logic that doesn’t need to be reused</li>
</ul>

<h4 id="when-to-use-expression-blocks">When to Use Expression Blocks</h4>

<ul>
  <li>You need a value from a mini logic block</li>
  <li>You don’t need parameters</li>
  <li>You want instant evaluation</li>
  <li>You’re not planning to reuse the logic</li>
</ul>

<h4 id="example-using-if-match-or-even-loop-as-a-value">Example: Using if, match, or even loop as a value</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">is_even</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">true</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">false</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">match</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="k">=&gt;</span> <span class="s">"one"</span><span class="p">,</span>
    <span class="mi">2</span> <span class="k">=&gt;</span> <span class="s">"two"</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="s">"many"</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">let</span> <span class="n">loop_value</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span> <span class="k">break</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// loop_value == 30</span>
</code></pre></div></div>

<p><strong>Note: <code class="language-plaintext highlighter-rouge">while</code> and <code class="language-plaintext highlighter-rouge">for</code> are statements, not expressions — they can’t be used like this.</strong></p>

<h3 id="closures-anonymous-functions-for-reuse-and-flexibility">Closures: Anonymous Functions for Reuse and Flexibility</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="o">=</span> <span class="p">|</span><span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 7</span>
</code></pre></div></div>

<ul>
  <li>Similar to anonymous functions in Go, JavaScript, etc.</li>
  <li>Executed only when called</li>
  <li>Can take parameters and capture external variables</li>
  <li>Useful when passing logic into another function (e.g. <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>)</li>
  <li>Can be reused multiple times</li>
</ul>

<h4 id="when-to-use-closures">When to Use Closures</h4>

<ul>
  <li>You need to reuse logic</li>
  <li>You want to pass logic as a parameter to another function</li>
  <li>You need to delay execution</li>
  <li>You need to capture external values</li>
</ul>

<h4 id="common-use-cases">Common Use Cases</h4>

<h5 id="1-parameterized-logic">1. Parameterized Logic</h5>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">square</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="c1">// 25</span>
</code></pre></div></div>

<h5 id="2-passing-to-higher-order-functions">2. Passing to Higher-Order Functions</h5>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">nums</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="k">let</span> <span class="n">doubled</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
<span class="c1">// Result: [2, 4, 6]</span>
</code></pre></div></div>

<h5 id="3-threaded-or-async-code">3. Threaded or Async Code</h5>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello from thread"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h5 id="4-capturing-external-variables">4. Capturing External Variables</h5>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">"Hi"</span><span class="p">;</span>
<span class="k">let</span> <span class="n">say_hello</span> <span class="o">=</span> <span class="p">|</span><span class="n">name</span><span class="p">|</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{greeting}, {name}"</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">say_hello</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">));</span> <span class="c1">// "Hi, Alice"</span>
</code></pre></div></div>

<h2 id="comparison-with-go">Comparison with Go</h2>

<p>Go only has function literals (<code class="language-plaintext highlighter-rouge">func() { ... }</code>) — no concept of expression blocks as values.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="o">:=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">val</span><span class="p">()</span> <span class="c">// Must be called</span>
</code></pre></div></div>

<p>In Rust:</p>

<ul>
  <li>Use closures for what you’d use <code class="language-plaintext highlighter-rouge">func() { ... }</code> in Go</li>
  <li>Use expression blocks for inline logic to assign values quickly</li>
</ul>

<h2 id="summary-when-to-use-what">Summary: When to Use What?</h2>

<table>
  <thead>
    <tr>
      <th>Situation</th>
      <th>Use</th>
      <th>Why</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Simple inline calculation</td>
      <td>Expression block</td>
      <td>Less syntax, faster execution</td>
    </tr>
    <tr>
      <td>Passing logic to another function</td>
      <td>Closure</td>
      <td>Closures are first-class citizens</td>
    </tr>
    <tr>
      <td>Accepting dynamic inputs</td>
      <td>Closure</td>
      <td>Accepting dynamic inputs</td>
    </tr>
    <tr>
      <td>Passing logic to another function</td>
      <td>Closure</td>
      <td>Closures take parameters</td>
    </tr>
    <tr>
      <td>Referencing external values</td>
      <td>Closure</td>
      <td>Can capture and use outer scope</td>
    </tr>
    <tr>
      <td>Like func() in Go</td>
      <td>Closure</td>
      <td>Closures = Go’s anonymous functions</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[In Rust, both expression blocks ({}) and closures (|| {}) can return values — but they serve different purposes. This post breaks down their differences, when to use each, and how they compare to Go’s func().]]></summary></entry><entry><title type="html">Understanding String Types in Rust and Go</title><link href="http://localhost:4000/2025/03/20/rust-about-string-type/" rel="alternate" type="text/html" title="Understanding String Types in Rust and Go" /><published>2025-03-20T00:00:00+09:00</published><updated>2025-03-20T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/20/rust-about-string-type</id><content type="html" xml:base="http://localhost:4000/2025/03/20/rust-about-string-type/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#strings-in-rust">Strings in Rust</a></li>
  <li><a href="#strings-in-go">Strings in Go</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="strings-in-rust">Strings in Rust</h2>

<h3 id="str--string-slice">&amp;str – String Slice</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span> <span class="c1">// &amp;str</span>
</code></pre></div></div>

<ul>
  <li>Immutable, read-only reference to a string</li>
  <li>Stored in static memory (binary section)</li>
  <li>Does not use the heap</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span> 
<span class="c1">// s points to the memory address of the "hello" string</span>

<span class="n">s</span> <span class="o">=</span> <span class="s">"bye"</span><span class="p">;</span>
<span class="c1">// s now points to a new memory address for "bye"</span>
<span class="c1">// The value isn't modified — the reference changes</span>

<span class="c1">// diagram</span>
<span class="c1">// "string type variable only points to the memory address"</span>
<span class="c1">// s -&gt; 0x1234["hello"] </span>
<span class="c1">// s -&gt; 0x5678["bye"]</span>
</code></pre></div></div>

<h3 id="string--heap-allocated-mutable-string">String – Heap-Allocated Mutable String</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>Mutable, owns the data</li>
  <li>Stored on the heap</li>
  <li>You can modify it using methods like .push_str() and .clear()</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> 
<span class="c1">// creates an empty string</span>

<span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span> <span class="c1">// compile error — not mutable</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">s2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> <span class="c1">// mutable</span>

<span class="n">s2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="n">s2</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" world"</span><span class="p">);</span>      <span class="c1">// "hello world"</span>
</code></pre></div></div>

<h2 id="strings-in-go">Strings in Go</h2>

<h3 id="string">string</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span> <span class="o">:=</span> <span class="s">"first"</span>
<span class="n">test</span> <span class="o">=</span> <span class="s">"second"</span>
</code></pre></div></div>

<ul>
  <li>Immutable value type</li>
  <li>Internally, a string is just a struct with a byte pointer and length:</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">string</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">*</span><span class="kt">byte</span>
    <span class="nb">len</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Assigning a new string creates a new string object in memory</li>
  <li>You cannot modify part of a string directly</li>
</ul>

<h3 id="how-to-modify-strings-in-go">How to “Modify” Strings in Go</h3>

<p>To modify a string in Go, convert it into a mutable byte slice:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">:=</span> <span class="s">"hello"</span>
<span class="n">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>   <span class="c">// Convert to byte slice</span>
<span class="n">b</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'H'</span>       <span class="c">// Modify</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c">// Convert back to string</span>

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>  <span class="c">// "Hello"</span>
</code></pre></div></div>

<h2 id="rust-vs-go-strings-at-a-glance">Rust vs Go: Strings at a Glance</h2>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>Go</th>
      <th>Rust</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Immutable string</td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td><code class="language-plaintext highlighter-rouge">&amp;str</code></td>
    </tr>
    <tr>
      <td>Mutable string (heap allocated)</td>
      <td><code class="language-plaintext highlighter-rouge">[]byte</code>, <code class="language-plaintext highlighter-rouge">[]rune</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
    </tr>
    <tr>
      <td>Modify string variable (new value)</td>
      <td>s = “new”</td>
      <td>s = <code class="language-plaintext highlighter-rouge">String::from(...)</code></td>
    </tr>
    <tr>
      <td>Modify string content</td>
      <td>via <code class="language-plaintext highlighter-rouge">[]byte</code> conversion</td>
      <td>via mutable <code class="language-plaintext highlighter-rouge">String</code></td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>In both Rust and Go, default strings are immutable — they point to memory, but do not allow direct content modification.</li>
  <li>To change the content of a <code class="language-plaintext highlighter-rouge">string</code>:
    <ul>
      <li>In Rust, use a mutable <code class="language-plaintext highlighter-rouge">String</code></li>
      <li>In Go, convert to <code class="language-plaintext highlighter-rouge">[]byte</code> or <code class="language-plaintext highlighter-rouge">[]rune</code></li>
    </ul>
  </li>
  <li>If you’re just changing the entire string value, you’re assigning a new memory reference either way.</li>
  <li>Rust gives more fine-grained control over memory and mutability, while Go keeps things simple but less flexible when it comes to string manipulation.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[In this post, we compare how strings work in Rust and Go — especially in terms of mutability, memory handling, and how to modify them. If you’ve ever wondered why Rust has both &str and String, or why Go strings can’t be changed directly, this breakdown is for you.]]></summary></entry><entry><title type="html">Should You Really Get a MacBook?</title><link href="http://localhost:4000/2025/03/19/macbook-purchase-guidline/" rel="alternate" type="text/html" title="Should You Really Get a MacBook?" /><published>2025-03-19T00:00:00+09:00</published><updated>2025-03-19T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/19/macbook-purchase-guidline</id><content type="html" xml:base="http://localhost:4000/2025/03/19/macbook-purchase-guidline/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#target-readers">Target Readers</a></li>
  <li><a href="#introduction-so-many-laptops-why-macbook">Introduction: So Many Laptops, Why MacBook?</a></li>
  <li><a href="#macbooks-are-pretty-period">MacBooks Are Pretty. Period</a></li>
  <li><a href="#is-a-macbook-necessary-for-developers">Is a MacBook Necessary for Developers?</a></li>
  <li><a href="#the-ill-use-it-forever-justification">The “I’ll Use It Forever” Justification</a></li>
  <li><a href="#is-macos-hard-to-use">Is macOS Hard to Use?</a></li>
  <li><a href="#the-hidden-costs-accessories--compatibility">The Hidden Costs: Accessories &amp; Compatibility</a></li>
  <li><a href="#but-what-about-apple-ecosystem--aesthetics">But What About Apple Ecosystem &amp; Aesthetics?</a></li>
  <li><a href="#can-you-game-on-a-mac">Can You Game on a Mac?</a></li>
  <li><a href="#final-thoughts">Final Thoughts</a></li>
</ul>

<h2 id="target-readers">Target Readers</h2>

<ul>
  <li>Aspiring developers</li>
  <li>Students looking to buy their first laptop</li>
  <li>Non-tech users who still want a cool MacBook</li>
</ul>

<h2 id="introduction-so-many-laptops-why-macbook">Introduction: So Many Laptops, Why MacBook?</h2>

<p>Back in my college days, ThinkPads (a.k.a. the famous red-dotted “bbalkkong”) were the go-to laptops for CS majors. Brands like Dell and HP were also quite popular. Out of patriotism (and practicality), I chose a lightweight 11-inch LG laptop.</p>

<p>Then came the game-changer: the 13-inch Retina MacBook in 2014. I saw that crisp screen once and was sold.</p>

<p>Since then, for over 10 years, my main work machine has always been a MacBook. But now that MacBooks are more popular than ever — especially among developers — it’s worth asking…</p>

<p><strong>“Do you really need a MacBook to become a developer?”</strong></p>

<h2 id="macbooks-are-pretty-period">MacBooks Are Pretty. Period</h2>

<p>Let’s get real. One of the strongest appeals of a MacBook is its beauty. It’s not just a laptop — it’s a fashion statement, a status symbol, and yes, a design masterpiece.</p>

<p>From “Why would you get that overpriced laptop?” to “You must have a MacBook to code!” — the perception of the MacBook in Korea and beyond has changed drastically.</p>

<p>Yes, Apple’s silicon chips are powerful. Yes, Windows laptops are getting pricier too. But ultimately…</p>

<p><strong>“You buy a MacBook first because it looks amazing.”</strong></p>

<p>And honestly, that’s okay.</p>

<h2 id="is-a-macbook-necessary-for-developers">Is a MacBook Necessary for Developers?</h2>

<p>Many say that since macOS is Unix-based, it’s easier for developers — especially those working with Linux servers. That was definitely true… in the past.</p>

<p>But Windows has caught up. With WSL2 (Windows Subsystem for Linux), you can run full Linux environments natively on Windows — no need for virtual machines or complex setups.</p>

<p>Plus, Apple’s shift to ARM-based chips (M1, M2, M3, etc.) created some compatibility issues with traditional x86 Linux environments. While tools like Docker help mitigate that, it’s not all smooth sailing.</p>

<p><strong>“A MacBook might not always be better — just different.”</strong></p>

<p>So no, being a developer doesn’t require a MacBook. Windows with WSL is now more than capable — and in some cases, even better suited for server-side development.</p>

<h2 id="the-ill-use-it-forever-justification">The “I’ll Use It Forever” Justification</h2>

<p>It’s common to see questions like:</p>

<p><strong>“I’m just learning to code now… should I max out the CPU and RAM?”</strong></p>

<p>My take? No. Unless you’re editing 8K videos or training AI models, a base model MacBook Air is more than enough.</p>

<p>I’ve used the 2020 M1 MacBook Pro for over 4 years with zero issues — and I’m a professional developer.</p>

<p><strong>“Buy for your current needs. Upgrade later if you actually need to.”</strong></p>

<p>And yes, 16-inch models look cool, but they’re heavy. If you commute on foot or public transport, go 14-inch or smaller.</p>

<h2 id="is-macos-hard-to-use">Is macOS Hard to Use?</h2>

<p>For lifelong Windows users: yes, at first. macOS does things differently — keyboard shortcuts, window management, file system, etc.</p>

<p>But you’ll adapt. Humans are adaptable creatures.</p>

<p>If you’re used to Microsoft Office or specific Korean software, there might be hiccups — but these days, most major apps support macOS just fine.</p>

<p>And yes, macOS no longer struggles with Korean fonts or certificates. That ship has sailed.</p>

<p><img src="https://github.com/user-attachments/assets/cd97cb20-e494-43cc-8167-484784e28a2b" alt="Image" />
@ <a href="https://www.apple.com/kr/macbook-pro/mac-does-that/">And Apple says you can easily switch from Windows to macOS :)</a>.</p>

<h2 id="the-hidden-costs-accessories--compatibility">The Hidden Costs: Accessories &amp; Compatibility</h2>

<p>You might need to buy extra accessories.</p>

<ul>
  <li>USB hubs, dongles, adapters — they add up.</li>
  <li>Cheaper accessories can cause damage. Get reputable brands.</li>
</ul>

<p>Windows on Mac? Not easy anymore.</p>

<ul>
  <li>Since Apple moved to their own chips, BootCamp is gone.</li>
  <li>You’ll need virtualization software (like Parallels), and even that costs money -  plus a Windows license.</li>
</ul>

<h2 id="but-what-about-apple-ecosystem--aesthetics">But What About Apple Ecosystem &amp; Aesthetics?</h2>

<p>Some say:</p>

<p><strong>“If you have an iPhone, iPad, AirPods — you should definitely get a MacBook too.”</strong></p>

<p>Not necessarily.</p>

<p>Sure, continuity features like AirDrop or shared clipboard are nice. But you won’t lose much by not having them either.</p>

<p>You don’t need to complete the Apple Infinity Gauntlet.</p>

<p>Also: yes, it looks amazing at Starbucks. My wife uses a Galaxy Book, I still take my MacBook.</p>

<h2 id="can-you-game-on-a-mac">Can You Game on a Mac?</h2>

<p>Short answer: You can. Long answer: It’s not ideal, but it’s getting better.</p>

<p>Cloud gaming, browser-based games, and new compatibility layers (like Wine, Crossover, etc.) help. But if you’re a serious gamer? Stick with Windows.</p>

<p><strong>“But hey, long gaming sessions aren’t healthy anyway.”</strong></p>

<h2 id="final-thoughts">Final Thoughts</h2>

<p>I’ve used MacBooks for over 10 years — and never regretted it. But that doesn’t mean it’s the right choice for everyone.</p>

<p>Here’s what I’ll say:</p>

<p>Get a MacBook if:</p>

<ul>
  <li>You love the design</li>
  <li>You want a reliable, well-optimized device</li>
  <li>You value battery life and quiet operation</li>
  <li>You’re okay adapting to macOS</li>
</ul>

<p>Don’t get one if:</p>

<ul>
  <li>You’re on a tight budget</li>
  <li>You need specific Windows-only software</li>
  <li>You game a lot</li>
</ul>

<p>Buy what fits your budget and purpose. Don’t overthink it. And remember — MacBooks are not mandatory for developers.</p>

<p>Hope this post helps you make a better decision!</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[Just because it’s expensive doesn’t mean it’s the right choice — and a MacBook might not be the answer for everyone. This post explores whether a MacBook truly fits your needs, budget, and lifestyle — especially if you’re a student or aspiring developer.]]></summary></entry><entry><title type="html">Rust Error Handling: unwrap, expect, and unwrap_or</title><link href="http://localhost:4000/2025/03/18/rust-error-handling-methods/" rel="alternate" type="text/html" title="Rust Error Handling: unwrap, expect, and unwrap_or" /><published>2025-03-18T00:00:00+09:00</published><updated>2025-03-18T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/18/rust-error-handling-methods</id><content type="html" xml:base="http://localhost:4000/2025/03/18/rust-error-handling-methods/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#why-rust-forces-you-to-handle-errors">Why Rust Forces You to Handle Errors</a></li>
  <li><a href="#handling-errors-unwrap-expect-unwrap_or">Handling Errors: unwrap, expect, unwrap_or</a></li>
  <li><a href="#more-idiomatic-alternatives">More Idiomatic Alternatives</a></li>
  <li><a href="#comparison-with-go">Comparison with Go</a></li>
  <li><a href="#summary">Summary</a></li>
</ul>

<h2 id="why-rust-forces-you-to-handle-errors">Why Rust Forces You to Handle Errors</h2>

<p>In Rust, functions that can fail typically return a Result&lt;T, E&gt; type. You must handle the result, even if you are confident the operation will succeed.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="s">"42"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// Result&lt;i32, ParseIntError&gt;</span>
</code></pre></div></div>

<p>Trying to ignore the Result leads to a compile-time warning:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>warning: unused <span class="sb">`</span>Result<span class="sb">`</span> that must be used
 <span class="nt">--</span><span class="o">&gt;</span> main.rs:2:9
  |
2 |     <span class="nb">let </span>num <span class="o">=</span> <span class="s2">"42"</span>.parse::&lt;i32&gt;<span class="o">()</span><span class="p">;</span>
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^
  |         |
  |         this <span class="sb">`</span>Result<span class="sb">`</span> may be an <span class="sb">`</span>Err<span class="sb">`</span> variant, which should be handled
</code></pre></div></div>

<p>You can’t use the result as if it’s already a number:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="s">"42"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// Ok(42)</span>
<span class="k">let</span> <span class="n">doubled</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>         <span class="c1">// Error: result is not i32 but Result&lt;i32, _&gt;</span>
</code></pre></div></div>

<h2 id="handling-errors-unwrap-expect-unwrap_or">Handling Errors: unwrap, expect, unwrap_or</h2>

<p>Rust provides several built-in ways to handle Result values.</p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Panics on Error?</th>
      <th>Provides Default Value?</th>
      <th>Custom Message?</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>unwrap()</td>
      <td>Yes</td>
      <td>No</td>
      <td>No</td>
      <td>Quick tests, throwaway code</td>
    </tr>
    <tr>
      <td>expect(“msg”)</td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>Debugging with context</td>
    </tr>
    <tr>
      <td>unwrap_or(x)</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Fallback/default values</td>
    </tr>
  </tbody>
</table>

<h3 id="unwrap">unwrap()</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"42"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>    <span class="c1">// Returns 42</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="s">"abc"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>   <span class="c1">// Panics!</span>
</code></pre></div></div>

<p>When an error occurs, <code class="language-plaintext highlighter-rouge">unwrap()</code> panics with a default error message:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thread <span class="s1">'main'</span> panicked at <span class="s1">'called `Result::unwrap()` on an `Err` value: ParseIntError'</span>
</code></pre></div></div>

<p>Not safe for production code—use only when you’re absolutely sure it will not fail.</p>

<h3 id="expectcustom-message">expect(“custom message”)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"abc"</span>
    <span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="nf">.expect</span><span class="p">(</span><span class="s">"number type is required"</span><span class="p">);</span>
</code></pre></div></div>

<p>Customizes the panic message:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thread <span class="s1">'main'</span> panicked at <span class="s1">'number type is required: ParseIntError'</span>
</code></pre></div></div>

<p>Helps during debugging by giving clearer failure context than <code class="language-plaintext highlighter-rouge">unwrap()</code>.</p>

<h3 id="unwrap_ordefault_value">unwrap_or(default_value)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"abc"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 0 when parse fails</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{x}"</span><span class="p">);</span> <span class="c1">// Output: 0</span>
</code></pre></div></div>

<p>No panic. Returns a default fallback instead of crashing.</p>

<h2 id="more-idiomatic-alternatives">More Idiomatic Alternatives</h2>

<p>These methods avoid panic and allow graceful error handling.</p>

<h3 id="pattern-matching-with-match">Pattern Matching with match</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="s">"42"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">();</span>

<span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Parsed number: {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Error occurred: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="if-let-for-simpler-matching">if let for Simpler Matching</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="s">"42"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Parsed number: {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Not a valid number."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="propagating-errors-with--operator">Propagating Errors with ? Operator</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">parse_number</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="s">"42"</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>  <span class="c1">// If parse fails, early return</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Only works inside functions that return <code class="language-plaintext highlighter-rouge">Result</code>.</li>
</ul>

<h2 id="comparison-with-go">Comparison with Go</h2>

<table>
  <thead>
    <tr>
      <th>Rust</th>
      <th>Go</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>.unwrap()</td>
      <td>panic(err)</td>
    </tr>
    <tr>
      <td>.unwrap_or(default_value)</td>
      <td>if err != nil { return default_value }</td>
    </tr>
    <tr>
      <td>.expect(“msg”)</td>
      <td>panic(“msg: “ + err.Error())</td>
    </tr>
  </tbody>
</table>

<h2 id="summary">Summary</h2>

<p>Rust enforces error handling at compile time to eliminate runtime surprises. You have multiple tools at your disposal—choose based on the level of control and safety you need:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unwrap()</code> – Fast, but dangerous.</li>
  <li><code class="language-plaintext highlighter-rouge">expect("msg")</code> – Safer panic with clear context.</li>
  <li><code class="language-plaintext highlighter-rouge">unwrap_or(default_value)</code> – Clean fallbacks.</li>
  <li><code class="language-plaintext highlighter-rouge">match</code>, <code class="language-plaintext highlighter-rouge">if let</code>, <code class="language-plaintext highlighter-rouge">?</code> – Idiomatic and safe.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Learn how Rust enforces error handling at compile time and explore different techniques for dealing with Result effectively using unwrap, expect, unwrap_or, and pattern matching.]]></summary></entry><entry><title type="html">How macros in Rust work and comparison with C language</title><link href="http://localhost:4000/2025/03/17/rust-macro-compare-c/" rel="alternate" type="text/html" title="How macros in Rust work and comparison with C language" /><published>2025-03-17T00:00:00+09:00</published><updated>2025-03-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/17/rust-macro-compare-c</id><content type="html" xml:base="http://localhost:4000/2025/03/17/rust-macro-compare-c/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#what-are-macros-in-rust">What Are Macros in Rust?</a></li>
  <li><a href="#macros-vs-functions-in-rust">Macros vs. Functions in Rust</a></li>
  <li><a href="#compile-time-vs-runtime-execution">Compile-Time vs. Runtime Execution</a></li>
  <li><a href="#when-should-you-use-macros">When Should You Use Macros?</a></li>
  <li><a href="#when-should-you-use-functions">When Should You Use Functions?</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="what-are-macros-in-rust">What Are Macros in Rust?</h2>

<p>Macros in Rust allow code to be expanded at compile time and included in the final executable.</p>

<p><strong>Rust documentation commonly refers to macros as “expanded” at compile time.</strong></p>

<ul>
  <li>However, this term can be <strong>misleading</strong>.</li>
  <li>The term “expanded” may suggest that the code dynamically changes at runtime. However, Rust macros operate entirely at compile time and do not modify execution at runtime.</li>
  <li>Instead of just being “expanded,” macros generate code, which is then compiled into the final executable.</li>
</ul>

<p>A more precise way to explain macros:</p>

<ul>
  <li>Macros generate code at compile time and include it in the final program.</li>
  <li>Once the executable is compiled, the macro-generated code is “fixed” and cannot change at runtime.</li>
</ul>

<h2 id="macros-vs-functions-in-rust">Macros vs. Functions in Rust</h2>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Macros (macro_rules!)</th>
      <th>Functions (fn)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Code Generation at Compile Time</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Variable Number of Arguments</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Supports Multiple Types</td>
      <td>Yes (via code generation)</td>
      <td>Yes (via generics)</td>
    </tr>
    <tr>
      <td>Performance Optimization</td>
      <td>Yes (no loops, direct code expansion)</td>
      <td>No (loops execute at runtime)</td>
    </tr>
    <tr>
      <td>Readability &amp; Debugging</td>
      <td>Hard to debug</td>
      <td>Easy to debug</td>
    </tr>
  </tbody>
</table>

<h3 id="when-should-you-use-macros">When Should You Use Macros?</h3>

<ul>
  <li>You need compile-time code generation to optimize performance.</li>
  <li>You need to support multiple types dynamically.</li>
  <li>You need variable-length arguments (e.g., <code class="language-plaintext highlighter-rouge">println!</code>).</li>
</ul>

<h3 id="when-should-you-use-functions">When Should You Use Functions?</h3>

<ul>
  <li>You need standard logic implementation.</li>
  <li>You need easier debugging.</li>
  <li>You have repetitive logic that doesn’t require compile-time expansion.</li>
</ul>

<h3 id="macros-are-not-just-about-avoiding-code-repetition">Macros are not just about avoiding code repetition</h3>

<ul>
  <li>If simple repetition is needed, functions are usually a better choice.</li>
  <li>Use macros when you need compile-time optimizations, dynamic argument handling, or complex code generation.</li>
</ul>

<h2 id="compile-time-vs-runtime-execution">Compile-Time vs. Runtime Execution</h2>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Compile Time (Macro Expansion)</th>
      <th>Runtime (Function Execution)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Macros (macro_rules!)</td>
      <td>Code is expanded at compile time</td>
      <td>Never executed directly</td>
    </tr>
    <tr>
      <td>Functions (fn)</td>
      <td>No expansion at compile time</td>
      <td>Executed during runtime</td>
    </tr>
    <tr>
      <td>Error Detection</td>
      <td>Errors occur at compile time</td>
      <td>Errors occur at runtime</td>
    </tr>
  </tbody>
</table>

<h3 id="using-macros-macro_rules">Using Macros (macro_rules!)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">repeat</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$msg:expr</span><span class="p">,</span> <span class="nv">$count:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nv">$msg</span><span class="p">);</span> <span class="p">)</span><span class="o">*</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">repeat!</span><span class="p">(</span><span class="s">"Hello, Rust!"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    
    <span class="c1">// The macro expands into:</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Hello, Rust!"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Hello, Rust!"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Hello, Rust!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The macro expands the <code class="language-plaintext highlighter-rouge">println!</code> calls at compile time, rather than looping at runtime.</li>
  <li>When compiled, the executable already contains three <code class="language-plaintext highlighter-rouge">println!</code> statements, eliminating any need for iteration at runtime.</li>
</ul>

<h3 id="using-functions-fn">Using Functions (fn)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">count</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">repeat</span><span class="p">(</span><span class="s">"Rust is awesome!"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The function executes a loop at runtime instead of unrolling at compile time.</li>
  <li>The compiled binary contains a loop, which adds execution overhead compared to macros.</li>
</ul>

<h2 id="advantages-of-using-macros">Advantages of Using Macros</h2>

<p>Macros expand code at compile time, reducing runtime overhead.</p>

<ul>
  <li>Functions require stack management and runtime execution.</li>
  <li>Macros allow code to be directly inserted into the final program, avoiding function calls.</li>
  <li>For example, match statements inside macros can be expanded into static branching logic, improving performance.</li>
</ul>

<h2 id="why-macros-are-hard-to-debug">Why Macros Are Hard to Debug</h2>

<h3 id="macros-expand-into-new-code-before-compiling">Macros Expand Into New Code Before Compiling</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">bad_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$val</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"True"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"False"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">bad_macro!</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>  <span class="c1">// error</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The macro expands before compilation, replacing <code class="language-plaintext highlighter-rouge">bad_macro!(42)</code>; with:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="mi">42</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"True"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"False"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But if 42 is not valid in Rust -&gt; this causes a type mismatch.</p>

<p>Rust’s error message points to the expanded code, not the macro definition:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0308]: mismatched types
 <span class="nt">--</span><span class="o">&gt;</span> src/main.rs:9:5
  |
9 |     bad_macro!<span class="o">(</span>42<span class="o">)</span><span class="p">;</span>
  |     ^^^^^^^^^^^^^ expected <span class="sb">`</span>bool<span class="sb">`</span>, found integer
  |
  <span class="o">=</span> note: expected <span class="nb">type</span> <span class="sb">`</span>bool<span class="sb">`</span>
             found <span class="nb">type</span> <span class="sb">`</span><span class="o">{</span>integer<span class="o">}</span><span class="sb">`</span>
</code></pre></div></div>

<p>Rust does not indicate that the error originated inside <code class="language-plaintext highlighter-rouge">bad_macro!</code>.
Instead, it shows an error where the macro was expanded, making debugging more difficult.</p>

<h3 id="debugging-logs-are-limited">Debugging Logs Are Limited</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">debug_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nv">$val</span> <span class="o">/</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Runtime error</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">debug_macro!</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>This macro expands before compilation, meaning <code class="language-plaintext highlighter-rouge">let result = 10 / 0;</code> is inserted directly.</li>
  <li>Rust won’t warn about division by zero at compile time, but it crashes at runtime.</li>
  <li>Debugging is difficult because Rust does not pinpoint where inside the macro the issue originated.</li>
</ul>

<h3 id="how-to-debug-macros">How to Debug Macros?</h3>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo <span class="nb">install </span>cargo-expand
cargo <span class="nb">expand</span>
</code></pre></div></div>

<ul>
  <li>Use <code class="language-plaintext highlighter-rouge">cargo expand</code> to view the expanded macro output</li>
</ul>

<h2 id="comparison-with-c-macros">Comparison with C Macros</h2>

<p>Although C and Rust are both compiled languages, Rust macros provide safer and more structured compile-time code generation.</p>

<h3 id="define">#define</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define SQUARE(x) (x * x)
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">SQUARE</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// Expands to: (5 * 5)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>C macros are text replacements, not structured code transformations.</li>
  <li>They lack type checking and can introduce subtle bugs.</li>
  <li>Rust macros, in contrast, operate within the compiler and ensure type safety.</li>
</ul>

<h3 id="inline-functions">inline Functions</h3>

<h4 id="comparison-with-rust-macros">Comparison with Rust Macros</h4>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>C inline Function</th>
      <th>Rust Macro (macro_rules!)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Compile-Time Expansion</td>
      <td>Compiler decides whether to inline</td>
      <td>Always expands at compile time</td>
    </tr>
    <tr>
      <td>Guaranteed Optimization</td>
      <td>Not always inlined</td>
      <td>Always replaces code directly</td>
    </tr>
    <tr>
      <td>Code Size Consideration</td>
      <td>Large functions may not be inlined</td>
      <td>Can increase code size</td>
    </tr>
    <tr>
      <td>Flexibility</td>
      <td>Works with fixed types</td>
      <td>Works with multiple types and patterns</td>
    </tr>
  </tbody>
</table>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Compilers may choose not to inline functions for performance reasons.</li>
  <li>Large or recursive functions will not be inlined.</li>
  <li>Rust macros, in contrast, always expand before compilation.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p><strong>When to Use Rust Macros?</strong></p>

<ul>
  <li>You need compile-time code generation for performance.</li>
  <li>You need flexible, generic behavior across multiple types.</li>
  <li>You need variadic arguments (e.g., <code class="language-plaintext highlighter-rouge">println!</code>).</li>
</ul>

<p><strong>When to Avoid Rust Macros?</strong></p>

<ul>
  <li>You need easier debugging -&gt; Functions are better.</li>
  <li>You don’t need compile-time code transformation -&gt; Functions work fine.</li>
  <li>Your macro logic is too complex -&gt; Hard to maintain.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Macros in Rust allow code to be expanded at compile time and included in the final executable.]]></summary></entry><entry><title type="html">Understanding inline Functions in C: When and How They Work</title><link href="http://localhost:4000/2025/03/17/inline-function-c/" rel="alternate" type="text/html" title="Understanding inline Functions in C: When and How They Work" /><published>2025-03-17T00:00:00+09:00</published><updated>2025-03-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/17/inline-function-c</id><content type="html" xml:base="http://localhost:4000/2025/03/17/inline-function-c/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#what-is-an-inline-function-in-c">What Is an inline Function in C?</a></li>
  <li><a href="#why-use-inline-functions">Why Use inline Functions?</a></li>
  <li><a href="#when-does-the-compiler-ignore-inline">When Does the Compiler Ignore inline?</a></li>
  <li><a href="#forcing-the-compiler-to-inline-a-function">Forcing the Compiler to Inline a Function</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="what-is-an-inline-function-in-c">What Is an inline Function in C?</h2>

<p>An <code class="language-plaintext highlighter-rouge">inline</code> function is a special function in C that suggests the compiler replace the function call with its actual code to optimize performance.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// Expands to: int result = (5 * 5);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>When the compiler processes <code class="language-plaintext highlighter-rouge">square(5)</code>, it replaces the function call with its definition: <code class="language-plaintext highlighter-rouge">int result = (5 * 5);</code></li>
  <li>This eliminates the overhead of function calls, potentially improving performance.</li>
</ul>

<h2 id="why-use-inline-functions">Why Use inline Functions?</h2>

<ul>
  <li>Performance Optimization – Reduces function call overhead.</li>
  <li>Encapsulation – Keeps function logic organized while avoiding extra calls.</li>
  <li>Reduced Stack Usage – No need to store function call metadata in the stack.</li>
</ul>

<h2 id="when-does-the-compiler-ignore-inline">When Does the Compiler Ignore inline?</h2>

<p>However, unlike Rust macros, inline in C is just a hint to the compiler—it does not guarantee inlining. The compiler decides whether to actually inline the function based on various optimization criteria.</p>

<p>Despite marking a function as inline, the compiler might not inline it in the following cases:</p>

<h3 id="1️-the-function-is-too-large">1️. The Function Is Too Large</h3>

<p>If a function contains too many instructions, inlining it could increase code size unnecessarily.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">big_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Large loop</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Expanding this function in multiple places increases binary size.</li>
  <li>Too much code duplication can harm performance rather than improve it.</li>
  <li>The compiler might keep it as a regular function instead.</li>
</ul>

<h3 id="2-recursive-functions">2. Recursive Functions</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Recursive call</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Inlining a recursive function is impossible in most cases because the function keeps calling itself.</li>
  <li>The compiler would need to unroll the recursion into a loop, which is not always feasible.</li>
  <li>If recursion depth is small and known in advance, consider manual loop unrolling instead.</li>
</ul>

<h3 id="3-function-pointers-prevent-inlining">3. Function Pointers Prevent Inlining</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span> <span class="c1">// Assign function to pointer</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">func_ptr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>     <span class="c1">// Compiler does not know function at compile time</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>When using function pointers, the actual function call is determined at runtime, not at compile time.</li>
  <li>The compiler cannot replace function calls with direct code expansion because the target function is unknown during compilation.</li>
  <li>Use direct function calls instead of function pointers when inlining is critical.</li>
</ul>

<h2 id="forcing-the-compiler-to-inline-a-function">Forcing the Compiler to Inline a Function</h2>

<p>If the compiler ignores inline, you can explicitly force inlining using compiler-specific attributes.</p>

<h3 id="1-gcc--clang-attributealways_inline">1. GCC &amp; Clang: <strong>attribute</strong>((always_inline))</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">))</span> <span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Ensures the function will always be inlined, even if it’s large.</li>
  <li>Only works if optimizations are enabled (-O2 or higher).</li>
  <li>Forcing inlining on a large function can increase binary size and reduce cache efficiency.</li>
</ul>

<h3 id="2-msvc-microsoft-compiler-__forceinline">2. MSVC (Microsoft Compiler): __forceinline</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__forceinline</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Forces the function to be inlined in Microsoft compilers (MSVC).</li>
  <li>Ensures consistent inlining behavior across different builds.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Use inline for:</p>

<ul>
  <li>Small, frequently used functions.</li>
  <li>Performance-sensitive calculations (e.g., mathematical operations).</li>
  <li>Functions that replace macros for better type safety.</li>
</ul>

<p>Avoid inline for:</p>

<ul>
  <li>Large functions (can increase binary size).</li>
  <li>Recursive functions.</li>
  <li>Functions used with pointers or virtual functions (C++).</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[inline functions in C allow code to be expanded at compile time and included in the final executable.]]></summary></entry><entry><title type="html">defer in Go Doesn’t Always Reflect the Latest Value</title><link href="http://localhost:4000/2025/03/14/go-defer-value/" rel="alternate" type="text/html" title="defer in Go Doesn’t Always Reflect the Latest Value" /><published>2025-03-14T00:00:00+09:00</published><updated>2025-03-14T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/14/go-defer-value</id><content type="html" xml:base="http://localhost:4000/2025/03/14/go-defer-value/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#the-problem">The Problem</a></li>
  <li><a href="#the-reason-why-status-is-not-updated">The Reason why status is not updated</a></li>
  <li><a href="#how-to-fix-it">How to Fix It?</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="the-problem">The Problem</h2>

<p>Consider the following Go function:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">status</span> <span class="kt">string</span>  <span class="c">// Initialized as an empty string</span>
    <span class="k">defer</span> <span class="n">notify</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">foo</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s">"error"</span>  <span class="c">// Status changes here, but defer does not reflect this change</span>
        <span class="k">return</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="n">status</span> <span class="o">=</span> <span class="s">"success"</span>
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We might expect notify(status) to reflect the latest value of status.
However, in reality, it always receives an empty string (<code class="language-plaintext highlighter-rouge">""</code>), regardless of how status is updated later.</p>

<h2 id="the-reason-why-status-is-not-updated">The Reason why status is not updated</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">status</span> <span class="kt">string</span> <span class="c">// ""</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">status</code> is initialized as an empty string</li>
  <li><code class="language-plaintext highlighter-rouge">defer</code> evaluates its arguments immediately when declared.
    <ul>
      <li>When <code class="language-plaintext highlighter-rouge">defer notify(status)</code> is called, <code class="language-plaintext highlighter-rouge">status</code> is still an empty string.</li>
      <li>Thus, <code class="language-plaintext highlighter-rouge">defer</code> captures the empty string(<code class="language-plaintext highlighter-rouge">""</code>) at this moment and never updates, even if <code class="language-plaintext highlighter-rouge">status</code> changes later.</li>
    </ul>
  </li>
  <li>Even though <code class="language-plaintext highlighter-rouge">status</code> is modified in the function, the deferred function call was already bound to the original value of <code class="language-plaintext highlighter-rouge">status</code> (empty string).</li>
  <li>In Go, when a function is deferred, its arguments are evaluated and stored immediately—not when the function actually executes.</li>
</ul>

<h2 id="how-to-fix-it">How to Fix It?</h2>

<p>To ensure that notify(status) receives the latest value of status, we can use two different approaches.</p>

<h3 id="1-using-a-closure-anonymous-function">1. Using a Closure (Anonymous Function)</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">notify</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">}()</span>
</code></pre></div></div>

<ul>
  <li>Instead of immediately passing <code class="language-plaintext highlighter-rouge">status</code> to <code class="language-plaintext highlighter-rouge">notify</code>, we defer an anonymous function.</li>
  <li>This function captures <code class="language-plaintext highlighter-rouge">status</code> at the moment <code class="language-plaintext highlighter-rouge">defer</code> executes, ensuring it reflects the latest value.</li>
  <li>When <code class="language-plaintext highlighter-rouge">notify(status)</code> is finally called, it uses the updated value of <code class="language-plaintext highlighter-rouge">status</code>.</li>
</ul>

<h3 id="2-passing-a-pointer">2. Passing a Pointer</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defer</span> <span class="n">notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Instead of passing the value of <code class="language-plaintext highlighter-rouge">status</code>, we pass its memory address (<code class="language-plaintext highlighter-rouge">&amp;status</code>).</li>
  <li>Since <code class="language-plaintext highlighter-rouge">defer</code> captures the pointer, any changes to <code class="language-plaintext highlighter-rouge">status</code> are reflected at execution time.</li>
  <li>However, this requires modifying <code class="language-plaintext highlighter-rouge">notify</code> to accept a pointer parameter.</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// If using a pointer, notify must be updated:</span>
<span class="c">// Dereference the pointer to get the latest value</span>
<span class="k">func</span> <span class="n">notify</span><span class="p">(</span><span class="n">status</span> <span class="o">*</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">)</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3-comparison-of-solutions">3. Comparison of Solutions</h3>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th>How it Works</th>
      <th>Requires Function Signature Change?</th>
      <th>Best Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Closure (Anonymous Function)</td>
      <td>Captures <code class="language-plaintext highlighter-rouge">status</code> at execution time</td>
      <td>No</td>
      <td>Works for most cases</td>
    </tr>
    <tr>
      <td>Pointer Passing (&amp;status)</td>
      <td>Passes a pointer, reflects latest value</td>
      <td>Yes</td>
      <td>When working with functions that support pointers</td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>Deferred functions capture arguments immediately, not when they actually run.</li>
  <li>If the deferred function needs the latest value, use:
    <ul>
      <li>Closures (Anonymous Functions): Recommended, as they don’t require modifying function signatures.</li>
      <li>Pointers (&amp;status): Useful when modifying function behavior explicitly.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[In Go, deferred functions capture arguments immediately, not when they actually run. Learn how to fix this common issue using closures or pointers to ensure your deferred calls use the latest variable values.]]></summary></entry></feed>