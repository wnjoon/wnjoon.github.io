<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-09-17T20:43:47+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">blog.wonjoon</title><subtitle>A blog about software engineering, blockchain, and other development topics.
</subtitle><author><name>Wonjoon</name></author><entry><title type="html">Claude Code를 활용한 vim cheatsheet vscode extension 개발기</title><link href="http://localhost:4000/2025/09/17/vim-vscode-extenstion/" rel="alternate" type="text/html" title="Claude Code를 활용한 vim cheatsheet vscode extension 개발기" /><published>2025-09-17T00:00:00+09:00</published><updated>2025-09-17T00:00:00+09:00</updated><id>http://localhost:4000/2025/09/17/vim-vscode-extenstion</id><content type="html" xml:base="http://localhost:4000/2025/09/17/vim-vscode-extenstion/"><![CDATA[<h2 id="hhkb-배열의-키보드를-구매한-것이-시작이었다">HHKB 배열의 키보드를 구매한 것이 시작이었다</h2>

<p>제 아내를 포함해서 저와 가까운 사람들이 항상 하는 이야기가 있습니다. 제가 물욕이 없다는 것입니다. 저는 개발자치고는 주변기기에 관심도 욕심도 없어서 주는대로 사용하는 편인데요, 여느때처럼 그냥 개발을 하다가 문득 이 상황이 지루하다고 느껴진 때가 있었습니다. 남들처럼 달그락 소리가 나는 멋진 키보드가 한번 써보고 싶었달까요. 그리고 제가 또 평범한건 별로 안좋아합니다.</p>

<p>사실 vim은 대학생 시절부터 써오던, 특히 미국에서 일하던 임베디드 개발자 시기에 굉장히 많이 사용했던 도구입니다. 그렇다고 잘 사용한건 아닙니다. 그냥 어쩔수없이 사용했고, xcode에서 c를 포팅해서 사용할 수 있는 방법을 알고나서부터는 사용하지 않았습니다. 앞서 말씀드린것처럼 저는 평범하지 않은것에 굉장히 흥미를 느끼는데요, ‘찐개발자라면 vim을 사용해야한다’는 영상이 그당시에는 왜 그리 흥미로웠는지 모르겠지만, 그렇게 저는 ‘명색이 개발자라면 vim을 사용하기에 좋은 키보드를 한번쯤 써봐야한다’는 마음으로 HHKB 배열의 키보드를 구매했습니다.</p>

<p>원래 마음같아선 해피해킹을 구입하려고 했습니다만, 여기서도 평범한것을 원치 않았던 저는 키크론에서 HHKB 배열로 만든 <a href="https://keychron.kr/q60max/">Q60 Pro Max</a>를 구입했습니다. 키보드에 대한 사용기는 나중에 블로그로 작성해보려고 합니다.</p>

<p><br /></p>

<p><img src="https://tbnws.hgodo.com/wordpress/keychorn/products/q60max/products_thumb_q60max_2.jpg" alt="" /></p>

<p><br /></p>

<p>결국 평범하지 않은 키배열의 키보드를 구매하고나니, vim을 꼭 제대로 익혀서 남들과 다른 모습의 개발자가 되고싶다는 욕심이 생겼습니다. 그래서 바로 vim extension을 설치했고, 1주일이 채 지나지 않아 해당 기능을 다시 disable하는 사태가 발생하고 말았습니다. 오늘 외운 단축키가 내일 생각이 나지 않았고, 익숙해지기 어려운 구조 덕분에 점점 업무 진행속도가 느려지게 되니 어쩔수 없었습니다.</p>

<p>한참뒤에 다시 또 욕심이 생겨서 vim extension을 설치했지만, 이 과정은 그냥 도르마무마냥 반복되고 있었습니다.</p>

<!-- ![](https://img.extmovie.com/files/attach/images/135/139/200/068/873e05f63a07c1cbd17782f793d970bf.gif) -->
<p><img src="https://velog.velcdn.com/images/wnjoon/post/5bcb4010-a9a1-4641-a9e4-7323deafdd0d/image.gif" alt="" /></p>

<h2 id="단축키를-바로-확인할-수는-없을까">단축키를 바로 확인할 수는 없을까?</h2>

<p>저에게는 vim을 잘 다루고싶다는 동기는 확실했습니다. 문제는 이 동기를 끝까지 이룰 수 있도록 해주는 좋은 방법이 없었습니다. vim 단축키를 화면에 띄워놓기도 해봤고, 프린팅해서 모니터 옆에 놓기도 해봤습니다만 결국 개발 중간에 ‘내가 원하는 단축어를 찾아내는 과정’이 굉장히 불편했습니다.</p>

<p>제가 요즘 AI 에이전트를 이용해서 이것저것 개발해보고싶은 마음에 claude code도 유료로 구독하고, 책도 사는 등 굉장히 열정적입니다. 일명 ‘바이브 코딩(저는 이 단어를 별로 좋아하지는 않습니다만)’이라고 부르는 것을 좀 해보고싶은데, 막상 개발하고싶은 프로그램은 또 없어서 고민중이었는데요. 원래 본인이 가장 필요하다고 느끼는 것을 개발하는 것 부터가 바이브코딩의 시작이라고 하더라구요? 그때 무릎을 탁 치면서 떠올렸습니다.</p>

<p>“아! vim 단축키를 vscode extension으로 만들면 나도 사용할 수 있겠구나!”</p>

<h2 id="다양한-언어로-vim-단축키를-제공하는-extension-만들기">다양한 언어로 vim 단축키를 제공하는 extension 만들기</h2>

<p><a href="https://vim.rtorr.com/">vim.rtorr.com</a>는 다양한 언어로 vim 단축키를 제공하는 사이트입니다. 이 사이트에는 약 37개의 언어로 vim 단축키를 제공하고 있었고, MIT 라이센스 기반으로 되어있었기 때문에 이 사이트를 참조하여 extension에 필요한 데이터를 수집할 수 있었습니다.</p>

<p>처음에는 37개 모든 언어를 제공하는 extension을 만들고자 헀으나, 최종적으로는 가장 많이 사용되는 8개의 언어를 기준으로 extension을 만들었습니다.</p>

<ol>
  <li>English</li>
  <li>한국어</li>
  <li>简体中文</li>
  <li>日本語</li>
  <li>Español</li>
  <li>Deutsch</li>
  <li>Français</li>
  <li>Português</li>
</ol>

<h2 id="claudemd-설정하기">CLAUDE.md 설정하기</h2>

<p>요즘 바이브코딩을 할때 추천하는 순서가 아래와 같다고 합니다.</p>

<ol>
  <li>gemini에게 전체적인 흐름, 아이디어를 검토받고 이를 claude code에게 전달할 수 있는 문서(CLAUDE.md)를 만든다.</li>
  <li>claude code에게 CLAUDE.md를 참고하여 개발하도록 요청한다.</li>
  <li>만들어진 프로그램을 감상한다.</li>
</ol>

<p>그래서 저도 똑같이 gemini에게 먼저 프로그램에 대한 저의 아이디어와 개발 방향을 이야기했습니다.</p>

<p><em>“HHKB(해피해킹배열) 키보드를 거금주고 구매해서 vim을 사용한 개발을 좀 해보려고하는데, 시도는 여러번해도 이게 손에 잘 익혀지지가 않네.. 일반적으로 개발하던 습관이 몸에 베어있어서 그런가. 그래서 vim 단축키를 별도의 창으로 띄워두고 해봤는데, 그러다보니 생산성이 너무 떨어져. 혹시 vscode에서 vim을 사용할때 즉각즉각 단축키를 확인할 수 있는 익스텐션이나 기능들이 있을까? 만약 없으면, 이런 기능을 만들어서 extension으로 만드는건 어려운일일까?”</em></p>

<p>gemini는 저의 애틋한 마음을 알아주었고, claude code가 잘 이해하고 개발해줄 수 있도록 멋드러진 CLAUDE.md를 작성해주었습니다. 물론 채팅을 하면서 생기는 문제점이나 고민들을 해결해가면서 아래와 같이 최종본을 다듬어갔습니다.</p>

<ul>
  <li>사용한 CLAUDE.md 파일은 <a href="https://github.com/wnjoon/vscode-vm-cheet-sheet/blob/main/CLAUDE.md">여기</a>에서 확인할 수 있습니다.</li>
</ul>

<h2 id="claude-code에게-claudemd를-참고하여-개발하도록-요청하기">claude code에게 CLAUDE.md를 참고하여 개발하도록 요청하기</h2>

<p>이제 CLAUDE.md 파일을 개발할 디렉토리에 넣고 claude를 호출했습니다. 바로 CLAUDE.md를 사용해서 개발하기 전에, 전체적인 목차를 보고 혹시 미비하거나 먼저 해결해야 할 사항이 있는지 물어보았습니다. 명확하지 않은 부분들을 claude와 해결하고 난 뒤에 하나씩 작업을 진행했습니다.</p>

<p>진행된 전체적인 단계를 간략하게 요약해보면,</p>

<ol>
  <li>
    <p>vim.rtorr.com로부터 각 언어별로 vim 단축키를 스크래핑할 수 있는 기능을 먼저 만들었습니다. 그리고 초기에 설정했던 한국어와 영어에 대해 먼저 데이터를 수집했습니다.</p>
  </li>
  <li>
    <p>처음에는 한국어와 영어만 지원하려고 했으나, 이왕 하는거 몇개 더 추가해보자는 생각으로 어떤 언어를 추가하면 좋을지 claude와 논의했습니다. 37개 모두를 추가하면 배포 가능한 extension 크기보다 데이터가 커질 수 있기 때문에, 8개정도로 한정하자는 claude의 의견을 받아들였습니다. 최대한 효율적으로(?) 일을 줄여나가는 claude의 모습에 감탄했습니다. 스크래핑 함수를 먼저 만들어놓았기 때문에 나머지 언어들은 금방 수집할 수 있었습니다.</p>
  </li>
  <li>
    <p>누군가는 이미 기본 단축키(Cmd+K+V)를 사용하고 있을 수도 있다고 생각했습니다. 그래서 단축키를 변경하는 기능을 extension에서 제공하도록 해서 설정 메뉴에 들어가는 수고로움을 줄이자고 했습니다. 이부분은 claude도 매우 찬성해주었습니다.</p>
  </li>
</ol>

<h2 id="extension-배포하기">Extension 배포하기</h2>

<p>이부분은 저도 처음하는거라 claude가 알려주는 방법 + 구글링(<a href="https://velog.io/@bo-like-chicken/%EC%9E%91%EA%B3%A0-%EC%86%8C%EC%A4%91%ED%95%9C-Viusal-Studio-Code-%ED%99%95%EC%9E%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EB%A7%8C%EB%93%A4%EA%B8%B0">참조사이트</a>)을 통해 진행했습니다.</p>

<ol>
  <li>Azure DevOps에서 계정을 만들어야 합니다.</li>
  <li><a href="https://marketplace.visualstudio.com/">Marketplace</a>의 Publisher로 등록해야 합니다.</li>
  <li>Personal Access Token을 발급받아야 합니다.</li>
  <li>extension을 배포하려는 터미널(로컬)에서 <code class="language-plaintext highlighter-rouge">vsce login</code> 명령어를 사용하여 publisher ID와 Personal Access Token을 입력합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">vsce package</code> 명령어를 사용하여 extension을 패키징합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">vsce publish</code> 명령어를 사용하여 extension을 배포합니다.</li>
</ol>

<p>추가로 개발된 extension의 package.json의 내용과 publisher 정보(ID), extension의 정보등이 일치해야 합니다. 이 부분은 구글링 또는 AI에게 질문하면 너무 잘 알려주기 때문에 이 글에서는 생략하도록 하겠습니다.</p>

<p>그리고 vsce publish 명령어를 사용하면, Marketplace에 동일한 이름을 가진 extension이 있는지 확인합니다. 중복된 이름이 있는 경우에는 ERROR가 발생하기 때문에, 이를 방지하려면 미리 생각하고 있는 extension의 이름이 중복되지는 않았는지 확인해야 합니다.</p>

<h2 id="굉장히-만족스러운-결과">굉장히 만족스러운 결과</h2>

<p>이렇게 해서 총 걸린 작업은 약 1시간 이내였습니다. 중간에 초콜릿도 먹고 커피도 먹었던 시간을 제외하면 30분 내외로도 충분히 가능할 것 같았습니다.</p>

<p><img src="https://velog.velcdn.com/images/wnjoon/post/dbcce4ac-dc2d-4a82-9fcb-78d2b5d5290f/image.png" alt="image" /></p>

<ul>
  <li>배포된 extension은 <a href="https://marketplace.visualstudio.com/items?itemName=xonxoon.quick-vim-cheatsheet">여기</a>에서 확인할 수 있습니다.</li>
  <li>Marketplace에서 조회가 되지 않으시다면, <a href="https://github.com/wnjoon/vscode-vm-cheet-sheet/releases/tag/v1.0.0">v1.0.0-release</a>를 통해 설치하실 수 있습니다.</li>
  <li><a href="https://github.com/wnjoon/vscode-vm-cheet-sheet">github</a> 리포지토리를 통해서는 작성된 코드를 확인하실 수 있습니다.</li>
</ul>

<h2 id="후기">후기</h2>

<p>이전 글에서도 제가 바이브코딩에 대한 생각을 짧게나마 적어보았지만, AI가 점점 발전해가면서 저와 같은 개발자들은 오히려 ‘엄청나게 똑똑한 조수’를 둔 것 같은 느낌이 듭니다. 조수라고 표현한 이유는, 앞에서 언급하지는 않았지만, AI가 개발하는 중간 결과들에 대해서 이를 주문한 사용자는 꼭 검토를 해야하기 때문입니다.</p>

<p>놀라운 것은 불과 몇달전, 아니 몇주전보다도 점점 AI가 만들어내는 오류가 줄어들고 있다는 것입니다. 이번에 만들어본 extension과 같이 정말 간단한 프로그램의 경우에는 오류를 전혀 발생시키지 않았습니다. 오히려 개발 중간에 제가 수정사항을 요구하거나 좀더 나은 개선 방향을 제시하면 다른 부분과 충돌하지 않으면서 굉장히 빠르게 이를 반영해주는 모습이 보였습니다.</p>

<p>저는 평소에는 windsurf에서 제공하는 탭발사대와 중간중간 개발하면서 이해가 안가거나 귀찮은 작업들을 AI에게 질문하곤 했습니다. 하지만 이번에 claude code를 사용해서 처음부터 끝까지 개발해보니 생각보다 간단한 작업들에 대해서 AI의 도움을 받으니 편리하다는 생각이 들었습니다. 예전에는 새로운 언어나 플랫폼을 학습하고 이를 익숙하게 사용하기까지 시간이 필요했다면, 이제는 전체적인 흐름과 코드를 읽을 줄 아는 기술만 있다면 새로운 언어나 플랫폼을 사용하더라도 크게 제약이 없는 시대가 오는 것 같았습니다.</p>

<p>물론 이번에도 느꼈지만, 개발자를 완전히 대체하는 것은 어려워보입니다. 우선 개발 단계마다 요청자가 잘 이해하고 좋은 방향으로 요청하기 위해서는 기본적인 지식, 아니 그 이상의 전문적인 역량이 필요할 것이라는 생각이 들었습니다. 오히려 AI가 코딩이라는 분야를 선택적인 누군가만 할 수 있는 기술이라기 보다, 인간이 사용할 수 있는 하나의 언어로써 좀더 친숙하게 다가오게 만드는 계기가 되었으면 좋겠다는 생각도 들었습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[HHKB 배열의 키보드는 구매했는데, 모르는 단축어가 나올때마다 웹사이트를 찾는것이 너무 귀찮아서 vim을 설치했다 지웠다만 수없이 반복했습니다. 차라리 vscode에서 단축어를 바로바로 알려줄수만 있으면 좋겠다고 생각해서, claude code를 사용해서 vscode extension을 만들어본 경험을 공유합니다.]]></summary></entry><entry><title type="html">바이브 코딩이란 단어는 적절하지 않다</title><link href="http://localhost:4000/2025/09/16/vibe-coding/" rel="alternate" type="text/html" title="바이브 코딩이란 단어는 적절하지 않다" /><published>2025-09-16T00:00:00+09:00</published><updated>2025-09-16T00:00:00+09:00</updated><id>http://localhost:4000/2025/09/16/vibe-coding</id><content type="html" xml:base="http://localhost:4000/2025/09/16/vibe-coding/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/25">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[바이브 코딩이란 개발자가 생성형 인공지능의 도움을 받아 코드를 작성하는 행위를 일컫는 신조어로 프로그래밍을 할 때 사전에 엄밀한 논리나 설계를 바탕으로 하지 않고 직감과 느낌에 의존한다는 의미로 바이브 코딩이라는 이름이 붙었다. 바이브 코딩이라는 단어는 잘못되었다는 나의 생각을 공유하고싶다.]]></summary></entry><entry><title type="html">개발자라면 이 책을 꼭 읽어보세요</title><link href="http://localhost:4000/2025/09/15/tobe-good-developer/" rel="alternate" type="text/html" title="개발자라면 이 책을 꼭 읽어보세요" /><published>2025-09-15T00:00:00+09:00</published><updated>2025-09-15T00:00:00+09:00</updated><id>http://localhost:4000/2025/09/15/%08tobe-good-developer</id><content type="html" xml:base="http://localhost:4000/2025/09/15/tobe-good-developer/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/24">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[대부분의 개발 서적이 기술에 대해 이야기할 때, 이 책은 좋은 개발자가 되기 위한 태도, 습관, 그리고 일하는 방식에 대해 이야기합니다. 이 책의 핵심 내용을 요약하고 공유합니다.]]></summary></entry><entry><title type="html">백엔드 개발자의 AI로 아주 작은 dApp 만들기</title><link href="http://localhost:4000/2025/09/15/miniamm-dapp-with-ai/" rel="alternate" type="text/html" title="백엔드 개발자의 AI로 아주 작은 dApp 만들기" /><published>2025-09-15T00:00:00+09:00</published><updated>2025-09-15T00:00:00+09:00</updated><id>http://localhost:4000/2025/09/15/miniamm-dapp-with-ai</id><content type="html" xml:base="http://localhost:4000/2025/09/15/miniamm-dapp-with-ai/"><![CDATA[<h2 id="hell-month">Hell-Month</h2>

<p>Hell-Month는 Web3 커뮤니티 빌더이자 개발자인 <a href="https://www.linkedin.com/posts/7oelm_%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%A1%B0%EC%97%98%EA%B3%BC-web3-%EC%82%BD%EC%A7%88-activity-7360115833097908225-HMuM?utm_source=share&amp;utm_medium=member_desktop&amp;rcm=ACoAACX_74kB5FHdEvU5kLzcald4RDFZSjBrrKA">Joel Mun님이 4주 동안 진행한 강의</a> 입니다. Uniswap과 AMM(Autonomous Market Maker)에 대해 배우고 직접 개발까지 해볼 수 있는 소중한 기회였죠.</p>

<p>Uniswap이 무엇인지, AMM은 어떻게 동작하고 왜 필요한지 등 바쁜 와중에도 열정적으로 강의해주시고 직접 과제까지 만들어주셔서 정말 많은 것을 배울 수 있었습니다. 이 글을 쓰는 시점에도 아직 강의와 과제가 남아있지만, 가장 최근에 진행한 dApp 만들기 과제를 통해 느낀 점을 먼저 정리하고 싶었습니다.</p>

<p>결과물은 <a href="https://github.com/wnjoon/cohort-1-assignments-public/tree/assignment-4/4">github</a>에 올려두었습니다.</p>

<h2 id="넘지-못했던-벽-프론트엔드">넘지 못했던 벽, 프론트엔드</h2>

<p>비개발자들은 ‘어차피 다 같은 개발 아니야?’라고 생각할지 모르지만, 프론트엔드와 백엔드는 정말 다른 세계입니다. 뛰어난 풀스택(Full Stack) 개발자가 되려면 두 배, 아니 그 이상의 노력이 필요하죠. 대부분의 직장인 개발자는 둘 중 하나의 영역에 속해있지만, 개인 서비스를 만들고 싶다면 두 분야를 모두 알아야만 합니다.</p>

<p>저 역시 서비스 개발자가 되고 싶다는 생각에 여러 번 프론트엔드에 도전했습니다. 하지만 당장 업무에 쓰는 백엔드 기술 하나만 제대로 파고들기에도 벅찬 현실 속에서, 사용하지도 않는 프론트엔드를 개념부터 공부하기란 쉽지 않았습니다.</p>

<p>과거 갑작스러운 프로젝트 투입으로 프론트엔드를 경험했던 후배가 혼자서 서비스를 뚝딱 만들어내는 모습을 보며 부러워했던 기억이 납니다. 당시에는 원치 않는 업무를 맡아 힘들어하는 후배가 안쓰럽기만 했는데, 돌이켜보면 역시 개발자는 직접 부딪쳐야 성장한다는 것을 그 친구를 통해 깨달을 수 있었습니다.</p>

<h2 id="ai로-프론트엔드를-띄워보다">AI로 프론트엔드를 띄워보다</h2>

<p>개인적으로 프론트엔드 개발이 AI의 도움을 받기 좋은 이유는 다음과 같다고 생각합니다.</p>

<ul>
  <li>정형화된 패턴: 사람들이 선호하는 웹사이트의 화면 구성과 기능은 대부분 비슷합니다.</li>
  <li>풍부한 학습 데이터: AI는 수많은 웹사이트를 학습해 가장 보편적이고 효율적인 방법을 제안할 수 있습니다.</li>
  <li>발전하는 개발 도구: 배포와 관리를 쉽게 해주는 도구들이 계속해서 등장하고 있습니다.</li>
</ul>

<p>결론적으로 AI를 이용하면 ‘남들이 만드는 것과 비슷한 웹사이트’는 충분히 만들 수 있다는 것이죠. 마침 이번 Hell-Month의 과제가 <strong>‘AI를 활용해 AMM 기반 dApp 개발하기’</strong>였기에, 제대로 AI를 이용해보기로 마음먹었습니다.</p>

<p>참고로 제가 사용하고 있는 AI 도구들을 나열해보면,</p>

<ul>
  <li>windsurf: AI 기반 IDE 도구로, 많은 사람들이 cursor를 사용할때 가격이 저렴하다는 이유로 windsurf의 초기버전부터 사용했습니다. 덕분에 아직도 $10의 요금제를 사용하고 있습니다(얼리버드 사용자 특전).</li>
  <li>gemini: 무료 크레딧을 얻게 되어 사용중입니다. 개인적으로 코딩에는 gpt보다 gemini가 더 정확하게 알려주는 것 같습니다. 대신 회화와 같이 실제 사람과의 interaction을 원한다면 gpt가 더 좋을 것 같습니다.</li>
</ul>

<p>추가로 windsurf에서 코딩에 사용한 모델은 claude-sonnet-4입니다. 최근에 claude code를 결제해서 유료버전을 사용해볼까 굉장히 고민하고 있습니다. 아무래도 가격이 비싸고, 저는 실제로 코드를 하나씩 확인하면서 리팩토링하는 것을 주로 업무로 하다보니, 웹서비스를 하나부터 열까지 AI에게 맡길만한 일의 필요성을 느끼지 못하고 있었습니다. 하지만 이번에 진행한 과제에서는 ‘프론트엔드에 대해 전혀 모르는 백엔드 개발자가 미리 만들어놓은 솔리디티 컨트랙트만 가지고 컨텍스트 프로그래밍을 하는 것’이었기 때문에, claude-sonnet-4의 성능을 시험해보고 싶어서 사용했습니다. 물론 현재 시점으로 windsurf에서 claude-sonnet-4는 다른 모델들보다 토큰비용이 2배정도 들어갑니다.</p>

<blockquote>
  <p>opus-4는 훨씬 많은 토큰비용 + 엔트로픽에서 API 키를 별도로 받은 후 비용을 충전해서 사용해야 했기 때문에, 이번 과제를 통해 일명 ‘바이브 코딩’을 테스트해보는 용도로는 적합하지 않다고 판단했습니다. 하지만 이에 대한 생각도 이후에 기술하겠습니다.</p>
</blockquote>

<h2 id="rule-만들기">rule 만들기</h2>

<p>수많은 영상에서 ‘AI 에이전트를 사용하기 전에 먼저 좋은 rule과 컨텍스트를 에이전트에게 주입’할 것을 추천합니다. 최근에 읽었던 책인 <a href="https://product.kyobobook.co.kr/detail/S000215838626">듀얼 브레인</a>에서도, AI에게 더 많이 설명할수록 그 내용을 기반으로 더 풍부한 답변을 줄 수 있다고 언급합니다. 사실 이건 너무 당연한 이야기입니다. AI가 우리의 생각을 읽고 답변할 수 없기 때문에, 우리는 원하는 답변을 얻기 위한 최대한의 정보를 AI에게 제공할 수 있어야 합니다. 그리고 우리가 원하는 방향으로 일이 진행되기 위한 가이드도 제공해야 합니다. 앞에서도 말했지만, AI는 우리의 생각을 읽을 수 없기 때문입니다. 물론 우리같은 사람도 다른 사람의 생각을 읽을 수 없죠.</p>

<p>사실 저는 지금까지 AI를 사용하면서 한번도 rule을 만들어본적은 없습니다. 문제가 있을법한 코드의 위치를 알려주고, 어느 부분에 문제가 있을것 같은지 제 생각을 정리하면서 대화형으로 문제를 해결해갔습니다. 하지만 이번 과제처럼 완전히 무에서 유를 창조하는 일을 AI에게 맡겨보는 것은 처음이었기 때문에, 제대로 rule을 만들어보자고 생각했습니다.</p>

<p>좋은 rule을 만드는 구조는 크게 아래와 같다고 합니다.</p>

<ul>
  <li>서비스 개발의 목적, 원하는 결과물에 대해서 최대한 구체적으로 설명할 수 있어야 한다.</li>
  <li>사용하고자 하는 기술 스택에 대해서 명확하게 정의해야 한다.</li>
  <li>단계별로 업무를 진행할 수 있도록 가이드 해야 한다. AI 또한 이를 명확히 해주지 않으면 여러개의 업무를 마구잡이로 실행할 가능성이 존재하기 때문이다. 그래서 체크박스 등을 통해 하나씩 업무를 해결하고 단계적으로 이를 확인받도록 해야 한다.</li>
  <li>AI가 자동으로 코드를 수정하거나 다음 단계로 넘어갈 수도 있다. 이를 원치 않으면 명확하게 지시할 수 있어야 한다.</li>
</ul>

<p>이 외에도 여러가지가 있었지만, 우선 위의 4가지를 기준으로 아래와 같은 rule을 만들어보았습니다.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># MiniAMM DApp 개발 체크리스트</span>

<span class="gu">## 1단계: 프로젝트 초기 설정</span>
<span class="p">-</span> [x] Next.js + Typescript 프로젝트 생성
<span class="p">-</span> [x] Ethers.js, RainbowKit, Wagmi 등 필수 라이브러리 설치
<span class="p">-</span> [x] TypeChain 설치 및 ABI로부터 타입스크립트 연동을 위한 설정
<span class="p">-</span> [x] 각 컨트랙트 주소를 관리하기 위한 <span class="sb">`static`</span> 변수 또는 환경변수 파일 설정

<span class="gu">## 2단계: 지갑 연결 및 기본 UI 구성</span>
<span class="p">-</span> [x] RainbowKit을 사용한 지갑 연결 버튼 및 기능 구현
<span class="p">-</span> [x] 지갑이 연결되지 않았을 때의 초기 화면 구성
<span class="p">    -</span> [x] MiniAMM의 전체 유동성(TokenA, TokenB 수량) 표시
<span class="p">-</span> [x] 지갑 연결 후 사용자 정보 표시 UI 추가
<span class="p">    -</span> [x] 사용자의 TokenA, TokenB 보유량 표시
<span class="p">    -</span> [x] 사용자의 LP 토큰 보유량 표시
<span class="p">-</span> [x] 트랜잭션 오류 메시지를 보여줄 UI 공간 확보

<span class="gu">## 3단계: Mock 토큰 발행 기능 구현</span>
<span class="p">-</span> [x] TokenA, TokenB를 각각 발행할 수 있는 UI (입력창, 발행 버튼) 구현
<span class="p">-</span> [x] '발행' 버튼 클릭 시 MockERC20 컨트랙트의 <span class="sb">`freeMintToSender`</span> 함수 호출 로직 구현
<span class="p">-</span> [x] 토큰 발행 후 사용자의 토큰 보유량 실시간 업데이트
<span class="p">-</span> [x] 발행 과정에서 발생하는 오류 처리 및 메시지 표시

<span class="gu">## 4단계: 유동성 공급 기능 구현</span>
<span class="p">-</span> [x] 공급할 TokenA, TokenB의 수량을 입력할 수 있는 UI 구현
<span class="p">-</span> [x] '유동성 공급' 버튼 클릭 시 MiniAMM 컨트랙트의 <span class="sb">`addLiquidity`</span> 함수 호출 로직 구현
<span class="p">-</span> [x] 유동성 공급 후 사용자의 LP 토큰 보유량 및 전체 유동성 ㅁ실시간 업데이트
<span class="p">-</span> [x] 유동성 공급 과정에서 발생하는 오류(예: 보유량 부족) 처리 및 메시지 표시
<span class="p">-</span> [x] 자동 approve 기능: 버튼 클릭 시 필요한 토큰 승인을 자동으로 처리
<span class="p">-</span> [x] 잔액 검증: 트랜잭션 실행 전 사용자 토큰 보유량 확인 및 부족 시 오류 표시
<span class="p">-</span> [x] 단계별 진행 상황 표시: approve → add liquidity 과정을 사용자에게 명확히 안내

<span class="gu">## 5단계: 스왑 기능 구현</span>
<span class="p">-</span> [x] 스왑할 토큰 종류(A→B, B→A) 선택 및 수량 입력 UI 구현
<span class="p">-</span> [x] 입력된 수량에 따라 예상되는 스왑 결과 수량을 실시간으로 계산하여 표시
<span class="p">-</span> [x] '스왑' 버튼 클릭 시 MiniAMM 컨트랙트의 <span class="sb">`swap`</span> 함수 호출 로직 구현
<span class="p">-</span> [x] 트랜잭션 처리 중 '스왑' 버튼 비활성화 처리
<span class="p">-</span> [x] 스왑 완료 후 사용자의 토큰 보유량 및 전체 유동성 실시간 업데이트
<span class="p">-</span> [x] 스왑 과정에서 발생하는 오류 처리 및 메시지 표시

<span class="gu">## 6단계: 유동성 해제 기능 구현</span>
<span class="p">-</span> [x] 해제할 LP 토큰의 수량을 입력할 수 있는 UI 구현
<span class="p">-</span> [x] '유동성 해제' 버튼 클릭 시 MiniAMM 컨트랙트의 <span class="sb">`removeLiquidity`</span> 함수 호출 로직 구현
<span class="p">-</span> [x] 트랜잭션 처리 중 '해제' 버튼 비활성화 처리
<span class="p">-</span> [x] 유동성 해제 완료 후 사용자의 토큰/LP 보유량 및 전체 유동성 실시간 업데이트
<span class="p">-</span> [x] 유동성 해제 과정에서 발생하는 오류 처리 및 메시지 표시

<span class="gu">## 7단계: 배포</span>
<span class="p">-</span> [x] Cloudflare Pages를 통한 웹 애플리케이션 배포 준비
<span class="p">-</span> [x] Next.js 정적 빌드 설정 (output: 'export')
<span class="p">-</span> [x] TypeScript 오류 수정 (any → unknown 타입 변경)
<span class="p">-</span> [x] Wrangler CLI 설치 및 Cloudflare 인증
<span class="p">-</span> [x] Cloudflare Pages 프로젝트 생성 (miniamm-dapp)
<span class="p">-</span> [x] 최종 테스트 및 배포 완료

<span class="gs">**배포 결과:**</span>
<span class="p">-</span> 메인 도메인: https://miniamm-dapp.pages.dev ✅ (정상 동작)
<span class="p">-</span> 배포 URL: https://27e7e9a0.miniamm-dapp.pages.dev ⚠️ (SSL 오류 - 정상적인 현상)
<span class="p">-</span> 업로드된 파일: 200개
<span class="p">-</span> 배포 상태: 성공
</code></pre></div></div>

<p>위의 내용은 제가 최종적으로 개발을 마무리한 결과입니다. 총 7단계로 개발범위를 나누어보았고, 각 단계별로 소항목을 체크박스 형식으로 구성해서 하나씩 해결할때마다 체크박스에 표시하도록 했습니다.</p>

<p>체크박스 형식을 사용하게 된 가장 큰 이유중 하나는, AI의 기억력에 한계가 있기 때문이었습니다. 자신이 이제까지 진행한 내용을 글로 남겨놓았기 때문에, 항상 이 파일을 기준으로 진행시켜서 이미 완료된 업무를 중복해서 진행함으로 토큰을 낭비하지 않게 했습니다. 추가로 각 단계별로 완료될때마다 저에게 최종적인 확인을 받도록 했는데요, 이렇게 했음에도 불구하고 중간에 자기 마음대로 다음 단계로 넘어가서 기능을 구현하는 경우도 있었습니다. 이부분을 막기 위한 더 좋은 컨텍스트 작성 방법이 있는지 확인해야겠다고 생각했습니다.</p>

<p>또한 각 단계가 마무리될때마다 꼭 커밋을 해야겠더라구요. 간혹 AI가 이미 잘 작성되어서 확인이 끝난 기능임에도 불구하고, 다음 단계의 기능을 개발하면서 이전에 개발완료된 기능을 자기 마음대로 고치는 경우도 있었습니다. 코드의 갯수가 많아질수록 사용자가 예측하지 못한 변경이 발생해서 프로그램이 잘못되는 경우, 어디서 문제가 발생했는지 추적하는게 어려웠습니다. 가장 좋은 방식은 개발 단계마다 최대한 많은 횟수로 커밋을 하면 좋겠지만, 이러면 너무 많은 히스토리가 남아서 오히려 추적을 방해할 수도 있다 생각했습니다. 그래서 각 단계별로 완료될때마다 커밋을 직접 했습니다. 나중에 컨텍스트 작성 능력이 더 발전하면, AI가 직접 커밋을 하도록 하는것도 좋을것 같았습니다.</p>

<h2 id="사용-후기">사용 후기</h2>

<p>실제로 사용해본 결과 위의 단계 중 6단계까지는 거의 실수없이 개발을 완료했습니다. 단계별로 테스트하면서 제가 예상했던 것과 다른 결과가 나오는 경우, 에러 메시지와 함께 원하는 결과를 잘 설명해주면 거의 1-2번만에 에러를 해결해주는 모습도 보여줬습니다.</p>

<p>하지만 배포처럼 외부 서비스를 이용하는 작업에는 약간의 가이드가 필요했습니다. 저는 Cloudflare Pages를 이용해 배포하려 했는데, 제 경험 부족도 있었지만 AI가 계속해서 ERR_SSL_VERSION_OR_CIPHER_MISMATCH 오류를 뿜어내며 해결하지 못해 한참 애를 먹었습니다. 나중에 알고 보니, 이 SSL 오류는 Cloudflare Pages 배포 시 일시적으로 발생할 수 있는 일반적인 현상이었습니다. 메인 도메인이 정상 작동하면 배포는 성공한 것이었죠.</p>

<p>재미있는 것은, 위의 내용을 알려준것도 AI였다는 것입니다. 계속 오류가 해결되지 않아서 코드를 이전 단계를 완료한 버전으로 되돌리고, 새로운 AI 창을 열어서 다시 대화를 시도했습니다. 이전 단계까지 완료되었다는 체크박스를 확인해서 다시 배포를 시도해보도록 했습니다. AI가 자신이 진행했던 히스토리를 복기할 수 있도록 문서를 유지하는 것의 중요성을 다시 알 수 있었고, AI도 항상 동일한 결과를 만들어내지 못하기 때문에, 얼만큼 더 많은 정보를 제공하느냐가 확실히 중요한 부분이라는 것을 알았습니다.</p>

<p>추가로 이번 과제를 통해 ‘일반 사용자들이 생각하고 구현하고자 하는 서비스는 거의 AI를 이용해서 만들어낼 수 있겠다’는 생각이 들었습니다. 복잡한 시스템인 경우에는 좀더 시도해봐야겠지만, 왠만한 기능 구현은 AI를 이용해서 할 수 있었습니다. 다만, 많은 사람들이 이야기하는 ‘바이브코딩에 대한 현실의 자각’은 필요한 것으로 보였습니다. IT에 대해 지식이 전혀 없거나, 혹은 지식이 부족한 사람들의 경우에는 아무리 AI가 서비스를 만들어준다 하더라도 이걸 확인하는 것이 어려울 것 같았습니다. 결국 ‘제대로 일하고 있는지 검토하는 능력’이 확실히 필요해보였습니다. 하나의 기술에 대한 깊은 이해도를 가진 사람이 되는것이 예전에는 중요했다면, 지금은 내가 개발하고자 하는 서비스에 필요한 기능을 빠르게 선택하고 새로운 기능을 빠르게 이해해서 AI에게 다양한 선택지와 정보를 풍부하게 제공할 수 있는 사람이 되는것이 중요한 시대가 되어가고 있다 생각했습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[프론트엔드에 대해 전혀 모르는 백엔드 개발자가 AI만 사용해서 매우 작은 AMM 기반 dApp을 개발해보는 과정을 정리했습니다. 이 모든 과정은 Hell-Month라고 하는 단기 프로젝트에서 진행하였습니다.]]></summary></entry><entry><title type="html">스테이블코인에 대한 개인적인 생각</title><link href="http://localhost:4000/2025/09/12/thoughts-stable-coin/" rel="alternate" type="text/html" title="스테이블코인에 대한 개인적인 생각" /><published>2025-09-12T00:00:00+09:00</published><updated>2025-09-12T00:00:00+09:00</updated><id>http://localhost:4000/2025/09/12/thoughts-stable-coin</id><content type="html" xml:base="http://localhost:4000/2025/09/12/thoughts-stable-coin/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/23">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="crypto" /><summary type="html"><![CDATA[CBDC, 토큰증권을 개발한 블록체인 개발자로서 스테이블코인을 바라보는 개인적인 생각을 정리했습니다.]]></summary></entry><entry><title type="html">컨텍스트 엔지니어링: AI를 효과적으로 사용하는 방법</title><link href="http://localhost:4000/2025/08/14/context-engineering/" rel="alternate" type="text/html" title="컨텍스트 엔지니어링: AI를 효과적으로 사용하는 방법" /><published>2025-08-14T00:00:00+09:00</published><updated>2025-08-14T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/14/context-engineering</id><content type="html" xml:base="http://localhost:4000/2025/08/14/context-engineering/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/22">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[AI의 이해 능력과 생성 능력 사이의 비대칭성을 설명하고, '프롬프트 엔지니어링'을 넘어 AI의 잠재력을 최대한 활용하기 위한 '컨텍스트 엔지니어링'의 개념, 핵심 단계(검색, 처리, 관리), 그리고 이를 바탕으로 한 최적의 AI 활용 방법을 제시합니다.]]></summary></entry><entry><title type="html">스테이블코인의 현주소: 시장의 구성과 주요 플레이어</title><link href="http://localhost:4000/2025/08/07/stable-coin/" rel="alternate" type="text/html" title="스테이블코인의 현주소: 시장의 구성과 주요 플레이어" /><published>2025-08-07T00:00:00+09:00</published><updated>2025-08-07T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/07/stable-coin</id><content type="html" xml:base="http://localhost:4000/2025/08/07/stable-coin/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/21">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="crypto" /><summary type="html"><![CDATA[2025년 기준, 스테이블코인의 정의와 1달러 가치를 유지하는 차익거래 원리, 시장 발전 과정, USDT·USDC 등 주요 플레이어 분석 및 미래 전망을 다룹니다.]]></summary></entry><entry><title type="html">SQLite FTS의 토크나이저와 인덱싱에 대해서</title><link href="http://localhost:4000/2025/08/06/sql-fts5/" rel="alternate" type="text/html" title="SQLite FTS의 토크나이저와 인덱싱에 대해서" /><published>2025-08-06T00:00:00+09:00</published><updated>2025-08-06T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/06/sql-fts5</id><content type="html" xml:base="http://localhost:4000/2025/08/06/sql-fts5/"><![CDATA[<h2 id="목차">목차</h2>

<ul>
  <li><a href="#전문-검색full-text-search이란">전문 검색(Full-Text Search)이란?</a></li>
  <li><a href="#fts는-어떻게-동작하나요">FTS는 어떻게 동작하나요?</a></li>
  <li><a href="#좀더-자세히-알아보기">좀더 자세히 알아보기</a></li>
  <li><a href="#fts의-장점">FTS의 장점</a></li>
</ul>

<h2 id="전문-검색full-text-search이란">전문 검색(Full-Text Search)이란?</h2>

<p>우리가 구글에서 “오늘 서울 날씨”라고 검색하면, 구글은 어떻게 요청 데이터를 처리할까요?
아마도 구글은 ‘오늘’, ‘서울’, ‘날씨’라는 단어가 포함된 수많은 웹페이지 중에서 가장 관련성 높은 문서를 찾아서 보여줄겁니다.</p>

<p>이처럼, 전문 검색(Full-Text Search)은 단순히 문자가 완전히 일치하는지(예: <code class="language-plaintext highlighter-rouge">LIKE '%검색어%'</code>)를 확인하는 것을 넘어, <strong>문장이나 문단 전체에서 특정 단어나 구문이 포함된 문서를 빠르고 효율적으로 찾아주는 기술</strong>입니다. 
일반적인 데이터베이스 검색(예: <code class="language-plaintext highlighter-rouge">WHERE title = '검색어'</code>)이 책의 ‘목차’에서 제목을 찾는 것이라면, 전문 검색은 일반적으로 책의 맨 뒤에서 볼 수 있는 ‘찾아보기(인덱스)’를 이용해 본문 내용 안에서 단어를 찾는 것과 같습니다.</p>

<p>SQLite 데이터베이스는 이 ‘전문 검색’ 기능을 사용할 수 있도록 해주는 강력한 확장 기능(extension)인 FTS를 제공합니다. ‘FTS’는 Full-Text Search의 약자이고, 뒤에 숫자로 버전을 명시합니다. 예를 들어 FTS5라는 것은 5번째 버전을 의미합니다. <strong>앞으로 설명할 FTS는 FTS5를 의미합니다.</strong></p>

<h2 id="fts는-어떻게-동작하나요">FTS는 어떻게 동작하나요?</h2>

<p>FTS는 일반적인 검색보다 훨씬 빠르고 효율적으로 동작하기 위해, 아래와 같은 과정을 거칩니다.</p>

<h3 id="1-가상-테이블virtual-table-생성">1. 가상 테이블(Virtual Table) 생성</h3>

<p>전문 검색을 할 텍스트 데이터(예: 상품 설명)를 일반 테이블이 아닌 FTS 전용의 ‘가상 테이블(VIRTUAL)’에 저장합니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 'product_fts' 라는 이름의 FTS5 가상 테이블을 생성</span>
<span class="k">CREATE</span> <span class="n">VIRTUAL</span> <span class="k">TABLE</span> <span class="n">product_fts</span> <span class="k">USING</span> <span class="n">fts5</span><span class="p">(</span>
    <span class="n">Name</span><span class="p">,</span>         <span class="c1">-- 상품명</span>
    <span class="n">Description</span>   <span class="c1">-- 상품설명</span>
    <span class="c1">-- , tokenize = 'porter' -- (옵션) 추가적인 토크나이저 설정</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="2-토큰화tokenization">2. 토큰화(Tokenization)</h3>

<p>FTS5 테이블에 텍스트를 저장하면, FTS5는 이 텍스트를 의미 있는 최소 단위의 단어, 즉 <strong>‘토큰(token)’</strong>으로 분해합니다. 예를 들어, “최고의 서울 야경 투어”라는 문장은 ‘최고’, ‘서울’, ‘야경’, ‘투어’ 같은 토큰으로 쪼개지는데, 이 과정에서 ‘의’ 같은 조사는 보통 무시됩니다.</p>

<h3 id="3-인덱싱indexing">3. 인덱싱(Indexing)</h3>

<p>앞에서 쪼개진 토큰들을 바탕으로 ‘역인덱스(inverted index)’라는 특별한 목록을 만듭니다. 이 목록에는 어떤 단어(토큰)가 어떤 문서(row)에 나타나는지에 대한 정보가 기록됩니다.</p>

<p>예를 들어, ‘서울’이 포함된 문서 목록(1, 5, 12)과 ‘야경’이 포함된 문서 목록(1, 7)을 찾아서 아래와 같이 매핑합니다.</p>

<ul>
  <li>‘서울’ -&gt; 1번, 5번, 12번 문서에 있음</li>
  <li>‘야경’ -&gt; 1번, 7번 문서에 있음</li>
</ul>

<h3 id="4-검색search">4. 검색(Search)</h3>

<p>사용자가 <code class="language-plaintext highlighter-rouge">MATCH</code> 연산자를 사용해 “서울 야경”이라고 검색하면, FTS는 앞에서 생성한 역인덱스를 이용해서 ‘서울’과 ‘야경’이 포함된 문서를 빠르게 찾아냅니다. 그리고 두 목록에 공통으로 존재하는 문서를 최종 결과로 반환합니다.</p>

<h2 id="좀더-자세히-알아보기">좀더 자세히 알아보기</h2>

<p>아래와 같이 다양한 옵션을 사용해서 가상 테이블을 설정해봅시다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="n">VIRTUAL</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">USING</span> <span class="n">FTS5</span><span class="p">(</span>
    <span class="n">id</span> <span class="n">UNINDEXED</span><span class="p">,</span>
    <span class="n">sub_id</span><span class="p">,</span>
    <span class="k">comment</span><span class="p">,</span>
    <span class="n">field</span> <span class="n">UNINDEXED</span><span class="p">,</span>
    <span class="nb">text</span><span class="p">,</span>
    <span class="k">prefix</span> <span class="o">=</span> <span class="s1">'1 2 3'</span><span class="p">,</span>
    <span class="n">tokenize</span> <span class="o">=</span> <span class="s1">'unicode61 remove_diacritics 2'</span>
<span class="p">)</span>
</code></pre></div></div>

<p>먼저 결론을 말씀드리면, 이 명령어를 통해 대소문자를 무시하고, 발음 기호를 제거하며, 공백/문장부호로 단어를 나누는 규칙으로 sub_id, comment, text 컬럼의 내용을 토큰으로 만들어 저장하는 FTS 테이블을 생성합니다.</p>

<h3 id="검색-대상-컬럼-선정">검색 대상 컬럼 선정</h3>

<p>일부 필드에는 UNINDEXED라는 옵션이 붙어있는 것을 볼수 있는데요, 이 옵션이 붙어있는 컬럼은 테이블에 저장되기는 하지만 전문 검색의 대상이 되지는 않습니다. 즉, MATCH 연산자를 사용해서 이 컬럼들을 검색할 수 없습니다.</p>

<ul>
  <li>검색 대상: sub_id, comment, text</li>
  <li>검색 비대상: id, field</li>
</ul>

<p>검색 대상 컬럼에 있는 텍스트는 토큰으로 분해되어 검색용 인덱스로 만들어집니다.</p>

<h3 id="토큰화tokenization">토큰화(Tokenization)</h3>

<p>토큰화(Tokenization)는 바로 <code class="language-plaintext highlighter-rouge">tokenize</code> 옵션에 의해 결정됩니다. 코드를 보면 <code class="language-plaintext highlighter-rouge">unicode61 remove_diacritics 2</code>라는 옵션이 붙어있는 것을 볼 수 있습니다. 이 옵션은 2가지 옵션을 포함하고 있습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">unicode61</code></strong></p>

<p>사용할 토크나이저(Tokenizer, 분해기)의 이름입니다. 이름 그대로 유니코드 6.1 표준에 정의된 규칙에 따라 텍스트를 단어로 분해합니다. 이 분해기는 크게 2가지 특징을 가지고 있습니다.</p>

<ol>
  <li>Case-insensitive: 대소문자를 구분하지 않습니다. Apple, apple, APPLE은 모두 같은 토큰 ‘apple’로 처리됩니다.</li>
  <li>Separator: 공백(space), 마침표(.), 쉼표(,) 등 문장 부호를 기준으로 단어를 나눕니다.</li>
</ol>

<p><strong><code class="language-plaintext highlighter-rouge">remove_diacritics 2</code></strong></p>

<p>토크나이저에 전달하는 추가 옵션입니다. 여기서 diacritic은 발음 구별 기호(예: é, ü, ñ)를 의미하고, 결국 앞에 remove가 붙었다는 것은 발음 기호를 제거하라는 옵션이 됩니다.</p>

<p>예를 들어,</p>

<ul>
  <li>résumé -&gt; resume로,</li>
  <li>café -&gt; cafe</li>
</ul>

<p>로 변환되어 토큰으로 만들어집니다.</p>

<p>그럼 뒤에 숫자는 무엇을 의미할까요? 이러한 기능을 처리하는 내부적인 알고리즘의 버전을 의미합니다. 즉 2버전을 기반으로 발음 기호를 제거하라는 옵션입니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">prefix</code></strong></p>

<p>단어의 앞부분만으로도 빠르게 검색할 수 있도록 <strong>접두어 인덱스(prefix index)</strong>를 만듭니다. ‘1 2 3’의 의미는 한 글자, 두 글자, 세 글자짜리 접두어에 대한 인덱스를 미리 만들어두겠다는 뜻입니다.</p>

<p>예를 들어, apple이라는 단어가 있다면 a, ap, app에 대한 인덱스가 생성됩니다. 이를 통해 사용자는 ‘app’ 까지만 입력해도 apple을 매우 빠르게 찾아낼 수 있습니다.</p>

<p>자동완성 기능이라고 생각하시면 이해하기 좋습니다.</p>

<h3 id="예시-1-영어-텍스트-토큰-분해-과정">예시 1. 영어 텍스트 토큰 분해 과정</h3>

<p><strong>원본 텍스트 저장</strong></p>

<p>“The best Café in Seoul is near City Hall.” 라는 원본 텍스트가 있다고 가정합니다. 이 텍스트는 <code class="language-plaintext highlighter-rouge">text</code> 컬럼에 저장됩니다.</p>

<p><strong>토큰화 과정</strong></p>

<p>unicode61 토크나이저는 대소문자를 통합하고 문장 부호를 기준으로 단어를 나눕니다.</p>

<p>결과로 [the, best, café, in, seoul, is, near, city, hall]이 생성됩니다.</p>

<p><strong>발음 기호 제거</strong></p>

<p>remove_diacritics 옵션은 발음 기호를 제거합니다. café -&gt; cafe</p>

<p>결과로 [the, best, cafe, in, seoul, is, near, city, hall]이 생성됩니다.</p>

<p><strong>접두어 인덱스 생성</strong></p>

<p>단어의 앞부분만으로도 빠르게 검색할 수 있도록 접두어 인덱스(prefix index)를 만듭니다.</p>

<p>위에서 prefix 뒤에 붙은 ‘1 2 3’의 의미는 한 글자, 두 글자, 세 글자짜리 접두어에 대한 인덱스를 미리 만들어두겠다는 뜻입니다.</p>

<p>예를 들어, apple이라는 단어가 있다면 a, ap, app에 대한 인덱스가 생성됩니다. 덕분에 사용자가 ‘app’까지만 입력해도 apple을 매우 빠르게 찾아낼 수 있습니다. 자동완성과 동일한 기능이라고 볼 수 있습니다.</p>

<h3 id="예시-2-한글-텍스트-토큰-분해-과정">예시 2. 한글 텍스트 토큰 분해 과정</h3>

<p><strong>원본 텍스트 저장</strong></p>

<p>“최고의 서울 야경 투어!”라는 원본 텍스트가 있습니다. 이 텍스트 또한 <code class="language-plaintext highlighter-rouge">text</code> 컬럼에 저장됩니다.</p>

<p><strong>토큰화 과정</strong></p>

<p>여기서 중요한 점이 있습니다. <strong><code class="language-plaintext highlighter-rouge">unicode61</code> 토크나이저는 한글의 형태소(명사, 조사 등)를 분석하는 기능이 없기 때문에, 공백과 문장 부호를 기준으로만 단어를 나눕니다.</strong></p>

<p>그러므로 최종 생성 토큰은 [최고의, 서울, 야경, 투어]가 됩니다.</p>

<p>이때 사용자가 ‘최고’라고 검색하면 어떻게 될까요? 토큰으로 저장된 결과는 ‘최고의’뿐이므로, ‘최고’라는 토큰을 찾을 수 없게 됩니다. 이것이 <code class="language-plaintext highlighter-rouge">unicode61</code> 토크나이저를 한글에 사용할 때의 한계점입니다.
그래서 일반적으로 더 정확한 한글 검색을 위해서는 별도의 한글 형태소 분석기를 FTS에 연동합니다.</p>

<p>그렇다면 궁금한 점이 생깁니다. 위에서 prefix해서 인덱스를 추가로 생성할 수 있다고 했는데, 그러면 ‘최고의’ 토큰은 [‘최’, ‘최고’, ‘최고의’] 인덱스를 가지게 되니까 ‘최고’를 검색할 때도 ‘최고의’를 찾을 수 있게 되는 거 아닌가?</p>

<p>결론부터 말씀드리면, 아쉽게도 그렇게 동작하지 않습니다.</p>

<p>이유를 명확히 이해하려면 <strong>토큰화(Tokenization)</strong>와 <strong>접두어 인덱싱(Prefix Indexing)</strong>의 역할을 정확하게 이해해야 합니다.</p>

<p>FTS에서 가장 먼저 일어나는 일은 입력된 텍스트에서 ‘단어(토큰)’가 무엇인지 정의하는 것입니다.</p>

<p>위에서 <code class="language-plaintext highlighter-rouge">unicode61</code>은 공백을 기준으로 단어를 나누므로, FTS는 이 텍스트에 최고의, 서울, 야경 이라는 3개의 단어(토큰)만 존재한다고 인식하고 저장합니다. 이 시점에서 FTS의 ‘단어 사전’에는 최고의라는 단어는 있지만, 최고라는 단어는 존재하지 않습니다. 토크나이저가 그렇게 정의했기 때문입니다.</p>

<p>이 다음에 진행되는 prefix (접두어 인덱싱)은 “결정된 단어를 빨리 찾기 위한 ‘색인’ 추가”의 역할을 합니다. 중요한 점은 <strong>‘생성된 색인이 토큰이 되지는 않는다’</strong>는 것입니다. 특정 토큰으로 이동할 수 있는 지름길을 만드는 것이지, 이미 만들어진 토큰을 글자수 단위로 더욱 세밀하게 쪼개서 토큰으로 생성하라는 의미가 아닙니다.</p>

<ul>
  <li>최고의라는 토큰에 대해: [최 -&gt; 최고의], [최고 -&gt; 최고의]로 가는 지름길을 만듭니다.</li>
  <li>서울이라는 토큰에 대해: [서 -&gt; 서울], [서울 -&gt; 서울]로 가는 지름길을 만듭니다.</li>
  <li>야경이라는 토큰에 대해: [야 -&gt; 야경], [야경 -&gt; 야경]로 가는 지름길을 만듭니다.</li>
</ul>

<p>그러므로 최나 최고가 독립적인 단어로 사전에 추가되는 것이 아니라, 오직 ‘최고의’라는 원본 단어를 더 빨리 찾기 위한 ‘색인’ 또는 ‘포인터’의 역할만 하게 됩니다.</p>

<h3 id="검색-시-어떻게-동작하는가">검색 시 어떻게 동작하는가?</h3>

<p>한글 텍스트를 기준으로 사용자가 검색을 시도하였을 때 어떻게 동작하는지 알아보겠습니다.</p>

<p><strong>CASE 1: … <code class="language-plaintext highlighter-rouge">MATCH '최고'</code> 라고 검색한 경우</strong></p>

<p>FTS는 단어 사전에서 최고라는 토큰이 완벽하게 일치하는 항목이 있는지 먼저 찾습니다. 하지만 단어 사전에는 ‘최고의’만 있을 뿐 ‘최고’라는 단어는 없습니다.</p>

<p>이때 접두어 인덱스는 사용되지 않는데요, 오직 <code class="language-plaintext highlighter-rouge">*</code> 와 함께 사용될 때만 접두어 인덱스는 활성화됩니다.</p>

<p>그러므로 결과적으로 문서를 찾지 못합니다.</p>

<p><strong>CASE 2: … <code class="language-plaintext highlighter-rouge">MATCH '최고*'</code> 라고 검색한 경우</strong></p>

<p>FTS는 검색어 끝에 <code class="language-plaintext highlighter-rouge">*</code>가 붙은 것을 보고, 접두어 인덱스를 활용한 검색을 수행합니다. 접두어 인덱스를 확인한 결과, ‘최고’라는 단어가 ‘최고의’ 토큰을 가리키는 지름길로 등록되어있음을 확인합니다.</p>

<p>이 지름길이 가리키는 ‘최고의’ 토큰이 포함된 문서를 찾아 성공적으로 반환합니다.</p>

<h2 id="fts의-장점">FTS의 장점</h2>

<p>일반적으로 사용되는 <code class="language-plaintext highlighter-rouge">WHERE content LIKE '%검색어%'</code> 방식과 FTS 방식을 간단하게 비교해보면, FTS 방식이 훨씬 빠르고 효율적이라는 것을 알 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>FTS (MATCH)</th>
      <th>일반 검색 (LIKE)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>속도</td>
      <td>매우 빠름. 미리 만들어 둔 인덱스를 사용해 검색하기 때문에 데이터가 수십만 건이 되어도 성능 저하가 거의 없습니다.</td>
      <td>매우 느림. 테이블의 모든 데이터를 하나씩 처음부터 끝까지 다 읽어서 비교(Table Full Scan)하기 때문에 데이터가 많아지면 속도가 급격히 느려집니다.</td>
    </tr>
    <tr>
      <td>정확도/기능</td>
      <td>- 단어(토큰) 단위로 검색하여 더 정확합니다.<br />- AND, OR, NOT 등 논리 연산이 가능합니다.<br />- “서울 야경”처럼 여러 단어가 가까이 있는 문서를 찾는 NEAR 검색도 가능합니다.<br />- 검색 결과의 관련도 순으로 정렬(rank)할 수 있습니다.</td>
      <td>- 단순히 문자열 포함 여부만 체크합니다.<br />- 복잡한 조건의 검색이 어렵습니다.</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[FTS5는 SQLite 데이터베이스에서 바로 이 '전문 검색' 기능을 사용할 수 있도록 해주는 강력한 확장 기능(extension)입니다. 'FTS'는 Full-Text Search의 약자입니다.]]></summary></entry><entry><title type="html">채권 가격과 금리의 관계: 왜 반대로 움직일까?</title><link href="http://localhost:4000/2025/08/03/interest-rate-bonds/" rel="alternate" type="text/html" title="채권 가격과 금리의 관계: 왜 반대로 움직일까?" /><published>2025-08-03T00:00:00+09:00</published><updated>2025-08-03T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/03/interest-rate-bonds</id><content type="html" xml:base="http://localhost:4000/2025/08/03/interest-rate-bonds/"><![CDATA[<p><strong>결론: 채권의 수요가 증가하면, 채권 가격이 상승하고 시장 금리가 하락합니다.</strong></p>

<h3 id="채권의-특징">채권의 특징</h3>

<p>채권 시장을 보다 보면 이런 말을 자주 듣게 됩니다. 주식처럼 가격이 오르면 좋은 것 아닌가? 싶은데, 왜 금리는 반대로 움직이는 걸까요? 이 원리를 알기 위해선 먼저 채권의 기본 특징 한 가지를 이해해야 합니다.</p>

<p>채권은 정부(국채)나 회사(회사채)가 자금을 조달하기 위해 발행하는 일종의 ‘차용증서’입니다. 정부는 일반적으로 매달 정기적으로 경쟁입찰을 통해 국채를 발행하고, 회사는 자금이 필요한 시기에 이사회의 결정을 거쳐 비정기적으로 회사채를 발행합니다.</p>

<p>채권의 대표적인 특징은 아래와 같습니다.</p>

<ul>
  <li><strong>채권은 발행 시점에 이자와 총량이 고정</strong>된다는 점입니다.</li>
  <li><strong>한번 발행된 채권은 만기가 되기 전까지 주식처럼 시장에서 자유롭게 거래됩니다.</strong></li>
  <li>채권은 발행될 때 지급하기로 약속한<strong>표면 이자율과 이자액이 절대 변하지 않습니다</strong>.</li>
</ul>

<p>특히 마지막 특징인 ‘변하지 않는 표면 이자율과 이자액’이 어떻게 채권 가격과 금리를 반대로 움직이게 만드는지 구체적인 예시로 살펴보겠습니다.</p>

<h3 id="고정된-이자-vs-변동하는-가격">고정된 이자 vs 변동하는 가격</h3>

<p>여기, A회사가 발행한 채권이 있다고 가정해 봅시다.</p>

<ul>
  <li><strong>채권 가격(발행가):</strong> 10,000원</li>
  <li><strong>표면 이자율:</strong> 연 5% (매년 500원의 이자를 지급하기로 약속)</li>
</ul>

<p>이 채권을 발행가인 10,000원에 샀다면, 투자 수익률은 약속 그대로 연 5%입니다.</p>

<p>그런데 이 A회사가 유망하다는 소문이 나면서 채권을 사려는 사람(수요)이 몰렸습니다. 한정된 채권을 사기 위한 경쟁이 붙으면서, 시장 가격이 <strong>10,000원에서 12,000원으로 올랐습니다.</strong></p>

<p>이때 채권의 시장 가격은 12,000원으로 올랐지만, A회사가 지급하기로 약속한 <strong>이자액은 여전히 500원으로 고정</strong>되어 있습니다.</p>

<p>그렇다면 지금 12,000원을 주고 이 채권을 산 사람의 실제 수익률은 어떻게 될까요?</p>

<ul>
  <li><strong>발행 시점 수익률:</strong> 500원 ÷ 10,000원 = <strong>5%</strong></li>
  <li><strong>가격 상승 후 수익률:</strong> 500원 ÷ 12,000원 = <strong>약 4.16%</strong></li>
</ul>

<p>이처럼 채권 가격이 오르니, 투자금 대비 실제 얻게 되는 <strong>‘수익률’은 오히려 떨어졌습니다.</strong> 경제 뉴스에서 말하는 시장 금리는 바로 채권의 실제 수익률을 의미하는 경우가 많습니다. 즉 채권 가격이 오르면서, <strong>금리가 하락(5% → 4.16%)했다고 평가하게 됩니다.</strong></p>]]></content><author><name>Wonjoon</name></author><category term="investment" /><summary type="html"><![CDATA[채권 가격이 오르면 왜 시장 금리는 하락하는지, 그 역학 관계를 설명합니다.]]></summary></entry><entry><title type="html">Go 에러 처리: fmt.Errorf는 언제, 어떻게 사용해야 할까요?</title><link href="http://localhost:4000/2025/06/23/fmt-error-handling/" rel="alternate" type="text/html" title="Go 에러 처리: fmt.Errorf는 언제, 어떻게 사용해야 할까요?" /><published>2025-06-23T00:00:00+09:00</published><updated>2025-06-23T00:00:00+09:00</updated><id>http://localhost:4000/2025/06/23/fmt-error-handling</id><content type="html" xml:base="http://localhost:4000/2025/06/23/fmt-error-handling/"><![CDATA[<h2 id="핵심-요약-tldr">핵심 요약 (TL;DR)</h2>

<ul>
  <li><strong>언제 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 쓰면 안 되나요?</strong>
    <ul>
      <li>라이브러리(예: <code class="language-plaintext highlighter-rouge">backoff.Retry</code>)가 에러의 종류를 파악해야 할 때. <strong>원본 에러를 그대로 반환</strong>해야 라이브러리와의 ‘약속’을 지킬 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>언제 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 써야 하나요?</strong>
    <ul>
      <li>모든 재시도 등 정책적 판단이 끝난 후, 최종적으로 에러를 반환하는 시점. <strong>“재시도 끝에 실패”와 같은 명확한 맥락(Context)을 추가</strong>하기 위해 사용합니다.</li>
    </ul>
  </li>
  <li><strong>가장 중요한 원칙은 무엇인가요?</strong>
    <ul>
      <li><strong>역할 분리</strong>. 에러를 발생시키는 ‘실무자’ 함수와, 그 에러를 받아 정책을 결정하는 ‘매니저’ 함수로 역할을 나누고 각 계층에 맞는 책임을 부여하는 것입니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="질문-1-fmterrorf를-무조건-사용하면-왜-안-되나요">질문 1: <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 무조건 사용하면 왜 안 되나요?</h2>

<p>많은 Go 개발자가 외부 API 호출과 같은 불안정한 작업을 처리할 때 <code class="language-plaintext highlighter-rouge">cenk/backoff</code> 같은 라이브러리로 재시도 로직을 구현합니다. 이때 모든 에러를 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>로 감싸는 실수를 하곤 합니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">doRetry</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span><span class="n">Client</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ...</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">backoff</span><span class="o">.</span><span class="n">Retry</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
		<span class="n">bs</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span> <span class="c">// &lt;-- 여기서는 원본 에러를 그대로 반환</span>
	<span class="p">},</span> <span class="o">...</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="c">// &lt;-- 여기서는 컨텍스트를 추가하여 반환</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"failed after retries %w"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bs</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>결론부터 말하면, <strong>라이브러리가 에러의 종류를 보고 특정 행동(예: 재시도 중단)을 결정해야 할 때, <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>로 에러를 감싸면 원본 에러의 정보가 가려져 라이브러리가 올바르게 동작하지 못하기 때문입니다.</strong></p>

<h2 id="질문-2-어떻게-역할을-분리해야-하나요">질문 2: 어떻게 역할을 분리해야 하나요?</h2>

<p>견고한 에러 처리는 함수의 역할을 ‘실무자’와 ‘매니저’로 명확히 나누는 것에서 시작합니다.</p>

<ul>
  <li>실무자 (<code class="language-plaintext highlighter-rouge">do</code> 함수): 실제 작업을 딱 한 번 수행하고, 그 결과를 가공하지 않은 원본 에러 그대로 보고하는 역할만 합니다.</li>
  <li>매니저 (<code class="language-plaintext highlighter-rouge">doRetry</code> 함수): 실무자의 보고(원본 에러)를 받아 정책적 결정을 내립니다. 예를 들어 ‘일시적 오류’는 재시도, ‘영구적 오류’는 즉시 중단 같은 결정을 합니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">backoff.Retry</code> 라이브러리는 매니저의 ‘비서’와 같습니다. 비서는 실무자가 제출한 원본 에러 보고서에 <code class="language-plaintext highlighter-rouge">backoff.PermanentError</code> 같은 특정 도장이 찍혀 있는지 확인합니다. 만약 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>라는 별도의 봉투에 담아 보고하면, 비서는 중요한 도장을 보지 못하고 재시도하면 안 되는 일에 불필요한 노력을 쏟게 됩니다.</p>

<p>이것이 <code class="language-plaintext highlighter-rouge">backoff.Retry</code> 안에서는 원본 에러(<code class="language-plaintext highlighter-rouge">return err</code>)를 그대로 반환해야 하는 이유입니다. 라이브러리와의 약속(Contract)을 지키는 것이죠.</p>

<h2 id="질문-3-에러에-컨텍스트는-언제-추가해야-가장-좋은가요">질문 3: 에러에 컨텍스트는 언제 추가해야 가장 좋은가요?</h2>

<p>“재시도 끝에 실패했다”와 같은 구체적인 맥락은 <strong>매니저가 모든 정책적 판단을 끝낸 시점</strong>에 추가하는 것이 가장 좋습니다.</p>

<p><code class="language-plaintext highlighter-rouge">doRetry</code> 함수는 <code class="language-plaintext highlighter-rouge">backoff.Retry</code>가 최종적으로 실패했을 때, 비로소 <code class="language-plaintext highlighter-rouge">fmt.Errorf("failed after retries %w", err)</code>를 통해 더 자세한 컨텍스트를 담은 최종 에러를 생성하여 상위 호출자에게 반환합니다.</p>

<blockquote>
  <p><strong>Go 에러 처리 철학</strong>: 에러가 발생한 가장 낮은 수준에서는 원본을 유지하고, 계층을 따라 올라오며 각 계층의 역할에 맞는 컨텍스트를 추가합니다.</p>
</blockquote>

<h2 id="질문-4-defer를-사용할-때-에러는-어떻게-처리해야-하나요">질문 4: <code class="language-plaintext highlighter-rouge">defer</code>를 사용할 때 에러는 어떻게 처리해야 하나요?</h2>

<p><code class="language-plaintext highlighter-rouge">defer</code>로 리소스를 정리할 때 발생하는 에러를 놓치지 않으면서, 더 중요한 원인 에러를 덮어쓰지 않는 것이 중요합니다. 아래는 매우 실용적인 Go의 표준 패턴(idiomatic Go)입니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">do</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="n">bs</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">st</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="c">// &lt;-- 1. 반환 값을 'err'로 명명</span>
    <span class="c">// ...</span>
    <span class="c">// http 요청 등 주요 로직</span>
    <span class="c">// ...</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">closeErr</span> <span class="o">:=</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">();</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="c">// &lt;-- 2. 기존 에러가 없을 때만</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">closeErr</span> <span class="c">// &lt;-- 3. 뒷정리 에러를 최종 에러로 할당</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="c">// ...</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 패턴의 핵심은 <code class="language-plaintext highlighter-rouge">if err == nil</code> 조건입니다.</p>

<ul>
  <li>주요 로직에서 에러가 없었을 경우 (<code class="language-plaintext highlighter-rouge">err</code>가 <code class="language-plaintext highlighter-rouge">nil</code>일 때): defer문에서 발생한 뒷정리 에러(<code class="language-plaintext highlighter-rouge">closeErr</code>)를 최종 반환 에러로 삼습니다.</li>
  <li>주요 로직에서 이미 에러가 발생했을 경우 (<code class="language-plaintext highlighter-rouge">err</code>가 <code class="language-plaintext highlighter-rouge">nil</code>이 아닐 때): 덜 중요한 뒷정리 에러는 무시하고, 더 중요한 최초의 원인 에러를 그대로 보존하여 반환합니다.</li>
</ul>

<p>이는 “함수가 실패했다면, 그 최초의 원인을 보존하라”는 Go의 중요한 에러 처리 철학을 잘 보여줍니다</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Go 언어에서 fmt.Errorf를 올바르게 사용하는 방법을 알아봅니다. 모든 에러를 fmt.Errorf로 감싸는 것이 왜 안티 패턴인지, 재시도 로직과 에러 래핑(wrapping)의 모범 사례를 실제 코드를 통해 명확히 설명합니다.]]></summary></entry></feed>