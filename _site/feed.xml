<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-08-25T08:24:51+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">//TODO: Write Blog</title><subtitle>A blog about software engineering, blockchain, and other development topics.
</subtitle><author><name>Wonjoon</name></author><entry><title type="html">컨텍스트 엔지니어링: AI를 효과적으로 사용하는 방법</title><link href="http://localhost:4000/2025/08/14/context-engineering/" rel="alternate" type="text/html" title="컨텍스트 엔지니어링: AI를 효과적으로 사용하는 방법" /><published>2025-08-14T00:00:00+09:00</published><updated>2025-08-14T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/14/context-engineering</id><content type="html" xml:base="http://localhost:4000/2025/08/14/context-engineering/"><![CDATA[<h2 id="점점-빠르게-변화하는-ai">점점 빠르게 변화하는 AI</h2>

<p>작년과 올해 사이에 삶에서 느껴진 가장 큰 변화가 있다면 AI일 것입니다. 사람과 대화하듯 질문하는 내용에, 사람처럼 대답하는 AI를 보면서 신기해하던게 불과 작년이었는데, 이제는 복잡한 내용을 이해하고 정리하는 것을 넘어서 새로운 것을 만들고 이를 검토하는 것까지 가능할정도로 엄청나게 빠르게 발전하고 있습니다.</p>

<p>작년에 서점에 가면 ‘프롬프트 엔지니어가 되는 방법’이라는 주제의 책들이 굉장히 많았습니다. ‘좋은 질문을 할 수 있는 엔지니어’가 앞으로 AI 시대에 가장 필요할 것이라는 내용이 대다수였죠.</p>

<p>하지만 불과 1년이 채 되지 않은 시점에, 우리는 ‘개같이 말해도 찰떡같이 알아듣는’ AI를 만나고 있습니다. 내가 무엇을 궁금해하는지 모를 정도로 이해하기 어려운 질문을 던지더라도, 100%는 아니지만 그만큼 근접할 정도로 이해하기 위해 노력한 흔적이 뭍은 답변을 제공하는 것을 경험하고 있습니다.</p>

<p>앞에서 이야기할 내용이지만, 현재 AI는 ‘잘 설계된 컨텍스트, 즉 풍부하고 정확한 정보가 주어졌을 때, 매우 복잡한 내용이라 하더라도 정확하게 이해’할 수 있습니다. 하지만 이러한 이해를 바탕으로 무언가를 새롭게 생성하고자 하면, 특히 결과물이 점점 복잡해질수록 일관성이 부족해지거나 중복된 내용이 발생하는 등 생성 능력에 있어서 아직 부족한 점을 보이고 있습니다.</p>

<p>2025년 7월에 작성된 논문 ‘<a href="https://arxiv.org/abs/2507.13334">A Survey of Context Engineering for Large Language Models</a>‘에서는 컨텍스트 엔지니어링에 대해서 소개하고 있습니다. 이 논문은 프롬프트 엔지니어링과 컨텍스트 엔지니어링을 비교하고, 사용자가 더 나은 AI 활용을 위해 어떻게 컨텍스트 엔지니어링을 적용해야하는지에 대해 설명합니다.</p>

<h2 id="프롬프트-엔지니어링과-컨텍스트-엔지니어링">프롬프트 엔지니어링과 컨텍스트 엔지니어링</h2>

<p>프롬프트 엔지니어링은 ‘최고의 답변을 생성할 수 있는 최고의 질문’을 만드는데 집중합니다. 마치 ‘숙련된 수사관이 증인에게서 가장 정확한 진술을 이끌어내기 위해 단어 하나와 뉘앙스 하나까지 신중하게 고르는 것’과 비슷합니다.</p>

<p>하지만 컨텍스트 엔지니어링은 ‘AI가 문제를 해결하고 좋은 답변을 줄 수 있도록 최선을 다해 도와주는 것’과 같습니다. 숙련된 수사관인 AI에게 이제까지 모든 자료가 담긴 사건 파일을 건내주는 것과 같습니다. 이 파일에는 명확한 지시사항, 외부 참고자료, 사용 가능한 도구 목록, 그리고 과거 상호작용 기록등이 포함될 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>차원</th>
      <th>프롬프트 엔지니어링</th>
      <th>컨텍스트 엔지니어링</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>범위</td>
      <td>단일 텍스트 입력(프롬프트) 최적화</td>
      <td>다수의 정보 소스로 구성된 전체 정보 환경 설계</td>
    </tr>
    <tr>
      <td>모델</td>
      <td>정적인 텍스트 문자열 ($C = \text{prompt}$)</td>
      <td>동적이고 구조화된 정보 요소들의 조립 ($C = \mathcal{A}(c_1, c_2,…, c_n)$)</td>
    </tr>
    <tr>
      <td>목표</td>
      <td>특정 프롬프트에 대한 최상의 응답 생성</td>
      <td>주어진 과제에 대해 보상(품질)을 극대화하는 정보 시스템 최적화</td>
    </tr>
    <tr>
      <td>복잡성</td>
      <td>수동적, 반복적 시도를 통한 최적의 문구 탐색</td>
      <td>검색, 선택, 조립 등 여러 기능으로 구성된 시스템 수준의 최적화</td>
    </tr>
    <tr>
      <td>정보 흐름</td>
      <td>프롬프트 내에 정보가 고정됨</td>
      <td>외부 데이터베이스, 도구, 메모리 등에서 정보를 동적으로 가져와 활용</td>
    </tr>
    <tr>
      <td>상태 관리</td>
      <td>주로 상태가 없음 (매번 새로운 대화)</td>
      <td>메모리 구성요소를 통해 이전 상호작용의 상태를 명시적으로 관리</td>
    </tr>
    <tr>
      <td>확장성</td>
      <td>프롬프트가 길고 복잡해질수록 취약해짐</td>
      <td>모듈식 구성 요소를 통해 복잡성을 체계적으로 관리</td>
    </tr>
    <tr>
      <td>오류 분석</td>
      <td>수동 검사 및 반복적인 프롬프트 수정</td>
      <td>각 정보 구성 요소(함수)에 대한 체계적인 평가 및 디버깅</td>
    </tr>
  </tbody>
</table>

<h2 id="컨텍스트-엔지니어링의-단계">컨텍스트 엔지니어링의 단계</h2>

<p>논문에서는 컨텍스트 엔지니어링을 크게 3가지 기반 요소로 구성합니다. 이를 제품을 만드는 공급망이라고 할 때, 아래와 같이 표현할 수 있습니다.</p>

<ul>
  <li>검색 및 생성: 원자재를 조달합니다</li>
  <li>처리: 공장에서 원자재를 가공합니다.</li>
  <li>관리: 가공된 제품을 창고에 효율적으로 전달하고 이를 관리합니다.</li>
</ul>

<h3 id="1-컨텍스트-검색-및-생성">1. 컨텍스트 검색 및 생성</h3>

<p><strong>좋은 프롬프트의 중요성</strong></p>

<p>컨텍스트 엔지니어링에서도 프롬프트 엔지니어링, 즉 좋은 질문은 당연히 중요합니다. 우리는 AI에게 ‘이렇게 답변하게 된 과정을 보여달라고 요청’하거나, ‘하나의 답변 말고 여러 가능성을 동시에 탐색하도록 요청’해야 합니다. 이를 통해 AI가 성급한 결론을 내리지 않고, 여러 가능성을 추론함으로써 가장 효과적인 방향으로 사고를 확장할 수 있도록 도울 수 있습니다.</p>

<p><strong>외부 지식의 활용</strong></p>

<p>AI는 ‘학습한 내용까지만 생각할 수 있다’는 제약이 있습니다. ChatGPT의 경우에도 선택한 모델에 따라 알고 있는 최신 정보가 달라지기도 합니다.</p>

<p>하지만 최근에는 검색 증강 생성(RAG: Retrieval Augmented Generation) 기술을 통해 AI에게 인터넷, 내부 문서와 같은 외부 지식을 답변 생성에 사용할 수 있도록 제공할 수 있습니다. 이는 컨텍스트 엔지니어링 기법에 가장 핵심적인 기술중 하나로, AI가 가지고 있는 큰 문제점 중 하나인 환각(Hallucination)이라고 불리는 거짓된 정보 생성을 크게 줄일 수 있습니다.</p>

<p>초기 RAG가 단순한 사실 검색에 그쳤다면, 최근 RAG 시스템은 크게 2가지로 구분되어 더욱 정교한 방식으로 정보를 처리합니다.</p>

<ul>
  <li>
    <p>모듈형(Modular RAG): 사용자는 질문을 더 명확하게 다듬는 ‘질의 재작성’ 모듈, 여러 데이터베이스에서 동시에 정보를 가져오는 ‘다중 소스 검색’ 모듈, 그리고 검색된 정보들 중 가장 유용한 것을 골라내는 ‘재순위화’ 모듈 등을 필요에 따라 자유롭게 조합하여 최적의 RAG 파이프라인을 구축합니다.</p>
  </li>
  <li>
    <p>에이전트(Agentic RAG):  AI는 단순히 정보를 검색하는 것을 넘어, 스스로 ‘조사’를 수행합니다. 복잡한 질문을 받으면 이를 여러 개의 하위 질문으로 분해하고, 각각에 대한 정보를 검색한 뒤, 그 결과들을 종합하여 최종 결론을 도출합니다.</p>
  </li>
</ul>

<p>AI는 외부로부터 전달받은 지식을 마인드맵과 같은 그래프 형태로 연결합니다. 이렇게 연결된 정보들은 AI가 연관된 내용을 통한 다단계 추론을 훨씬 정확하게 할 수 있도록 합니다.</p>

<h3 id="2-컨텍스트-처리">2. 컨텍스트 처리</h3>

<p><strong>컨텍스트 크기의 한계</strong></p>

<p>AI는 한번에 처리할 수 있는 정보의 양에 한계를 갖고 있습니다. 우리도 한번에 공부할 수 있는 정보의 양이 한정되어 있듯이, AI 또한 메모리에 한계를 갖고 있습니다. 이로 인해, AI에게 너무 많은 정보를 제공하게 되면 중간 분실(Lost-In-The-Middle) 현상이 발생하기도 합니다. 중간에 있는 정보를 잊어버린채 잘못된 답변을 하거나, 생성된 결과의 일관성이 무너지기도 합니다. 이를 해결하기 위한 다양한 연구들(FlashAttention, Mamba 등)이 있습니다.</p>

<p>사실 이부분은 ‘컴퓨터 또한 메모리라는 한정된 기억공간을 갖는다’는 내용으로 보면, 당연한 결과일 뿐입니다. 다만 인간은 ‘과거를 기억하기 위한 다양한 수단을 사용’하는 것과 달리, AI는 상대적으로 방법과 공간의 한계가 명확합니다.</p>

<p><strong>자발적인 개선</strong></p>

<p>AI는 주어진 컨텍스트를 가지고 자체적인 개선(Self-Refine)이 가능합니다. 스스로 초안을 만들고, 이걸 비평하고, 초안을 수정합니다. 이러한 과정을 계속 반복해서 최적의 결과물을 생성합니다. 이를 다른 관점에서 보면, 우리가 공상 과학에서나 보던 ‘AI는 스스로 성장하고 있다’는 이야기가 현실로 이루어지고 있는 것이죠. 우리는 점점 발전해가는 결과를 얻을 수 있다는 기술적 이점 이면에, 앞으로 어떻게 발전할지 예측할 수 없는 진정한 인공지능을 마주하고 있는지도 모릅니다.</p>

<h3 id="3-컨텍스트-관리">3. 컨텍스트 관리</h3>

<p>AI는 기본적인 대화가 끝나면 모든것을 잊어버립니다. 이를 해결하기 위해, AI는 메모리라는 한정된 기억공간을 갖습니다. 메모리는 작은 공간이라는 제약이 있지만, 빠르게 기억을 불러올 수 있습니다. AI 뿐만 아니라 많은 시스템에서는 ‘자주 사용하는 정보를 메모리에 두고, 장기 기억을 할 수 있는 저장소에서 필요할 때마다 정보를 불러오는 방식’을 사용합니다. MemGPT는 이러한 방식을 통해 정보를 효율적으로 관리할 수 있는 기능(페이징)을 제공합니다.</p>

<p>또한 AI가 사용하는 작업공간, 즉 컨텍스트 창도 한정된 공간을 갖습니다. 모든 정보를 그대로 담을 수 없기 때문에, AI는 이를 압축하여 사용합니다. 컨텍스트 압축을 통해 AI는 핵심만 요약한 ‘요약노트’를 만들어서, 메모리에 더 많은 정보를 효율적으로 저장할 수 있도록 합니다.</p>

<h2 id="우리는-어떻게-ai를-사용하면-좋을까">우리는 어떻게 AI를 사용하면 좋을까?</h2>

<p>논문에서 제공한 내용을 바탕으로, 우리는 ‘AI를 통해 최적의 답변을 얻을 수 있는 방법’을 찾을 수 있습니다.</p>

<p><strong>작업의 목적을 명확하게 하고, 범위를 최소화 한다.</strong></p>

<p>이는 ‘내가 무엇을 요청하고 싶은지 명확하게 파악’하는 것에서부터 시작합니다. 실생활에서도 그렇듯이, AI에도 좋은 질문, 즉 프롬프트 엔지니어링이 가장 중요합니다. 그리고 이 요청을 가장 작은 단위의 질문으로 나눌 수 있어야 합니다. 질문의 크기가 커질수록 Lost-In-The-Middle 현상이 발생할 가능성이 높아집니다. 논문에서는 ‘중요한 정보가 컨텍스트의 시작 또는 끝에 위치할 때 가장 좋은 성능을 보여준다’고 말합니다.</p>

<p>작업을 요청할때에도 마찬가지입니다. 한번에 많은 작업을 요청하기보다는, 작업을 모듈화하고 단계별로 요청하는 것이 좋습니다.</p>

<p><strong>최대한의 정보를 제공한다.</strong></p>

<p>사용자가 AI를 사용하는 가장 큰 목적은 ‘빠르게 최적의 결과물을 얻는 것’입니다. 사실 AI에게 정보를 제공하는 것 자체가 또다른 업무일 수 있습니다. 하지만 AI에게 제공하는 정보가 많아질수록, AI가 더욱 양질의 답변을 제공한다는 것은 당연한 결과입니다.</p>

<p>단순히 정보를 많이 주는 것을 넘어, AI가 잘 활용할 수 있는 형태로 정보를 가공하고 이를 조립하여 제공해야 합니다. 정확한 정보가 담긴 전문 지식을 제공해야 하고, AI가 자체적으로 할 수 없는 일을 도울 수 있는 외부 도구(API)를 호출하여 효과적인 작업이 가능하도록 해야 합니다.</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[AI의 이해 능력과 생성 능력 사이의 비대칭성을 설명하고, '프롬프트 엔지니어링'을 넘어 AI의 잠재력을 최대한 활용하기 위한 '컨텍스트 엔지니어링'의 개념, 핵심 단계(검색, 처리, 관리), 그리고 이를 바탕으로 한 최적의 AI 활용 방법을 제시합니다.]]></summary></entry><entry><title type="html">스테이블코인의 현주소: 시장의 구성과 주요 플레이어</title><link href="http://localhost:4000/2025/08/07/stable-coin/" rel="alternate" type="text/html" title="스테이블코인의 현주소: 시장의 구성과 주요 플레이어" /><published>2025-08-07T00:00:00+09:00</published><updated>2025-08-07T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/07/stable-coin</id><content type="html" xml:base="http://localhost:4000/2025/08/07/stable-coin/"><![CDATA[<p>최근 금융 및 기술 분야에서 ‘스테이블코인(StableCoin)’이라는 용어가 자주 언급되고 있습니다. 글을 작성하는 시점인 2025년 8월, 카카오는 그룹차원에서 스테이블코인을 위한 TF를 구성(<a href="https://www.mk.co.kr/news/stock/11386047">뉴스</a>)했고, 뒤에서 다룰 글로벌 양대 스테이블코인 발행사 중 하나인 Circle는 대한민국 방문을 계획(<a href="https://www.sedaily.com/NewsView/2GWIS82LOS">뉴스</a>)하고 있습니다.</p>

<p>그래서 2025년 7월 기준으로 스테이블코인에 대해 정리한 다양한 보고서들중에서 ‘규모가 큰 기관’에서 발행한 보고서가 무엇이 있는지 Perplexity에게 물어보았습니다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>기관‧발행처</th>
      <th>보고서·글 제목 (발행일)</th>
      <th>핵심 내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>✔️</td>
      <td>McKinsey &amp; Company</td>
      <td>The stable door opens: how tokenized cash enables next-gen payments (2025-07-21)</td>
      <td>- 2025년이 스테이블코인 성장의 분기점이라 진단<br />- EU MiCA·영국 FSMA·美 GENIUS Act 등 글로벌 규제 총정리<br />- 지급결제·증권결제·자산토큰화 시나리오와 시장 규모 추정</td>
    </tr>
    <tr>
      <td>✔️</td>
      <td>CertiK Skynet</td>
      <td>2025년 상반기 스테이블코인 종합 보고서 (2025-07-23)</td>
      <td>- 총 공급 2,500억달러·월 결제 1.4조달러 등 실측 데이터 제시<br />- 보안 사고·준비금 투명성·규제 리스크 분석</td>
    </tr>
    <tr>
      <td>✔️</td>
      <td>Samsung Securities 리서치센터</td>
      <td>스테이블코인 통화 패권 경쟁, 새로운 기회? (2025-06-13)</td>
      <td>- 달러 패권 수호 vs 각국 통화주권 경쟁 구도 해석<br />- USDT·USDC 독점 구조 속 신규 프로젝트 전략 비교</td>
    </tr>
    <tr>
      <td> </td>
      <td>TRM Labs</td>
      <td>Stablecoins – Risks &amp; Compliance Cheat-Sheet (2025-05-28)</td>
      <td>- FATF Travel Rule·AML/KYC 체크리스트<br />- 온체인 포렌식 사례와 발행사 제재 위험</td>
    </tr>
    <tr>
      <td>✔️</td>
      <td>Amberdata</td>
      <td>Stablecoin Q1 2025: Insights on Trends &amp; Regulation (2025-05-16)</td>
      <td>- 분기별 발행/상환(issuance) 차트로 수요 분석<br />- Circle-ICE 제휴, FDUSD 디페깅 등 사건별 영향 평가</td>
    </tr>
    <tr>
      <td> </td>
      <td>FXC Intelligence</td>
      <td>State of Stablecoins in Cross-border Payments 2025 (2025-07-22)</td>
      <td>- 송금·무역결제 수수료 절감 사례, 금융기관 인터뷰</td>
    </tr>
    <tr>
      <td>✔️</td>
      <td>국제결제은행(BIS)</td>
      <td>Stablecoins and Safe-Asset Pricing (요약 기사 2025-07-25)</td>
      <td>- 안전자산 부족과 ‘코인런’ 시나리오 경고<br />- 스테이블코인 금리·레포시장 연계 가능성 제시</td>
    </tr>
  </tbody>
</table>

<p>위의 내용 중 총 5개의 보고서를 추려서, NotebookLM을 이용해 전체적인 흐름과 내용을 정리해달라고 요청했습니다. 그리고 이 내용을 기반으로 글을 작성해보았습니다.</p>

<h2 id="스테이블코인이란-무엇인가">스테이블코인이란 무엇인가?</h2>

<p>스테이블코인은 이름 그대로 <strong>‘가치가 안정적으로 유지되도록 설계된 디지털 자산’</strong>을 의미합니다. 일반적으로 미국 달러 등 특정 법정화폐의 가치에 1:1로 연동(pegging)되는데, 쉽게 말하면 <strong>1개의 스테이블코인이 항상 1달러의 가치를 유지</strong>하도록 설계하는 것입니다.</p>

<p>이점이 가격 변동성이 큰 다른 암호화폐와 스테이블코인이 구별되는 가장 큰 특징입니다. 이러한 가치 안정성은 보통 <strong>발행된 코인의 수량만큼 실제 현금이나 미국 단기 국채(T-bill)와 같은 현금성 자산을 준비금으로 보유</strong>함으로써 담보됩니다.</p>

<blockquote>
  <p>준비금이란, 기업이 미래의 불확실한 상황에 대비하여 미리 적립해두는 자금을 의미합니다. 기업의 안정성을 위해 법적으로 강제되는 법정준비근과 기업의 판단하에 자율적으로 하는 임의준비금으로 구분됩니다. 이러한 준비금은 자본의 보전, 배당 재원 제한 등 다양한 목적으로 사용됩니다.</p>
</blockquote>

<p>사실 스테이블코인이 갑자기 등장한 것은 아닙니다. 가장 처음으로 스테이블코인이 등장한 것은 2014년으로, 미국 국채와 같이 안정적인 자산을 이용하여 변동성을 낮추고자 하는 목적으로 만들어졌습니다. 2025년 상반기 기준으로 스테이블코인의 전체 시장 규모는 약 <strong>2,520억 달러(약 350조 원)</strong>에 이르렀고, 월간 결제 및 전송량은 <strong>1조 3,900억 달러(약 1,930조 원)</strong>를 기록했습니다. 이 수치들은 스테이블코인이 디지털 자산 생태계 내에서 상당한 규모를 가진 하나의 분야로 자리 잡았음을 보여줍니다.</p>

<h3 id="어떻게-스테이블코인은-11-가치를-유지할-수-있을까">어떻게 스테이블코인은 1:1 가치를 유지할 수 있을까?</h3>

<p>그렇다면 질문이 생깁니다. 사용자들이 코인을 사고팔 때 수요와 공급에 따라 가격이 변동할텐데, 어떻게 1달러 가치가 유지될 수 있는걸까요?</p>

<p>스테이블코인은 <strong>‘차익거래(Arbitrage)’의 원리</strong>로 1달러 가치를 유지할 수 있습니다. 시장의 가격이 1달러에서 벗어나면, 차익거래자들이 이익을 얻기 위해 개입하여 가격을 다시 1달러로 되돌려 놓는 과정에서 자연스럽게 1:1 가치가 유지됩니다.</p>

<p>먼저 차익거래의 원리를 설명하기 전에, 발행사, 차익거래자, 일반투자자에 대해 알아볼 필요가 있습니다.</p>

<p><strong>발행사</strong></p>

<ul>
  <li>스테이블코인을 만들고(발행), 없애는(소각/상환) 주체입니다.</li>
  <li>예를 들어 USDT라는 스테이블코인을 만드는 테더사(Tether Limited)가 이에 해당합니다.</li>
  <li>발행사는 발행한 스테이블코인의 총량 이상으로 준비금을 보유하고 있어야 합니다. 이때 준비금은 실제 달러나 국채등의 현금성 자산으로 보유되어야 합니다. 이를 통해 스테이블코인의 가치를 1:1로 유지할 수 있습니다.</li>
</ul>

<p><strong>차익거래자</strong></p>

<ul>
  <li>스테이블코인의 시장 가격이 법정화폐(미국 달러 등)와 괴리가 생길 경우, 발행사와 거래하여 차익을 실현하고 가격을 안정시키는 주체입니다.</li>
  <li>차익거래자는 아무나 될 수 없습니다. KYC/AML등 엄격한 고객확인이 가능해야 하고, 발행사와 직접 계약을 체결해야 합니다.</li>
  <li>주로 대형 암호화폐 거래소(Binance, Kraken 등), 대규모 자금을 운용하는 암호화폐 펀드, 전문 트레이딩 회사등이 이에 해당합니다.</li>
  <li>예로 테더사는 발행 및 상환의 최소 단위를 10만달러(한화 약 1억 4천만원)로 설정하고 있습니다.</li>
</ul>

<p><strong>일반투자자</strong></p>

<ul>
  <li>암호화폐 거래소를 통해 시장가격에 따라 스테이블코인을 사고팝니다.</li>
  <li>스테이블코인의 수요와 공급에 영향을 주기 때문에, 시장가격이 변동되는 원인이 됩니다.</li>
</ul>

<p>그렇다면 차익거래가 어떻게 작동하는지 2가지 상황을 통해 살펴보겠습니다. 여기서는 USDT를 예시로 설명하겠습니다.</p>

<p><strong>상황 1: 수요 증가로 가격이 1달러보다 높아질 때</strong></p>

<ol>
  <li>시장에서 USDT 가격이 1.01달러가 되면, 차익거래자는 발행사에 1달러를 주고 1 USDT를 발행받습니다. (오른가격으로 발행하지 않습니다)</li>
  <li>이 1 USDT를 시장에 즉시 팔아 1.01달러를 얻고, 0.01달러의 차익을 봅니다.</li>
  <li>이 차익거래가 계속되면 시장에 USDT 공급이 늘어나면서 가격은 다시 1달러로 내려옵니다.</li>
</ol>

<p><strong>상황 2: 공급 증가로 가격이 1달러보다 낮아질 때</strong></p>

<ol>
  <li>시장에서 USDT 가격이 0.99달러로 떨어지면, 차익거래자는 시장에서 0.99달러로 1 USDT를 삽니다.</li>
  <li>이 1 USDT를 발행사에 가져가 1달러로 상환받고, 0.01달러의 차익을 봅니다.</li>
  <li>이 차익거래가 계속되면 시장의 USDT 수요가 늘어나면서 가격은 다시 1달러로 올라갑니다.</li>
</ol>

<p>이처럼 차익거래는 스테이블코인의 가격을 1달러라는 기준점에 묶어두는 ‘보이지 않는 손’ 역할을 합니다. 물론 이 메커니즘은 <strong>“발행사가 1:1 준비금을 잘 보유하고 있고, 언제든 교환해 줄 것이다”</strong>라는 시장의 신뢰가 있을 때만 원활히 작동합니다.</p>

<h2 id="스테이블코인-시장의-발전-과정">스테이블코인 시장의 발전 과정</h2>

<h3 id="20212023년-시장-성장과-안정성-테스트">2021~2023년: 시장 성장과 안정성 테스트</h3>

<p>이 시기 스테이블코인 시장은 암호화폐 시장 전반의 성장과 함께 규모가 커졌습니다. USDT와 USDC가 시장의 대부분을 점유하는 양강 구도가 형성되었죠. 한편, 2023년 3월 실리콘밸리 은행(SVB) 파산의 여파로 USDC의 1달러 페깅이 일시적으로 흔들리는 사건이 발생했습니다. 이는 스테이블코인의 안정성이 전적으로 발행사의 준비금 관리 능력에 달려있다는 점과 잠재적 리스크를 시장에 명확히 보여준 사례가 되었습니다.</p>

<h3 id="2024년-거래-규모의-확대와-네트워크-확장">2024년: 거래 규모의 확대와 네트워크 확장</h3>

<p>2024년에는 스테이블코인의 연간 거래량이 27조 달러를 넘어서며 활용도가 크게 증가했습니다. 이 과정에서 사용자들은 거래 효율성(속도, 비용)을 중시하기 시작했고, 이더리움 외에 솔라나(Solana)와 같은 대체 블록체인 네트워크에서의 스테이블코인 거래량이 크게 늘어나는 등 네트워크의 확장이 뚜렷해졌습니다.</p>

<h3 id="2025년-상반기-정책적-관심-증대와-시장-구도-변화">2025년 상반기: 정책적 관심 증대와 시장 구도 변화</h3>

<p><strong>미국의 정책 변화</strong></p>

<p>시장의 규모가 커지자 정책적 관심도 높아졌습니다. 1월 23일, 미국 대통령은 행정명령을 통해 민간이 발행하는 법정화폐 기반 스테이블코인을 지원하는 방향성을 제시했습니다.</p>

<p>이 행정명령은 중앙은행이 직접 발행하는 디지털화폐인 CBDC(Central Bank Digital Currency)에도 영향을 미쳤습니다. 2025년에는 하원의원 ‘톰 에머(Tom Emmer)’가 연준이 디지털 통화를 개발하거나 배포하는 것을 차단하는 법안을 발의했습니다. 이를 통해 CBDC 발행을 전면 금지하는 ‘Anti-CBDC Surveillance State Act’가 상·하원에서 동시 심의되고 있습니다. 결국 CBDC 개발을 중단하고 fiat-backed 스테이블코인 지원을 지시하는 등, 스테이블코인을 금융 시스템의 한 요소로 인식하기 시작했다는 정책적인 변화가 나타났습니다 (<a href="https://www.g-enews.com/article/Global-Biz/2025/07/202507041553356500906806b77b_1">뉴스</a>).</p>

<blockquote>
  <p>fiat-backed: 스테이블코인이 법정화폐(fiat)를 담보로 한다는 의미입니다. 여기서 법정화폐는 미국달러와 같이 정부가 가치를 보증하고 발행하는 실제 돈을 의미합니다. USDT, USDC, PYUSD 등 대부분의 스테이블코인이 이에 해당합니다. 대부분의 스테이블코인은 미국 단기채권을 준비금으로 보유하고 있습니다. BIS 보고서에 따르면, 스테이블코인 순유입은 단기 국채(T-bill) 수익률을 하락시키는 경향이 있는데, 약 2표준편차(약 35억 달러)의 스테이블코인이 유입될 경우 3개월 만기 국채 수익률은 10일 이내에 약 2~2.5bp(베이시스 포인트) 하락시킵니다.</p>
</blockquote>

<p><strong>유럽의 MiCA 규제</strong></p>

<p>MiCA(Markets in Crypto-Assets Regulation)는 유럽 연합이 암호화폐 시장의 투명성과 안정성을 높이고 투자자를 보호하기 위해 마련된 법률입니다. (<a href="https://kdaxa.org/support/report.php?mNum=3&amp;sNum=2&amp;boardid=data&amp;mode=view&amp;idx=202">링크</a>)</p>

<ul>
  <li>가상자산을 발행하는 사업자들은 백서를 의무적으로 발행해야 합니다.</li>
  <li>가상자산 서비스 제공업체들은 일정 수준 이상의 자본과 위험관리를 충족해야 합니다.</li>
  <li>가상자산 서비스 제공업체는 자금세탁방지 및 테러자금 조달 방지 등 내부 관리 체계를 구축해야 합니다.</li>
  <li>스테이블코인은 일반적으로 통용되는 가상자산과는 다르게 규제 대상이 됩니다.</li>
</ul>

<p>실제로 2024년 6월 MiCA가 최초로 시행된 이후 2024년 12월 이 법의 완전한 시행이 이뤄졌을 때, 테더사는 MiCA 기준을 충족하지 못해 유럽 시장에서 철수하였습니다. 현재 테더사는 유럽 지역 협력사의 스테이블코인 발행을 지원하는 방식으로 유럽 시장에 진출하는 방향을 계획하고 있습니다.</p>

<p>그 외에도 영국, 싱가포르, 홍콩, 일본 등도 스테이블코인 규제 프레임워크를 도입하거나 추진하고 있습니다.</p>

<p><strong>규제의 배경: 보안 리스크</strong></p>

<p>이렇게 다양한 국가에서 높은 규제를 요구하는 이유는, 스테이블코인 시장에서 발생한 다양한 보안사고와 리스크 떄문입니다. 2025년 상반기에만 총 344건의 가상자산 보안 사고로 인해 약 24.7억 달러의 피해가 발생하였습니다. 이전에 보안 사고 원인의 높은 비율을 차지하던 스마트 컨트랙트 코드의 취약점보다는, 개인키 관리 실패, 유동성 풀의 논리적 결함 등 운영상 허점이 더 큰 비율을 차지했습니다. 예를 들어 Bybit에서 발생한 약 15억 달러의 피해나 Infin에서의 4,950만 달러의 손실 모두 해킹에서 비롯되었습니다. 또한 스테이블코인 보유자는 발행사 파산 시 법적으로 무담보 채권자로 취급될 수 있으며, 중앙은행이나 정부의 보호를 보장받지 못할 수 있다는 문제도 존재합니다.</p>

<p><strong>규제가 시장에 미치는 영향</strong></p>

<p>하지만 이러한 규제가 시장에 미치는 영향은 생각보다 크고 복잡합니다. 먼저 규제 요건을 충족하는 ‘컴플라이언스 리더’와 규제를 회피하거나 충족하지 못하는 ‘비준수 잔류자’ 간의 격차가 뚜렷해지고 있습니다. 심지어 USDT는 가장 먼저 시장에 진입한, 그리고 가장 큰 규모를 자랑하지만 반대로 MiCA 규제를 충족하지 못한 비준수 잔류자이기도 합니다.</p>

<p>또한 규제가 엄격해지면서, 보안 감사나 투명성 확보에 대한 기준이 높아졌습니다. 예로 USDC를 발행하는 써클(Circle)사는 연간 5,000만 달러를 투명성 확보를 위해 지출하고 있습니다. 이러한 영향은 발행사의 크기 또한 중요해지게 되는데요, 결국 대형 발행자에게 유리한 환경이 조성됩니다.</p>

<h2 id="주요-스테이블코인과-시장-구도">주요 스테이블코인과 시장 구도</h2>

<p>2025년 기준으로, 스테이블코인 시장은 뚜렷한 특징을 가진 몇몇 주요 플레이어들이 경쟁하고 있습니다.</p>

<p><strong>USDT (테더)</strong></p>

<p>2025년 상반기 기준 유통량 약 1,540억 달러로, 시장에서 가장 큰 규모와 유동성을 차지하고 있습니다. 특히 수수료가 저렴한 트론(TRON) 네트워크에서 전체 공급량의 절반 이상이 유통되며 높은 거래 활성도를 보입니다.</p>

<blockquote>
  <p>트론은 2017년 저스틴 선(Justin Sun)이 만든 블록체인 네트워크로, 거의 무료에 가까운 수수료와 초당 2,000건의 거래(2,000TPS)를 처리할 수 있을 정도로 빠른 속도를 제공합니다.</p>
</blockquote>

<p>USDT는 가장 먼저 시장에 진입하여 많은 사용자를 보유하게 되었고, 이를 통해 안정적인 유동성을 확보하고 있습니다. 다만 과거부터 준비금 구성의 투명성과 관련하여 여러 논의가 있어왔고, 최근 MiCA를 충족하지 못해 유럽 시장에서 철수한 상태입니다. 앞으로 유럽 뿐만 아니라 전 세계 시장에서 점점 강화되고 있는 규제 환경에 어떻게 대응할 것인지가 중요한 상황입니다.</p>

<p><strong>USDC (써클)</strong></p>

<p>2025년 상반기 기준 공급량 약 610억 달러로, USDT와 함께 시장에서 두 번째로 큰 규모를 차지하고 있습니다. 특히 써클사는 정기적인 회계 감사를 통해 준비금을 투명하게 공개하고, 미국 등 주요국의 규제 프레임워크를 적극적으로 준수하는 전략을 취합니다.</p>

<p>2025년에는 성공적으로 기업공개(IPO)를 마쳤으며, 비자(Visa), 블랙록(BlackRock) 등 전통 금융 기업들과의 파트너십을 통해 제도권 시장으로의 확장을 모색하고 있습니다. 또한 MiCA의 규제 준수를 위해 프랑스에 별도 법인을 설립하고 새로운 발행구조를 도입하고 있습니다.</p>

<p><strong>PYUSD (페이팔)</strong></p>

<p>2025년 상반기에 시가총액이 두 배 이상 증가하며 빠르게 점유율을 높이고 있습니다. 특히 글로벌 결제 플랫폼인 페이팔의 검증된 인프라와 약 4억명의 사용자를 이미 확보하고 있다는 큰 장점이 있습니다. 빠른 거래 속도를 위해 솔라나 네트워크를 도입하고, 보유자에게 연 3.7%의 보상을 제공하는 등 후발 주자로서 사용자 채택을 늘리기 위한 적극적인 전략을 펼치고 있습니다.</p>

<p><strong>DAI (메이커다오)</strong></p>

<p>특정 중앙화된 발행사 없이, 프로토콜에 의해 관리되는 ‘탈중앙화’ 모델을 대표합니다. 최근에는 ‘USDS’로 리브랜딩하고 여러 블록체인으로 확장하는 등 발전을 모색하고 있습니다.</p>

<p><strong>FDUSD (퍼스트 디지털 USD)</strong></p>

<p>2025년 3월, 시장의 루머로 디페깅 위기를 겪었으나, 발행사가 신속하게 준비금 내역을 공개하며 12시간 만에 가치를 회복했습니다. 이는 중앙화 스테이블코인의 위기관리 능력과 투명성의 중요성을 보여준 사례로 분석됩니다.</p>

<h2 id="미래-전망-및-시사점">미래 전망 및 시사점</h2>

<p>최근에는 RWA를 담보로 발행하는 ‘RWA 담보형 스테이블코인’과 ‘수익 발생형 스테이블코인’이 스테이블코인 시장에서 성장하는 추세입니다. RWA(Real-World Asset) 토큰은 현실 세계에 존재하는 실물 자산을 블록체인 기술을 통해 디지털화한 것으로, 부동산, 미술품, 금, 채권, 저작권 등 우리가 현실에서 소유하고 거래하는 자산들의 소유권을 블록체인 상에 기록하여 토큰 형태로 만든 것을 의미합니다. 일부에서는 2025년 연말까지 이러한 형식의 스테이블코인이 전체 시장 규모의 8~10%를 차지할 것으로 예상하고 있습니다.</p>

<p>또한 Société Générale, Santander, Bank of America 등 주요 은행 및 Visa, Stripe와 같은 결제 네트워크가 스테이블코인 파일럿 프로그램을 확대하고 있습니다. 이는 전통 금융 시스템과 스테이블코인의 통합이 점점 가속화되고 있음을 보여줍니다.</p>

<p>대한민국에서도 한국형 스테이블코인의 제도화 필요성에 대해 지속적으로 논의되고 있습니다. 특히 원/달러 환율 상승 지속, 기존 외환 규제 우회 가능성, 민간 시장 보호(결제사, 은행, 투자자, 알트코인 발행사 등), 국채 수요 창출 등을 위해 규제 프레임워크 수립이 시급하다는 의견이 많습니다.</p>

<p>하지만 한국형 원화 스테이블코인은 시장에서 살아남기 쉽지는 않아보입니다. 먼저 대한민국은 이미 핀테크 인프라가 매우 고도화로 발전되어 있기 때문에, 단순히 개방성과 신뢰를 전제로 시장에서 전통 금융 시스템과 비교하여 높은 경쟁력을 갖기 어렵습니다. 이를 극복하기 위해, 한국은 금 기반 RWA 및 외화 운용 능력을 결합한 ‘혼합형 스테이블코인 모델’이 유망할 것으로 전망됩니다.</p>

<p>이미 디지털시장의 금이라고 불리는 비트코인과 스테이블코인의 관계는 어떻게 될까요? 일부 보고서에서는 스테이블코인이 활성화되면 단기적으로 비트코인의 수요에도 영향이 있을거라고 판단합니다. 하지만 장기적으로는 비트코인이 스테이블코인 체계 내에서 ‘전략적 헷지 및 구조적 보완 자산’으로서의 가치를 강화할 것으로 예상됩니다. 이러한 움직임은 스테이블코인만이 아닌 가상자산 시장에서도 현재 활용되고 있는 방법이라 현실성있는 방법으로 보입니다.</p>]]></content><author><name>Wonjoon</name></author><category term="crypto" /><summary type="html"><![CDATA[2025년 기준, 스테이블코인의 정의와 1달러 가치를 유지하는 차익거래 원리, 시장 발전 과정, USDT·USDC 등 주요 플레이어 분석 및 미래 전망을 다룹니다.]]></summary></entry><entry><title type="html">SQLite FTS의 토크나이저와 인덱싱에 대해서</title><link href="http://localhost:4000/2025/08/06/sql-fts5/" rel="alternate" type="text/html" title="SQLite FTS의 토크나이저와 인덱싱에 대해서" /><published>2025-08-06T00:00:00+09:00</published><updated>2025-08-06T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/06/sql-fts5</id><content type="html" xml:base="http://localhost:4000/2025/08/06/sql-fts5/"><![CDATA[<h2 id="목차">목차</h2>

<ul>
  <li><a href="#전문-검색full-text-search이란">전문 검색(Full-Text Search)이란?</a></li>
  <li><a href="#fts는-어떻게-동작하나요">FTS는 어떻게 동작하나요?</a></li>
  <li><a href="#좀더-자세히-알아보기">좀더 자세히 알아보기</a></li>
  <li><a href="#fts의-장점">FTS의 장점</a></li>
</ul>

<h2 id="전문-검색full-text-search이란">전문 검색(Full-Text Search)이란?</h2>

<p>우리가 구글에서 “오늘 서울 날씨”라고 검색하면, 구글은 어떻게 요청 데이터를 처리할까요?
아마도 구글은 ‘오늘’, ‘서울’, ‘날씨’라는 단어가 포함된 수많은 웹페이지 중에서 가장 관련성 높은 문서를 찾아서 보여줄겁니다.</p>

<p>이처럼, 전문 검색(Full-Text Search)은 단순히 문자가 완전히 일치하는지(예: <code class="language-plaintext highlighter-rouge">LIKE '%검색어%'</code>)를 확인하는 것을 넘어, <strong>문장이나 문단 전체에서 특정 단어나 구문이 포함된 문서를 빠르고 효율적으로 찾아주는 기술</strong>입니다. 
일반적인 데이터베이스 검색(예: <code class="language-plaintext highlighter-rouge">WHERE title = '검색어'</code>)이 책의 ‘목차’에서 제목을 찾는 것이라면, 전문 검색은 일반적으로 책의 맨 뒤에서 볼 수 있는 ‘찾아보기(인덱스)’를 이용해 본문 내용 안에서 단어를 찾는 것과 같습니다.</p>

<p>SQLite 데이터베이스는 이 ‘전문 검색’ 기능을 사용할 수 있도록 해주는 강력한 확장 기능(extension)인 FTS를 제공합니다. ‘FTS’는 Full-Text Search의 약자이고, 뒤에 숫자로 버전을 명시합니다. 예를 들어 FTS5라는 것은 5번째 버전을 의미합니다. <strong>앞으로 설명할 FTS는 FTS5를 의미합니다.</strong></p>

<h2 id="fts는-어떻게-동작하나요">FTS는 어떻게 동작하나요?</h2>

<p>FTS는 일반적인 검색보다 훨씬 빠르고 효율적으로 동작하기 위해, 아래와 같은 과정을 거칩니다.</p>

<h3 id="1-가상-테이블virtual-table-생성">1. 가상 테이블(Virtual Table) 생성</h3>

<p>전문 검색을 할 텍스트 데이터(예: 상품 설명)를 일반 테이블이 아닌 FTS 전용의 ‘가상 테이블(VIRTUAL)’에 저장합니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 'product_fts' 라는 이름의 FTS5 가상 테이블을 생성</span>
<span class="k">CREATE</span> <span class="n">VIRTUAL</span> <span class="k">TABLE</span> <span class="n">product_fts</span> <span class="k">USING</span> <span class="n">fts5</span><span class="p">(</span>
    <span class="n">Name</span><span class="p">,</span>         <span class="c1">-- 상품명</span>
    <span class="n">Description</span>   <span class="c1">-- 상품설명</span>
    <span class="c1">-- , tokenize = 'porter' -- (옵션) 추가적인 토크나이저 설정</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="2-토큰화tokenization">2. 토큰화(Tokenization)</h3>

<p>FTS5 테이블에 텍스트를 저장하면, FTS5는 이 텍스트를 의미 있는 최소 단위의 단어, 즉 <strong>‘토큰(token)’</strong>으로 분해합니다. 예를 들어, “최고의 서울 야경 투어”라는 문장은 ‘최고’, ‘서울’, ‘야경’, ‘투어’ 같은 토큰으로 쪼개지는데, 이 과정에서 ‘의’ 같은 조사는 보통 무시됩니다.</p>

<h3 id="3-인덱싱indexing">3. 인덱싱(Indexing)</h3>

<p>앞에서 쪼개진 토큰들을 바탕으로 ‘역인덱스(inverted index)’라는 특별한 목록을 만듭니다. 이 목록에는 어떤 단어(토큰)가 어떤 문서(row)에 나타나는지에 대한 정보가 기록됩니다.</p>

<p>예를 들어, ‘서울’이 포함된 문서 목록(1, 5, 12)과 ‘야경’이 포함된 문서 목록(1, 7)을 찾아서 아래와 같이 매핑합니다.</p>

<ul>
  <li>‘서울’ -&gt; 1번, 5번, 12번 문서에 있음</li>
  <li>‘야경’ -&gt; 1번, 7번 문서에 있음</li>
</ul>

<h3 id="4-검색search">4. 검색(Search)</h3>

<p>사용자가 <code class="language-plaintext highlighter-rouge">MATCH</code> 연산자를 사용해 “서울 야경”이라고 검색하면, FTS는 앞에서 생성한 역인덱스를 이용해서 ‘서울’과 ‘야경’이 포함된 문서를 빠르게 찾아냅니다. 그리고 두 목록에 공통으로 존재하는 문서를 최종 결과로 반환합니다.</p>

<h2 id="좀더-자세히-알아보기">좀더 자세히 알아보기</h2>

<p>아래와 같이 다양한 옵션을 사용해서 가상 테이블을 설정해봅시다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="n">VIRTUAL</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">USING</span> <span class="n">FTS5</span><span class="p">(</span>
    <span class="n">id</span> <span class="n">UNINDEXED</span><span class="p">,</span>
    <span class="n">sub_id</span><span class="p">,</span>
    <span class="k">comment</span><span class="p">,</span>
    <span class="n">field</span> <span class="n">UNINDEXED</span><span class="p">,</span>
    <span class="nb">text</span><span class="p">,</span>
    <span class="k">prefix</span> <span class="o">=</span> <span class="s1">'1 2 3'</span><span class="p">,</span>
    <span class="n">tokenize</span> <span class="o">=</span> <span class="s1">'unicode61 remove_diacritics 2'</span>
<span class="p">)</span>
</code></pre></div></div>

<p>먼저 결론을 말씀드리면, 이 명령어를 통해 대소문자를 무시하고, 발음 기호를 제거하며, 공백/문장부호로 단어를 나누는 규칙으로 sub_id, comment, text 컬럼의 내용을 토큰으로 만들어 저장하는 FTS 테이블을 생성합니다.</p>

<h3 id="검색-대상-컬럼-선정">검색 대상 컬럼 선정</h3>

<p>일부 필드에는 UNINDEXED라는 옵션이 붙어있는 것을 볼수 있는데요, 이 옵션이 붙어있는 컬럼은 테이블에 저장되기는 하지만 전문 검색의 대상이 되지는 않습니다. 즉, MATCH 연산자를 사용해서 이 컬럼들을 검색할 수 없습니다.</p>

<ul>
  <li>검색 대상: sub_id, comment, text</li>
  <li>검색 비대상: id, field</li>
</ul>

<p>검색 대상 컬럼에 있는 텍스트는 토큰으로 분해되어 검색용 인덱스로 만들어집니다.</p>

<h3 id="토큰화tokenization">토큰화(Tokenization)</h3>

<p>토큰화(Tokenization)는 바로 <code class="language-plaintext highlighter-rouge">tokenize</code> 옵션에 의해 결정됩니다. 코드를 보면 <code class="language-plaintext highlighter-rouge">unicode61 remove_diacritics 2</code>라는 옵션이 붙어있는 것을 볼 수 있습니다. 이 옵션은 2가지 옵션을 포함하고 있습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">unicode61</code></strong></p>

<p>사용할 토크나이저(Tokenizer, 분해기)의 이름입니다. 이름 그대로 유니코드 6.1 표준에 정의된 규칙에 따라 텍스트를 단어로 분해합니다. 이 분해기는 크게 2가지 특징을 가지고 있습니다.</p>

<ol>
  <li>Case-insensitive: 대소문자를 구분하지 않습니다. Apple, apple, APPLE은 모두 같은 토큰 ‘apple’로 처리됩니다.</li>
  <li>Separator: 공백(space), 마침표(.), 쉼표(,) 등 문장 부호를 기준으로 단어를 나눕니다.</li>
</ol>

<p><strong><code class="language-plaintext highlighter-rouge">remove_diacritics 2</code></strong></p>

<p>토크나이저에 전달하는 추가 옵션입니다. 여기서 diacritic은 발음 구별 기호(예: é, ü, ñ)를 의미하고, 결국 앞에 remove가 붙었다는 것은 발음 기호를 제거하라는 옵션이 됩니다.</p>

<p>예를 들어,</p>

<ul>
  <li>résumé -&gt; resume로,</li>
  <li>café -&gt; cafe</li>
</ul>

<p>로 변환되어 토큰으로 만들어집니다.</p>

<p>그럼 뒤에 숫자는 무엇을 의미할까요? 이러한 기능을 처리하는 내부적인 알고리즘의 버전을 의미합니다. 즉 2버전을 기반으로 발음 기호를 제거하라는 옵션입니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">prefix</code></strong></p>

<p>단어의 앞부분만으로도 빠르게 검색할 수 있도록 <strong>접두어 인덱스(prefix index)</strong>를 만듭니다. ‘1 2 3’의 의미는 한 글자, 두 글자, 세 글자짜리 접두어에 대한 인덱스를 미리 만들어두겠다는 뜻입니다.</p>

<p>예를 들어, apple이라는 단어가 있다면 a, ap, app에 대한 인덱스가 생성됩니다. 이를 통해 사용자는 ‘app’ 까지만 입력해도 apple을 매우 빠르게 찾아낼 수 있습니다.</p>

<p>자동완성 기능이라고 생각하시면 이해하기 좋습니다.</p>

<h3 id="예시-1-영어-텍스트-토큰-분해-과정">예시 1. 영어 텍스트 토큰 분해 과정</h3>

<p><strong>원본 텍스트 저장</strong></p>

<p>“The best Café in Seoul is near City Hall.” 라는 원본 텍스트가 있다고 가정합니다. 이 텍스트는 <code class="language-plaintext highlighter-rouge">text</code> 컬럼에 저장됩니다.</p>

<p><strong>토큰화 과정</strong></p>

<p>unicode61 토크나이저는 대소문자를 통합하고 문장 부호를 기준으로 단어를 나눕니다.</p>

<p>결과로 [the, best, café, in, seoul, is, near, city, hall]이 생성됩니다.</p>

<p><strong>발음 기호 제거</strong></p>

<p>remove_diacritics 옵션은 발음 기호를 제거합니다. café -&gt; cafe</p>

<p>결과로 [the, best, cafe, in, seoul, is, near, city, hall]이 생성됩니다.</p>

<p><strong>접두어 인덱스 생성</strong></p>

<p>단어의 앞부분만으로도 빠르게 검색할 수 있도록 접두어 인덱스(prefix index)를 만듭니다.</p>

<p>위에서 prefix 뒤에 붙은 ‘1 2 3’의 의미는 한 글자, 두 글자, 세 글자짜리 접두어에 대한 인덱스를 미리 만들어두겠다는 뜻입니다.</p>

<p>예를 들어, apple이라는 단어가 있다면 a, ap, app에 대한 인덱스가 생성됩니다. 덕분에 사용자가 ‘app’까지만 입력해도 apple을 매우 빠르게 찾아낼 수 있습니다. 자동완성과 동일한 기능이라고 볼 수 있습니다.</p>

<h3 id="예시-2-한글-텍스트-토큰-분해-과정">예시 2. 한글 텍스트 토큰 분해 과정</h3>

<p><strong>원본 텍스트 저장</strong></p>

<p>“최고의 서울 야경 투어!”라는 원본 텍스트가 있습니다. 이 텍스트 또한 <code class="language-plaintext highlighter-rouge">text</code> 컬럼에 저장됩니다.</p>

<p><strong>토큰화 과정</strong></p>

<p>여기서 중요한 점이 있습니다. <strong><code class="language-plaintext highlighter-rouge">unicode61</code> 토크나이저는 한글의 형태소(명사, 조사 등)를 분석하는 기능이 없기 때문에, 공백과 문장 부호를 기준으로만 단어를 나눕니다.</strong></p>

<p>그러므로 최종 생성 토큰은 [최고의, 서울, 야경, 투어]가 됩니다.</p>

<p>이때 사용자가 ‘최고’라고 검색하면 어떻게 될까요? 토큰으로 저장된 결과는 ‘최고의’뿐이므로, ‘최고’라는 토큰을 찾을 수 없게 됩니다. 이것이 <code class="language-plaintext highlighter-rouge">unicode61</code> 토크나이저를 한글에 사용할 때의 한계점입니다.
그래서 일반적으로 더 정확한 한글 검색을 위해서는 별도의 한글 형태소 분석기를 FTS에 연동합니다.</p>

<p>그렇다면 궁금한 점이 생깁니다. 위에서 prefix해서 인덱스를 추가로 생성할 수 있다고 했는데, 그러면 ‘최고의’ 토큰은 [‘최’, ‘최고’, ‘최고의’] 인덱스를 가지게 되니까 ‘최고’를 검색할 때도 ‘최고의’를 찾을 수 있게 되는 거 아닌가?</p>

<p>결론부터 말씀드리면, 아쉽게도 그렇게 동작하지 않습니다.</p>

<p>이유를 명확히 이해하려면 <strong>토큰화(Tokenization)</strong>와 <strong>접두어 인덱싱(Prefix Indexing)</strong>의 역할을 정확하게 이해해야 합니다.</p>

<p>FTS에서 가장 먼저 일어나는 일은 입력된 텍스트에서 ‘단어(토큰)’가 무엇인지 정의하는 것입니다.</p>

<p>위에서 <code class="language-plaintext highlighter-rouge">unicode61</code>은 공백을 기준으로 단어를 나누므로, FTS는 이 텍스트에 최고의, 서울, 야경 이라는 3개의 단어(토큰)만 존재한다고 인식하고 저장합니다. 이 시점에서 FTS의 ‘단어 사전’에는 최고의라는 단어는 있지만, 최고라는 단어는 존재하지 않습니다. 토크나이저가 그렇게 정의했기 때문입니다.</p>

<p>이 다음에 진행되는 prefix (접두어 인덱싱)은 “결정된 단어를 빨리 찾기 위한 ‘색인’ 추가”의 역할을 합니다. 중요한 점은 <strong>‘생성된 색인이 토큰이 되지는 않는다’</strong>는 것입니다. 특정 토큰으로 이동할 수 있는 지름길을 만드는 것이지, 이미 만들어진 토큰을 글자수 단위로 더욱 세밀하게 쪼개서 토큰으로 생성하라는 의미가 아닙니다.</p>

<ul>
  <li>최고의라는 토큰에 대해: [최 -&gt; 최고의], [최고 -&gt; 최고의]로 가는 지름길을 만듭니다.</li>
  <li>서울이라는 토큰에 대해: [서 -&gt; 서울], [서울 -&gt; 서울]로 가는 지름길을 만듭니다.</li>
  <li>야경이라는 토큰에 대해: [야 -&gt; 야경], [야경 -&gt; 야경]로 가는 지름길을 만듭니다.</li>
</ul>

<p>그러므로 최나 최고가 독립적인 단어로 사전에 추가되는 것이 아니라, 오직 ‘최고의’라는 원본 단어를 더 빨리 찾기 위한 ‘색인’ 또는 ‘포인터’의 역할만 하게 됩니다.</p>

<h3 id="검색-시-어떻게-동작하는가">검색 시 어떻게 동작하는가?</h3>

<p>한글 텍스트를 기준으로 사용자가 검색을 시도하였을 때 어떻게 동작하는지 알아보겠습니다.</p>

<p><strong>CASE 1: … <code class="language-plaintext highlighter-rouge">MATCH '최고'</code> 라고 검색한 경우</strong></p>

<p>FTS는 단어 사전에서 최고라는 토큰이 완벽하게 일치하는 항목이 있는지 먼저 찾습니다. 하지만 단어 사전에는 ‘최고의’만 있을 뿐 ‘최고’라는 단어는 없습니다.</p>

<p>이때 접두어 인덱스는 사용되지 않는데요, 오직 <code class="language-plaintext highlighter-rouge">*</code> 와 함께 사용될 때만 접두어 인덱스는 활성화됩니다.</p>

<p>그러므로 결과적으로 문서를 찾지 못합니다.</p>

<p><strong>CASE 2: … <code class="language-plaintext highlighter-rouge">MATCH '최고*'</code> 라고 검색한 경우</strong></p>

<p>FTS는 검색어 끝에 <code class="language-plaintext highlighter-rouge">*</code>가 붙은 것을 보고, 접두어 인덱스를 활용한 검색을 수행합니다. 접두어 인덱스를 확인한 결과, ‘최고’라는 단어가 ‘최고의’ 토큰을 가리키는 지름길로 등록되어있음을 확인합니다.</p>

<p>이 지름길이 가리키는 ‘최고의’ 토큰이 포함된 문서를 찾아 성공적으로 반환합니다.</p>

<h2 id="fts의-장점">FTS의 장점</h2>

<p>일반적으로 사용되는 <code class="language-plaintext highlighter-rouge">WHERE content LIKE '%검색어%'</code> 방식과 FTS 방식을 간단하게 비교해보면, FTS 방식이 훨씬 빠르고 효율적이라는 것을 알 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>FTS (MATCH)</th>
      <th>일반 검색 (LIKE)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>속도</td>
      <td>매우 빠름. 미리 만들어 둔 인덱스를 사용해 검색하기 때문에 데이터가 수십만 건이 되어도 성능 저하가 거의 없습니다.</td>
      <td>매우 느림. 테이블의 모든 데이터를 하나씩 처음부터 끝까지 다 읽어서 비교(Table Full Scan)하기 때문에 데이터가 많아지면 속도가 급격히 느려집니다.</td>
    </tr>
    <tr>
      <td>정확도/기능</td>
      <td>- 단어(토큰) 단위로 검색하여 더 정확합니다.<br />- AND, OR, NOT 등 논리 연산이 가능합니다.<br />- “서울 야경”처럼 여러 단어가 가까이 있는 문서를 찾는 NEAR 검색도 가능합니다.<br />- 검색 결과의 관련도 순으로 정렬(rank)할 수 있습니다.</td>
      <td>- 단순히 문자열 포함 여부만 체크합니다.<br />- 복잡한 조건의 검색이 어렵습니다.</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[FTS5는 SQLite 데이터베이스에서 바로 이 '전문 검색' 기능을 사용할 수 있도록 해주는 강력한 확장 기능(extension)입니다. 'FTS'는 Full-Text Search의 약자입니다.]]></summary></entry><entry><title type="html">채권 가격과 금리의 관계: 왜 반대로 움직일까?</title><link href="http://localhost:4000/2025/08/03/interest-rate-bonds/" rel="alternate" type="text/html" title="채권 가격과 금리의 관계: 왜 반대로 움직일까?" /><published>2025-08-03T00:00:00+09:00</published><updated>2025-08-03T00:00:00+09:00</updated><id>http://localhost:4000/2025/08/03/interest-rate-bonds</id><content type="html" xml:base="http://localhost:4000/2025/08/03/interest-rate-bonds/"><![CDATA[<p><strong>결론: 채권의 수요가 증가하면, 채권 가격이 상승하고 시장 금리가 하락합니다.</strong></p>

<h3 id="채권의-특징">채권의 특징</h3>

<p>채권 시장을 보다 보면 이런 말을 자주 듣게 됩니다. 주식처럼 가격이 오르면 좋은 것 아닌가? 싶은데, 왜 금리는 반대로 움직이는 걸까요? 이 원리를 알기 위해선 먼저 채권의 기본 특징 한 가지를 이해해야 합니다.</p>

<p>채권은 정부(국채)나 회사(회사채)가 자금을 조달하기 위해 발행하는 일종의 ‘차용증서’입니다. 정부는 일반적으로 매달 정기적으로 경쟁입찰을 통해 국채를 발행하고, 회사는 자금이 필요한 시기에 이사회의 결정을 거쳐 비정기적으로 회사채를 발행합니다.</p>

<p>채권의 대표적인 특징은 아래와 같습니다.</p>

<ul>
  <li><strong>채권은 발행 시점에 이자와 총량이 고정</strong>된다는 점입니다.</li>
  <li><strong>한번 발행된 채권은 만기가 되기 전까지 주식처럼 시장에서 자유롭게 거래됩니다.</strong></li>
  <li>채권은 발행될 때 지급하기로 약속한<strong>표면 이자율과 이자액이 절대 변하지 않습니다</strong>.</li>
</ul>

<p>특히 마지막 특징인 ‘변하지 않는 표면 이자율과 이자액’이 어떻게 채권 가격과 금리를 반대로 움직이게 만드는지 구체적인 예시로 살펴보겠습니다.</p>

<h3 id="고정된-이자-vs-변동하는-가격">고정된 이자 vs 변동하는 가격</h3>

<p>여기, A회사가 발행한 채권이 있다고 가정해 봅시다.</p>

<ul>
  <li><strong>채권 가격(발행가):</strong> 10,000원</li>
  <li><strong>표면 이자율:</strong> 연 5% (매년 500원의 이자를 지급하기로 약속)</li>
</ul>

<p>이 채권을 발행가인 10,000원에 샀다면, 투자 수익률은 약속 그대로 연 5%입니다.</p>

<p>그런데 이 A회사가 유망하다는 소문이 나면서 채권을 사려는 사람(수요)이 몰렸습니다. 한정된 채권을 사기 위한 경쟁이 붙으면서, 시장 가격이 <strong>10,000원에서 12,000원으로 올랐습니다.</strong></p>

<p>이때 채권의 시장 가격은 12,000원으로 올랐지만, A회사가 지급하기로 약속한 <strong>이자액은 여전히 500원으로 고정</strong>되어 있습니다.</p>

<p>그렇다면 지금 12,000원을 주고 이 채권을 산 사람의 실제 수익률은 어떻게 될까요?</p>

<ul>
  <li><strong>발행 시점 수익률:</strong> 500원 ÷ 10,000원 = <strong>5%</strong></li>
  <li><strong>가격 상승 후 수익률:</strong> 500원 ÷ 12,000원 = <strong>약 4.16%</strong></li>
</ul>

<p>이처럼 채권 가격이 오르니, 투자금 대비 실제 얻게 되는 <strong>‘수익률’은 오히려 떨어졌습니다.</strong> 경제 뉴스에서 말하는 시장 금리는 바로 채권의 실제 수익률을 의미하는 경우가 많습니다. 즉 채권 가격이 오르면서, <strong>금리가 하락(5% → 4.16%)했다고 평가하게 됩니다.</strong></p>]]></content><author><name>Wonjoon</name></author><category term="investment" /><summary type="html"><![CDATA[채권 가격이 오르면 왜 시장 금리는 하락하는지, 그 역학 관계를 설명합니다.]]></summary></entry><entry><title type="html">Go 에러 처리: fmt.Errorf는 언제, 어떻게 사용해야 할까요?</title><link href="http://localhost:4000/2025/06/23/fmt-error-handling/" rel="alternate" type="text/html" title="Go 에러 처리: fmt.Errorf는 언제, 어떻게 사용해야 할까요?" /><published>2025-06-23T00:00:00+09:00</published><updated>2025-06-23T00:00:00+09:00</updated><id>http://localhost:4000/2025/06/23/fmt-error-handling</id><content type="html" xml:base="http://localhost:4000/2025/06/23/fmt-error-handling/"><![CDATA[<h2 id="핵심-요약-tldr">핵심 요약 (TL;DR)</h2>

<ul>
  <li><strong>언제 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 쓰면 안 되나요?</strong>
    <ul>
      <li>라이브러리(예: <code class="language-plaintext highlighter-rouge">backoff.Retry</code>)가 에러의 종류를 파악해야 할 때. <strong>원본 에러를 그대로 반환</strong>해야 라이브러리와의 ‘약속’을 지킬 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>언제 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 써야 하나요?</strong>
    <ul>
      <li>모든 재시도 등 정책적 판단이 끝난 후, 최종적으로 에러를 반환하는 시점. <strong>“재시도 끝에 실패”와 같은 명확한 맥락(Context)을 추가</strong>하기 위해 사용합니다.</li>
    </ul>
  </li>
  <li><strong>가장 중요한 원칙은 무엇인가요?</strong>
    <ul>
      <li><strong>역할 분리</strong>. 에러를 발생시키는 ‘실무자’ 함수와, 그 에러를 받아 정책을 결정하는 ‘매니저’ 함수로 역할을 나누고 각 계층에 맞는 책임을 부여하는 것입니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="질문-1-fmterrorf를-무조건-사용하면-왜-안-되나요">질문 1: <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>를 무조건 사용하면 왜 안 되나요?</h2>

<p>많은 Go 개발자가 외부 API 호출과 같은 불안정한 작업을 처리할 때 <code class="language-plaintext highlighter-rouge">cenk/backoff</code> 같은 라이브러리로 재시도 로직을 구현합니다. 이때 모든 에러를 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>로 감싸는 실수를 하곤 합니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">doRetry</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span><span class="n">Client</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ...</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">backoff</span><span class="o">.</span><span class="n">Retry</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
		<span class="n">bs</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span> <span class="c">// &lt;-- 여기서는 원본 에러를 그대로 반환</span>
	<span class="p">},</span> <span class="o">...</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="c">// &lt;-- 여기서는 컨텍스트를 추가하여 반환</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"failed after retries %w"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bs</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>결론부터 말하면, <strong>라이브러리가 에러의 종류를 보고 특정 행동(예: 재시도 중단)을 결정해야 할 때, <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>로 에러를 감싸면 원본 에러의 정보가 가려져 라이브러리가 올바르게 동작하지 못하기 때문입니다.</strong></p>

<h2 id="질문-2-어떻게-역할을-분리해야-하나요">질문 2: 어떻게 역할을 분리해야 하나요?</h2>

<p>견고한 에러 처리는 함수의 역할을 ‘실무자’와 ‘매니저’로 명확히 나누는 것에서 시작합니다.</p>

<ul>
  <li>실무자 (<code class="language-plaintext highlighter-rouge">do</code> 함수): 실제 작업을 딱 한 번 수행하고, 그 결과를 가공하지 않은 원본 에러 그대로 보고하는 역할만 합니다.</li>
  <li>매니저 (<code class="language-plaintext highlighter-rouge">doRetry</code> 함수): 실무자의 보고(원본 에러)를 받아 정책적 결정을 내립니다. 예를 들어 ‘일시적 오류’는 재시도, ‘영구적 오류’는 즉시 중단 같은 결정을 합니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">backoff.Retry</code> 라이브러리는 매니저의 ‘비서’와 같습니다. 비서는 실무자가 제출한 원본 에러 보고서에 <code class="language-plaintext highlighter-rouge">backoff.PermanentError</code> 같은 특정 도장이 찍혀 있는지 확인합니다. 만약 <code class="language-plaintext highlighter-rouge">fmt.Errorf</code>라는 별도의 봉투에 담아 보고하면, 비서는 중요한 도장을 보지 못하고 재시도하면 안 되는 일에 불필요한 노력을 쏟게 됩니다.</p>

<p>이것이 <code class="language-plaintext highlighter-rouge">backoff.Retry</code> 안에서는 원본 에러(<code class="language-plaintext highlighter-rouge">return err</code>)를 그대로 반환해야 하는 이유입니다. 라이브러리와의 약속(Contract)을 지키는 것이죠.</p>

<h2 id="질문-3-에러에-컨텍스트는-언제-추가해야-가장-좋은가요">질문 3: 에러에 컨텍스트는 언제 추가해야 가장 좋은가요?</h2>

<p>“재시도 끝에 실패했다”와 같은 구체적인 맥락은 <strong>매니저가 모든 정책적 판단을 끝낸 시점</strong>에 추가하는 것이 가장 좋습니다.</p>

<p><code class="language-plaintext highlighter-rouge">doRetry</code> 함수는 <code class="language-plaintext highlighter-rouge">backoff.Retry</code>가 최종적으로 실패했을 때, 비로소 <code class="language-plaintext highlighter-rouge">fmt.Errorf("failed after retries %w", err)</code>를 통해 더 자세한 컨텍스트를 담은 최종 에러를 생성하여 상위 호출자에게 반환합니다.</p>

<blockquote>
  <p><strong>Go 에러 처리 철학</strong>: 에러가 발생한 가장 낮은 수준에서는 원본을 유지하고, 계층을 따라 올라오며 각 계층의 역할에 맞는 컨텍스트를 추가합니다.</p>
</blockquote>

<h2 id="질문-4-defer를-사용할-때-에러는-어떻게-처리해야-하나요">질문 4: <code class="language-plaintext highlighter-rouge">defer</code>를 사용할 때 에러는 어떻게 처리해야 하나요?</h2>

<p><code class="language-plaintext highlighter-rouge">defer</code>로 리소스를 정리할 때 발생하는 에러를 놓치지 않으면서, 더 중요한 원인 에러를 덮어쓰지 않는 것이 중요합니다. 아래는 매우 실용적인 Go의 표준 패턴(idiomatic Go)입니다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">do</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="n">bs</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">st</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="c">// &lt;-- 1. 반환 값을 'err'로 명명</span>
    <span class="c">// ...</span>
    <span class="c">// http 요청 등 주요 로직</span>
    <span class="c">// ...</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">closeErr</span> <span class="o">:=</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">();</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="c">// &lt;-- 2. 기존 에러가 없을 때만</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">closeErr</span> <span class="c">// &lt;-- 3. 뒷정리 에러를 최종 에러로 할당</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="c">// ...</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 패턴의 핵심은 <code class="language-plaintext highlighter-rouge">if err == nil</code> 조건입니다.</p>

<ul>
  <li>주요 로직에서 에러가 없었을 경우 (<code class="language-plaintext highlighter-rouge">err</code>가 <code class="language-plaintext highlighter-rouge">nil</code>일 때): defer문에서 발생한 뒷정리 에러(<code class="language-plaintext highlighter-rouge">closeErr</code>)를 최종 반환 에러로 삼습니다.</li>
  <li>주요 로직에서 이미 에러가 발생했을 경우 (<code class="language-plaintext highlighter-rouge">err</code>가 <code class="language-plaintext highlighter-rouge">nil</code>이 아닐 때): 덜 중요한 뒷정리 에러는 무시하고, 더 중요한 최초의 원인 에러를 그대로 보존하여 반환합니다.</li>
</ul>

<p>이는 “함수가 실패했다면, 그 최초의 원인을 보존하라”는 Go의 중요한 에러 처리 철학을 잘 보여줍니다</p>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Go 언어에서 fmt.Errorf를 올바르게 사용하는 방법을 알아봅니다. 모든 에러를 fmt.Errorf로 감싸는 것이 왜 안티 패턴인지, 재시도 로직과 에러 래핑(wrapping)의 모범 사례를 실제 코드를 통해 명확히 설명합니다.]]></summary></entry><entry><title type="html">Using labels while looping in Rust: Breaking or Continuing Exactly Where You Mean To</title><link href="http://localhost:4000/2025/03/22/expression-block-closure/" rel="alternate" type="text/html" title="Using labels while looping in Rust: Breaking or Continuing Exactly Where You Mean To" /><published>2025-03-22T00:00:00+09:00</published><updated>2025-03-22T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/22/expression-block-closure</id><content type="html" xml:base="http://localhost:4000/2025/03/22/expression-block-closure/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#why-use-loop-labels-in-rust">Why Use Loop Labels in Rust?</a></li>
  <li><a href="#using-loop-with-labels">Using loop with labels</a></li>
  <li><a href="#using-while-with-labels">Using while with labels</a></li>
  <li><a href="#using-for-with-labels">Using for with labels</a></li>
  <li><a href="#using-continue-with-labels">Using continue with labels</a></li>
  <li><a href="#summary">Summary</a></li>
</ul>

<h2 id="why-use-loop-labels-in-rust">Why Use Loop Labels in Rust?</h2>

<p>When you have nested loops, calling <code class="language-plaintext highlighter-rouge">break</code> or <code class="language-plaintext highlighter-rouge">continue</code> may only affect the nearest loop.
If you want to target an outer loop, Rust lets you assign a label using the <code class="language-plaintext highlighter-rouge">label_name:</code> syntax.</p>

<h2 id="using-loop-with-labels">Using loop with labels</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nv">'counting_up</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"count = {count}"</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">remaining</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"remaining = {remaining}"</span><span class="p">);</span>
            
            <span class="k">if</span> <span class="n">remaining</span> <span class="o">==</span> <span class="mi">9</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span> <span class="c1">// exits this inner loop only</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="k">break</span> <span class="nv">'counting_up</span><span class="p">;</span> <span class="c1">// exits the labeled outer loop</span>
            <span class="p">}</span>

            <span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"End count = {count}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">break</code> exits the inner loop</li>
  <li><code class="language-plaintext highlighter-rouge">break 'counting_up</code> exits the outer labeled loop</li>
  <li>You can apply labels to any loop, not just loop blocks</li>
</ul>

<h2 id="using-while-with-labels">Using while with labels</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nv">'outer</span><span class="p">:</span> <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="k">break</span> <span class="nv">'outer</span><span class="p">;</span> <span class="c1">// exits the outer while loop</span>
            <span class="p">}</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Done: i = {i}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="using-for-with-labels">Using for with labels</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nv">'outer</span><span class="p">:</span> <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="k">break</span> <span class="nv">'outer</span><span class="p">;</span> <span class="c1">// exits the outer for loop</span>
            <span class="p">}</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"x = {x}, y = {y}"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="using-continue-with-labels">Using continue with labels</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">'outer</span><span class="p">:</span> <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">continue</span> <span class="nv">'outer</span><span class="p">;</span> <span class="c1">// skips rest of inner loop and moves to next outer iteration</span>
        <span class="p">}</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"x = {x}, y = {y}"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>break</td>
      <td>Exits the nearest loop</td>
    </tr>
    <tr>
      <td>break ‘label</td>
      <td>Exits the specific loop with the given label</td>
    </tr>
    <tr>
      <td>continue ‘label</td>
      <td>Skips to the next iteration of the labeled loop</td>
    </tr>
    <tr>
      <td>Label works on</td>
      <td><code class="language-plaintext highlighter-rouge">loop</code>, <code class="language-plaintext highlighter-rouge">while</code>, <code class="language-plaintext highlighter-rouge">for</code>, and <code class="language-plaintext highlighter-rouge">continue</code></td>
    </tr>
  </tbody>
</table>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[Rust allows you to label loops and precisely control break and continue flow — even across nested loop, while, and for blocks. Learn how to avoid confusion in complex loop structures with simple, powerful labels.]]></summary></entry><entry><title type="html">Expression Blocks vs Closures in Rust – What’s the Difference?</title><link href="http://localhost:4000/2025/03/22/add-label-in-loop/" rel="alternate" type="text/html" title="Expression Blocks vs Closures in Rust – What’s the Difference?" /><published>2025-03-22T00:00:00+09:00</published><updated>2025-03-22T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/22/add-label-in-loop</id><content type="html" xml:base="http://localhost:4000/2025/03/22/add-label-in-loop/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#expression-blocks-vs-closures">Expression Blocks vs Closures</a>
    <ul>
      <li><a href="#key-differences">Key Differences</a></li>
      <li><a href="#expression-blocks-inline-one-time-calculations">Expression Blocks: Inline One-Time Calculations</a></li>
      <li><a href="#closures-anonymous-functions-for-reuse-and-flexibility">Closures: Anonymous Functions for Reuse and Flexibility</a></li>
    </ul>
  </li>
  <li><a href="#comparison-with-go">Comparison with Go</a></li>
  <li><a href="#summary-when-to-use-what">Summary: When to Use What?</a></li>
</ul>

<h2 id="expression-blocks-vs-closures">Expression Blocks vs Closures</h2>

<h3 id="key-differences">Key Differences</h3>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Expression Block</th>
      <th>Closure</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>What it is</td>
      <td>Inline calculation block</td>
      <td>Anonymous function</td>
    </tr>
    <tr>
      <td>Execution timing</td>
      <td>Immediately</td>
      <td>When called</td>
    </tr>
    <tr>
      <td>Parameters</td>
      <td>Not allowed</td>
      <td>Allowed</td>
    </tr>
    <tr>
      <td>Captures outer variables</td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Reusable</td>
      <td>One-time</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Passable to other funcs</td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Return value</td>
      <td>Last expression</td>
      <td>Last expression</td>
    </tr>
  </tbody>
</table>

<h3 id="expression-blocks-inline-one-time-calculations">Expression Blocks: Inline One-Time Calculations</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
<span class="p">};</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{y}"</span><span class="p">);</span> <span class="c1">// 15</span>
</code></pre></div></div>

<ul>
  <li>Block used just for computing a value</li>
  <li>Executed immediately</li>
  <li>Returns the last expression (no semicolon)</li>
  <li>Does not take parameters or capture external variables</li>
  <li>Great for one-off logic that doesn’t need to be reused</li>
</ul>

<h4 id="when-to-use-expression-blocks">When to Use Expression Blocks</h4>

<ul>
  <li>You need a value from a mini logic block</li>
  <li>You don’t need parameters</li>
  <li>You want instant evaluation</li>
  <li>You’re not planning to reuse the logic</li>
</ul>

<h4 id="example-using-if-match-or-even-loop-as-a-value">Example: Using if, match, or even loop as a value</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">is_even</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">true</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">false</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">match</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="k">=&gt;</span> <span class="s">"one"</span><span class="p">,</span>
    <span class="mi">2</span> <span class="k">=&gt;</span> <span class="s">"two"</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="s">"many"</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">let</span> <span class="n">loop_value</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span> <span class="k">break</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// loop_value == 30</span>
</code></pre></div></div>

<p><strong>Note: <code class="language-plaintext highlighter-rouge">while</code> and <code class="language-plaintext highlighter-rouge">for</code> are statements, not expressions — they can’t be used like this.</strong></p>

<h3 id="closures-anonymous-functions-for-reuse-and-flexibility">Closures: Anonymous Functions for Reuse and Flexibility</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="o">=</span> <span class="p">|</span><span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 7</span>
</code></pre></div></div>

<ul>
  <li>Similar to anonymous functions in Go, JavaScript, etc.</li>
  <li>Executed only when called</li>
  <li>Can take parameters and capture external variables</li>
  <li>Useful when passing logic into another function (e.g. <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>)</li>
  <li>Can be reused multiple times</li>
</ul>

<h4 id="when-to-use-closures">When to Use Closures</h4>

<ul>
  <li>You need to reuse logic</li>
  <li>You want to pass logic as a parameter to another function</li>
  <li>You need to delay execution</li>
  <li>You need to capture external values</li>
</ul>

<h4 id="common-use-cases">Common Use Cases</h4>

<h5 id="1-parameterized-logic">1. Parameterized Logic</h5>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">square</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="c1">// 25</span>
</code></pre></div></div>

<h5 id="2-passing-to-higher-order-functions">2. Passing to Higher-Order Functions</h5>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">nums</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="k">let</span> <span class="n">doubled</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
<span class="c1">// Result: [2, 4, 6]</span>
</code></pre></div></div>

<h5 id="3-threaded-or-async-code">3. Threaded or Async Code</h5>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello from thread"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h5 id="4-capturing-external-variables">4. Capturing External Variables</h5>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">"Hi"</span><span class="p">;</span>
<span class="k">let</span> <span class="n">say_hello</span> <span class="o">=</span> <span class="p">|</span><span class="n">name</span><span class="p">|</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{greeting}, {name}"</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">say_hello</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">));</span> <span class="c1">// "Hi, Alice"</span>
</code></pre></div></div>

<h2 id="comparison-with-go">Comparison with Go</h2>

<p>Go only has function literals (<code class="language-plaintext highlighter-rouge">func() { ... }</code>) — no concept of expression blocks as values.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="o">:=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">val</span><span class="p">()</span> <span class="c">// Must be called</span>
</code></pre></div></div>

<p>In Rust:</p>

<ul>
  <li>Use closures for what you’d use <code class="language-plaintext highlighter-rouge">func() { ... }</code> in Go</li>
  <li>Use expression blocks for inline logic to assign values quickly</li>
</ul>

<h2 id="summary-when-to-use-what">Summary: When to Use What?</h2>

<table>
  <thead>
    <tr>
      <th>Situation</th>
      <th>Use</th>
      <th>Why</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Simple inline calculation</td>
      <td>Expression block</td>
      <td>Less syntax, faster execution</td>
    </tr>
    <tr>
      <td>Passing logic to another function</td>
      <td>Closure</td>
      <td>Closures are first-class citizens</td>
    </tr>
    <tr>
      <td>Accepting dynamic inputs</td>
      <td>Closure</td>
      <td>Accepting dynamic inputs</td>
    </tr>
    <tr>
      <td>Passing logic to another function</td>
      <td>Closure</td>
      <td>Closures take parameters</td>
    </tr>
    <tr>
      <td>Referencing external values</td>
      <td>Closure</td>
      <td>Can capture and use outer scope</td>
    </tr>
    <tr>
      <td>Like func() in Go</td>
      <td>Closure</td>
      <td>Closures = Go’s anonymous functions</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[In Rust, both expression blocks ({}) and closures (|| {}) can return values — but they serve different purposes. This post breaks down their differences, when to use each, and how they compare to Go’s func().]]></summary></entry><entry><title type="html">Understanding String Types in Rust and Go</title><link href="http://localhost:4000/2025/03/20/rust-about-string-type/" rel="alternate" type="text/html" title="Understanding String Types in Rust and Go" /><published>2025-03-20T00:00:00+09:00</published><updated>2025-03-20T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/20/rust-about-string-type</id><content type="html" xml:base="http://localhost:4000/2025/03/20/rust-about-string-type/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#strings-in-rust">Strings in Rust</a></li>
  <li><a href="#strings-in-go">Strings in Go</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="strings-in-rust">Strings in Rust</h2>

<h3 id="str--string-slice">&amp;str – String Slice</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span> <span class="c1">// &amp;str</span>
</code></pre></div></div>

<ul>
  <li>Immutable, read-only reference to a string</li>
  <li>Stored in static memory (binary section)</li>
  <li>Does not use the heap</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span> 
<span class="c1">// s points to the memory address of the "hello" string</span>

<span class="n">s</span> <span class="o">=</span> <span class="s">"bye"</span><span class="p">;</span>
<span class="c1">// s now points to a new memory address for "bye"</span>
<span class="c1">// The value isn't modified — the reference changes</span>

<span class="c1">// diagram</span>
<span class="c1">// "string type variable only points to the memory address"</span>
<span class="c1">// s -&gt; 0x1234["hello"] </span>
<span class="c1">// s -&gt; 0x5678["bye"]</span>
</code></pre></div></div>

<h3 id="string--heap-allocated-mutable-string">String – Heap-Allocated Mutable String</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>Mutable, owns the data</li>
  <li>Stored on the heap</li>
  <li>You can modify it using methods like .push_str() and .clear()</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> 
<span class="c1">// creates an empty string</span>

<span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span> <span class="c1">// compile error — not mutable</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">s2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> <span class="c1">// mutable</span>

<span class="n">s2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="n">s2</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" world"</span><span class="p">);</span>      <span class="c1">// "hello world"</span>
</code></pre></div></div>

<h2 id="strings-in-go">Strings in Go</h2>

<h3 id="string">string</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span> <span class="o">:=</span> <span class="s">"first"</span>
<span class="n">test</span> <span class="o">=</span> <span class="s">"second"</span>
</code></pre></div></div>

<ul>
  <li>Immutable value type</li>
  <li>Internally, a string is just a struct with a byte pointer and length:</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">string</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">*</span><span class="kt">byte</span>
    <span class="nb">len</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Assigning a new string creates a new string object in memory</li>
  <li>You cannot modify part of a string directly</li>
</ul>

<h3 id="how-to-modify-strings-in-go">How to “Modify” Strings in Go</h3>

<p>To modify a string in Go, convert it into a mutable byte slice:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">:=</span> <span class="s">"hello"</span>
<span class="n">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>   <span class="c">// Convert to byte slice</span>
<span class="n">b</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'H'</span>       <span class="c">// Modify</span>
<span class="n">s2</span> <span class="o">:=</span> <span class="kt">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c">// Convert back to string</span>

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>  <span class="c">// "Hello"</span>
</code></pre></div></div>

<h2 id="rust-vs-go-strings-at-a-glance">Rust vs Go: Strings at a Glance</h2>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>Go</th>
      <th>Rust</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Immutable string</td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td><code class="language-plaintext highlighter-rouge">&amp;str</code></td>
    </tr>
    <tr>
      <td>Mutable string (heap allocated)</td>
      <td><code class="language-plaintext highlighter-rouge">[]byte</code>, <code class="language-plaintext highlighter-rouge">[]rune</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
    </tr>
    <tr>
      <td>Modify string variable (new value)</td>
      <td>s = “new”</td>
      <td>s = <code class="language-plaintext highlighter-rouge">String::from(...)</code></td>
    </tr>
    <tr>
      <td>Modify string content</td>
      <td>via <code class="language-plaintext highlighter-rouge">[]byte</code> conversion</td>
      <td>via mutable <code class="language-plaintext highlighter-rouge">String</code></td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>In both Rust and Go, default strings are immutable — they point to memory, but do not allow direct content modification.</li>
  <li>To change the content of a <code class="language-plaintext highlighter-rouge">string</code>:
    <ul>
      <li>In Rust, use a mutable <code class="language-plaintext highlighter-rouge">String</code></li>
      <li>In Go, convert to <code class="language-plaintext highlighter-rouge">[]byte</code> or <code class="language-plaintext highlighter-rouge">[]rune</code></li>
    </ul>
  </li>
  <li>If you’re just changing the entire string value, you’re assigning a new memory reference either way.</li>
  <li>Rust gives more fine-grained control over memory and mutability, while Go keeps things simple but less flexible when it comes to string manipulation.</li>
</ul>]]></content><author><name>Wonjoon</name></author><category term="dev" /><summary type="html"><![CDATA[In this post, we compare how strings work in Rust and Go — especially in terms of mutability, memory handling, and how to modify them. If you’ve ever wondered why Rust has both &str and String, or why Go strings can’t be changed directly, this breakdown is for you.]]></summary></entry><entry><title type="html">맥북 10년 차 개발자가 전하는 구매 가이드</title><link href="http://localhost:4000/2025/03/20/macbook-purchase-guide/" rel="alternate" type="text/html" title="맥북 10년 차 개발자가 전하는 구매 가이드" /><published>2025-03-20T00:00:00+09:00</published><updated>2025-03-20T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/20/macbook-purchase-guide</id><content type="html" xml:base="http://localhost:4000/2025/03/20/macbook-purchase-guide/"><![CDATA[<p>이 포스트의 전체 내용은 <a href="https://brunch.co.kr/@wallee/20">외부 링크</a>에서 확인하실 수 있습니다.</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[맥북 구매를 고민하는 개발자와 입문자를 위한 10년 차 개발자의 현실적인 구매 가이드. 나에게 맞는 모델 선택, 사양 결정, 그리고 필수 확인 사항까지 담았습니다.]]></summary></entry><entry><title type="html">Should You Really Get a MacBook?</title><link href="http://localhost:4000/2025/03/19/macbook-purchase-guidline/" rel="alternate" type="text/html" title="Should You Really Get a MacBook?" /><published>2025-03-19T00:00:00+09:00</published><updated>2025-03-19T00:00:00+09:00</updated><id>http://localhost:4000/2025/03/19/macbook-purchase-guidline</id><content type="html" xml:base="http://localhost:4000/2025/03/19/macbook-purchase-guidline/"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#target-readers">Target Readers</a></li>
  <li><a href="#introduction-so-many-laptops-why-macbook">Introduction: So Many Laptops, Why MacBook?</a></li>
  <li><a href="#macbooks-are-pretty-period">MacBooks Are Pretty. Period</a></li>
  <li><a href="#is-a-macbook-necessary-for-developers">Is a MacBook Necessary for Developers?</a></li>
  <li><a href="#the-ill-use-it-forever-justification">The “I’ll Use It Forever” Justification</a></li>
  <li><a href="#is-macos-hard-to-use">Is macOS Hard to Use?</a></li>
  <li><a href="#the-hidden-costs-accessories--compatibility">The Hidden Costs: Accessories &amp; Compatibility</a></li>
  <li><a href="#but-what-about-apple-ecosystem--aesthetics">But What About Apple Ecosystem &amp; Aesthetics?</a></li>
  <li><a href="#can-you-game-on-a-mac">Can You Game on a Mac?</a></li>
  <li><a href="#final-thoughts">Final Thoughts</a></li>
</ul>

<h2 id="target-readers">Target Readers</h2>

<ul>
  <li>Aspiring developers</li>
  <li>Students looking to buy their first laptop</li>
  <li>Non-tech users who still want a cool MacBook</li>
</ul>

<h2 id="introduction-so-many-laptops-why-macbook">Introduction: So Many Laptops, Why MacBook?</h2>

<p>Back in my college days, ThinkPads (a.k.a. the famous red-dotted “bbalkkong”) were the go-to laptops for CS majors. Brands like Dell and HP were also quite popular. Out of patriotism (and practicality), I chose a lightweight 11-inch LG laptop.</p>

<p>Then came the game-changer: the 13-inch Retina MacBook in 2014. I saw that crisp screen once and was sold.</p>

<p>Since then, for over 10 years, my main work machine has always been a MacBook. But now that MacBooks are more popular than ever — especially among developers — it’s worth asking…</p>

<p><strong>“Do you really need a MacBook to become a developer?”</strong></p>

<h2 id="macbooks-are-pretty-period">MacBooks Are Pretty. Period</h2>

<p>Let’s get real. One of the strongest appeals of a MacBook is its beauty. It’s not just a laptop — it’s a fashion statement, a status symbol, and yes, a design masterpiece.</p>

<p>From “Why would you get that overpriced laptop?” to “You must have a MacBook to code!” — the perception of the MacBook in Korea and beyond has changed drastically.</p>

<p>Yes, Apple’s silicon chips are powerful. Yes, Windows laptops are getting pricier too. But ultimately…</p>

<p><strong>“You buy a MacBook first because it looks amazing.”</strong></p>

<p>And honestly, that’s okay.</p>

<h2 id="is-a-macbook-necessary-for-developers">Is a MacBook Necessary for Developers?</h2>

<p>Many say that since macOS is Unix-based, it’s easier for developers — especially those working with Linux servers. That was definitely true… in the past.</p>

<p>But Windows has caught up. With WSL2 (Windows Subsystem for Linux), you can run full Linux environments natively on Windows — no need for virtual machines or complex setups.</p>

<p>Plus, Apple’s shift to ARM-based chips (M1, M2, M3, etc.) created some compatibility issues with traditional x86 Linux environments. While tools like Docker help mitigate that, it’s not all smooth sailing.</p>

<p><strong>“A MacBook might not always be better — just different.”</strong></p>

<p>So no, being a developer doesn’t require a MacBook. Windows with WSL is now more than capable — and in some cases, even better suited for server-side development.</p>

<h2 id="the-ill-use-it-forever-justification">The “I’ll Use It Forever” Justification</h2>

<p>It’s common to see questions like:</p>

<p><strong>“I’m just learning to code now… should I max out the CPU and RAM?”</strong></p>

<p>My take? No. Unless you’re editing 8K videos or training AI models, a base model MacBook Air is more than enough.</p>

<p>I’ve used the 2020 M1 MacBook Pro for over 4 years with zero issues — and I’m a professional developer.</p>

<p><strong>“Buy for your current needs. Upgrade later if you actually need to.”</strong></p>

<p>And yes, 16-inch models look cool, but they’re heavy. If you commute on foot or public transport, go 14-inch or smaller.</p>

<h2 id="is-macos-hard-to-use">Is macOS Hard to Use?</h2>

<p>For lifelong Windows users: yes, at first. macOS does things differently — keyboard shortcuts, window management, file system, etc.</p>

<p>But you’ll adapt. Humans are adaptable creatures.</p>

<p>If you’re used to Microsoft Office or specific Korean software, there might be hiccups — but these days, most major apps support macOS just fine.</p>

<p>And yes, macOS no longer struggles with Korean fonts or certificates. That ship has sailed.</p>

<p><img src="https://github.com/user-attachments/assets/cd97cb20-e494-43cc-8167-484784e28a2b" alt="Image" />
@ <a href="https://www.apple.com/kr/macbook-pro/mac-does-that/">And Apple says you can easily switch from Windows to macOS :)</a>.</p>

<h2 id="the-hidden-costs-accessories--compatibility">The Hidden Costs: Accessories &amp; Compatibility</h2>

<p>You might need to buy extra accessories.</p>

<ul>
  <li>USB hubs, dongles, adapters — they add up.</li>
  <li>Cheaper accessories can cause damage. Get reputable brands.</li>
</ul>

<p>Windows on Mac? Not easy anymore.</p>

<ul>
  <li>Since Apple moved to their own chips, BootCamp is gone.</li>
  <li>You’ll need virtualization software (like Parallels), and even that costs money -  plus a Windows license.</li>
</ul>

<h2 id="but-what-about-apple-ecosystem--aesthetics">But What About Apple Ecosystem &amp; Aesthetics?</h2>

<p>Some say:</p>

<p><strong>“If you have an iPhone, iPad, AirPods — you should definitely get a MacBook too.”</strong></p>

<p>Not necessarily.</p>

<p>Sure, continuity features like AirDrop or shared clipboard are nice. But you won’t lose much by not having them either.</p>

<p>You don’t need to complete the Apple Infinity Gauntlet.</p>

<p>Also: yes, it looks amazing at Starbucks. My wife uses a Galaxy Book, I still take my MacBook.</p>

<h2 id="can-you-game-on-a-mac">Can You Game on a Mac?</h2>

<p>Short answer: You can. Long answer: It’s not ideal, but it’s getting better.</p>

<p>Cloud gaming, browser-based games, and new compatibility layers (like Wine, Crossover, etc.) help. But if you’re a serious gamer? Stick with Windows.</p>

<p><strong>“But hey, long gaming sessions aren’t healthy anyway.”</strong></p>

<h2 id="final-thoughts">Final Thoughts</h2>

<p>I’ve used MacBooks for over 10 years — and never regretted it. But that doesn’t mean it’s the right choice for everyone.</p>

<p>Here’s what I’ll say:</p>

<p>Get a MacBook if:</p>

<ul>
  <li>You love the design</li>
  <li>You want a reliable, well-optimized device</li>
  <li>You value battery life and quiet operation</li>
  <li>You’re okay adapting to macOS</li>
</ul>

<p>Don’t get one if:</p>

<ul>
  <li>You’re on a tight budget</li>
  <li>You need specific Windows-only software</li>
  <li>You game a lot</li>
</ul>

<p>Buy what fits your budget and purpose. Don’t overthink it. And remember — MacBooks are not mandatory for developers.</p>

<p>Hope this post helps you make a better decision!</p>]]></content><author><name>Wonjoon</name></author><category term="essay" /><summary type="html"><![CDATA[Just because it’s expensive doesn’t mean it’s the right choice — and a MacBook might not be the answer for everyone. This post explores whether a MacBook truly fits your needs, budget, and lifestyle — especially if you’re a student or aspiring developer.]]></summary></entry></feed>