<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-26T21:59:42+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">월리의 탐구생활</title><subtitle>A (nearly) no-CSS, fast, minimalist Jekyll theme.
</subtitle><author><name>Wonjoon</name></author><entry><title type="html">가스비 절감의 효과를 갖는 솔리디티의 custom error</title><link href="http://localhost:4000/2023/08/22/blockchain-custom-error-solidity/" rel="alternate" type="text/html" title="가스비 절감의 효과를 갖는 솔리디티의 custom error" /><published>2023-08-22T00:00:00+09:00</published><updated>2023-08-22T00:00:00+09:00</updated><id>http://localhost:4000/2023/08/22/blockchain-custom-error-solidity</id><content type="html" xml:base="http://localhost:4000/2023/08/22/blockchain-custom-error-solidity/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커스텀-에러&quot;&gt;커스텀 에러&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ethereum/solidity/releases/tag/v0.8.4&quot;&gt;솔리디티 v0.8.4&lt;/a&gt;에서 소개된 방법으로, 기존의 에러 표현 방식에 비해 가스비를 줄이면서 에러 발생의 원인을 설명할 수 있다.&lt;br /&gt;
아래는 기존의 방식과 커스텀 에러 방식 각각을 예시로 표현한 내용이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Before
revert(&quot;Insufficient funds.&quot;); // 사용 (선언 없음)

# Custom errors
error Unauthorized(); // 선언
...
revert Unauthorized(); // 사용
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;가스비는 스마트 컨트랙트의 배포(deploy)에 영향을 주는데, 이 외에도 기존의 방식은 에러에 대한 정보를 동적으로 관리하기 어렵다는 단점이 있었다.&lt;br /&gt;
커스텀 에러는 ‘error’ 구문을 사용한다. 그리고 외부(인터페이스 또는 라이브러리)에서 선언한 에러를 스마트 컨트랙트에 불러와서 사용할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized(); // Custom error

contract VendingMachine {
    address payable owner = payable(msg.sender);

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();  // Using custom error with revert statement

        owner.transfer(address(this).balance);
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/contracts.html?color=dark#events&quot;&gt;이벤트(event)&lt;/a&gt;와 구문이 비슷한 것을 볼 수 있는데, 차이점은 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/control-structures.html?color=dark#revert-statement&quot;&gt;revert 구문&lt;/a&gt;과 같이 사용해야 한다는 것이다. revert를 사용하면 현재까지 진행되던 상태 변환 프로세스가 모두 중단되고 에러 메시지를 호출자에게 전달한다. &lt;a href=&quot;https://github.com/ethereum/solidity/issues/11278&quot;&gt;require 구문의 사용은 현재 포스팅 시점(2023.08.23)에는 제공되지 않고 있는데&lt;/a&gt;, 아래의 예시를 보면 이해가 쉬울 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This Error message with require statement 
require(condition, &quot;error message&quot;)

# Should be translated to
if (!condition) revert CustomError()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;파라미터를-추가한-커스텀-에러&quot;&gt;파라미터를 추가한 커스텀 에러&lt;/h2&gt;

&lt;p&gt;커스텀 에러는 파라미터를 추가할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

/// Insufficient balance for transfer. Needed `required` but only
/// `available` available.
/// @param available balance available.
/// @param required requested amount to transfer.
error InsufficientBalance(uint256 available, uint256 required);

contract TestToken {
    mapping(address =&amp;gt; uint) balance;
    function transfer(address to, uint256 amount) public {
        if (amount &amp;gt; balance[msg.sender])
            // Error call using named parameters. Equivalent to
            // revert InsufficientBalance(balance[msg.sender], amount);
            revert InsufficientBalance({
                available: balance[msg.sender],
                required: amount
            });
        balance[msg.sender] -= amount;
        balance[to] += amount;
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면 커스텀 에러를 아래와 같이 선언하고,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error InsufficientBalance(uint256 available, uint256 required);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;revert InsufficientBalance({
    available: balance[msg.sender],
    required: amount
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용 시점의 에러 데이터는 abi.encodeWithSignature(“InsufficientBalance(uint256,uint256)”, balance[msg.sender], amount)로 ABI 인코딩된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;실제로-얼마나-스마트-컨트랙트-사이즈가-줄어드는가&quot;&gt;실제로 얼마나 스마트 컨트랙트 사이즈가 줄어드는가?&lt;/h2&gt;

&lt;p&gt;위에서 예시로 든 VendingMachine 스마트 컨트랙트 기준으로 커스텀 에러 사용 여부에 따른 사이즈를 비교해보았다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized(); // Custom error

contract VendingMachine {
    address payable owner = payable(msg.sender);

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();  // 커스텀 에러 사용 시
            revert(&quot;Insufficient funds.&quot;); // 커스텀 에러 미사용 시

        owner.transfer(address(this).balance);
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/IoBuilders/truffle-contract-size&quot;&gt;truffle-contract-size&lt;/a&gt;를 사용하여 각 상황별로 스마트 컨트랙트 사이즈를 계산한 결과는 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;커스텀 에러 사용 : 0.33 KiB&lt;/li&gt;
  &lt;li&gt;커스텀 에러 미사용 : 0.46 KiB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단순한 에러라 할지라도 대략 0.13 KiB 정도의 차이가 나는 것을 보면, 복잡한 로직이 들어간 스마트 컨트랙트 일수록 커스텀 에러의 적용이 꽤 유의미한 가치를 가져올 수 있을 것이라고 생각된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;좀더-깊이-커스텀-에러-들여다보기&quot;&gt;좀더 깊이 커스텀 에러 들여다보기&lt;/h2&gt;

&lt;p&gt;파라미터를 포함하지 않는 기본적인 커스텀 에러 ‘revert Unauthorized()’를 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/yul.html&quot;&gt;Yul 코드&lt;/a&gt;로 확인해보면 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Yul 코드는 다양한 백엔드에서 바이트코트 형태로 컴파일될 수 있도록 하는 중간 언어(intermediate language)를 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# revert Unauthorized();
let free_mem_ptr := mload(64)
mstore(free_mem_ptr, 0x82b4290000000000000000000000000000000000000000000000000000000000)
revert(free_mem_ptr, 4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 0x82b42900은 Unauthourized() 커스텀 에러의 selector를 의미한다. 그렇다면 커스텀 에러를 사용하지 않고 revert(“Unauthorized”)와 같이 에러 메시지를 그대로 사용하면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# revert(&quot;Unauthorized&quot;);
let free_mem_ptr := mload(64)
mstore(free_mem_ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
mstore(add(free_mem_ptr, 4), 32)
mstore(add(free_mem_ptr, 36), 12)
mstore(add(free_mem_ptr, 68), &quot;Unauthorized&quot;)
revert(free_mem_ptr, 100)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;0x08c379a0 값은 Error(에러메시지 문자열)의 selector를 의미한다. 단순히 코드만 봐도 커스텀 에러를 사용할 때가 더 적은 가스비를 소모하는 것을 볼 수 있다. 런타임 시점의 가스비는 revert 조건을 만족하는 경우에 대해서만 연관이 있다는 것을 기억하자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커스텀-에러-확인하기&quot;&gt;커스텀 에러 확인하기&lt;/h2&gt;

&lt;p&gt;그렇다면 커스텀 에러는 어떻게 확인할 수 있을까? 가장 최근 버전의 ethers.js를 사용하면 커스텀 에러 메시지를 디코딩한 값을 확인할 수 있다.&lt;br /&gt;
아래 예시는 위의 InsufficientBalance 커스텀 에러를 확인하는 경우를 나타낸다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { ethers } from &apos;ethers&apos;

// As a workaround, we have a function with the
// same name and parameters as the error in the abi.
const abi = [
  &apos;function InsufficientBalance(uint256 available, uint256 required)&apos;,
]

const interface = new ethers.utils.Interface(abi)
const error_data =
  &apos;0xcf479181000000000000000000000000000000000000&apos; +
  &apos;0000000000000000000000000100000000000000000000&apos; +
  &apos;0000000000000000000000000000000000000100000000&apos;

const decoded = interface.decodeFunctionData(
  interface.functions[&apos;InsufficientBalance(uint256,uint256)&apos;],
  error_data
)
// Contents of decoded:
// [
//   BigNumber { _hex: &apos;0x0100&apos;, _isBigNumber: true },
//   BigNumber { _hex: &apos;0x0100000000&apos;, _isBigNumber: true },
//   available: BigNumber { _hex: &apos;0x0100&apos;, _isBigNumber: true },
//   required: BigNumber { _hex: &apos;0x0100000000&apos;, _isBigNumber: true }
// ]
console.log(
  &apos;Insufficient balance for transfer. &apos; +
    `Needed ${decoded.required.toString()} but only ` +
    `${decoded.available.toString()} available.`
)
// Insufficient balance for transfer. Needed 4294967296 but only 256 available.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;주의점&quot;&gt;주의점&lt;/h2&gt;

&lt;p&gt;스마트 컨트랙트를 컴파일해서 ABI 형태의 JSON 파일로 만드는 과정에서, 컴파일러는 해당 스마트 컨트랙트가 나타낼 수 있는(emit) 모든 에러를 해당 파일에 포함시킨다. 여기서 중요한 것은 이 과정에 &lt;u&gt;external call로 호출되는 에러 메시지들은 포함되지 않는다&lt;/u&gt;는 것이다. 
이러한 이유로 개발자들은 에러 마다 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/natspec-format.html?color=dark&quot;&gt;NatSpec&lt;/a&gt; 형식을 준수하는 설명을 달아놓기도 한다. NatSpec은 개발자와 사용자가 추가 비용없이 에러 메시지에 대해 서로 이해할 수 있도록 하는 좋은 방법 중 하나이다.&lt;/p&gt;

&lt;p&gt;어쨋든 에러 메시지의 출처를 추적할 수 없기 때문에, 에러 데이터는 신중하게 사용해야 한다. external call 호출 횟수가 계속 늘어날수록, 발생하는 에러 메시지가 어디서부터 온 것인지 추적하기 점점 어려워진다는 것을 의미한다. 게다가 실제 에러가 아님에도 불구하고 에러메시지(처럼 보이는 문구)를 호출하도록 악의적으로 스마트 컨트랙트를 작성할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://soliditylang.org/blog/2021/04/21/custom-errors/&quot;&gt;Custom Errors in Solidity - Soliditylang.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wonjoon</name></author><summary type="html"></summary></entry><entry><title type="html">스마트 컨트랙트의 사이즈를 줄이는 방법</title><link href="http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size/" rel="alternate" type="text/html" title="스마트 컨트랙트의 사이즈를 줄이는 방법" /><published>2023-08-21T00:00:00+09:00</published><updated>2023-08-21T00:00:00+09:00</updated><id>http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size</id><content type="html" xml:base="http://localhost:4000/2023/08/21/blockchain-downsizing-contract-size/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;eip-170&quot;&gt;EIP-170&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-170&quot;&gt;EIP-170&lt;/a&gt;은 2016년 11월 22일에 발생한 하드포크 &lt;a href=&quot;https://blog.ethereum.org/2016/11/18/hard-fork-no-4-spurious-dragon&quot;&gt;‘Suprious Dragon’&lt;/a&gt; 시기에 공개되었으며, DoS(Denial of Service) 공격으로부터 이더리움 네트워크를 보호하기 위해 스마트 컨트랙트의 사이즈를 24,576kb로 제한하는 규칙을 제안한 내용이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If block.number &amp;gt;= FORK_BLKNUM, then if contract creation initialization returns data with length of more than MAX_CODE_SIZE bytes, contract creation fails with an out of gas error.

- MAX_CODE_SIZE: 0x6000 (2**14 + 2**13)
- FORK_BLKNUM: 2,675,000
- CHAIN_ID: 1 (Mainnet)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이더리움 네트워크에서는 잠재적으로 최소 2번의 O(n) 만큼 가스가 사용될 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;디스크에서 읽어온 스마트 컨트랙트에 대한 코드를 VM 환경에서 실행하기 위해 전처리하는 과정에서 O(n)&lt;/li&gt;
  &lt;li&gt;블록의 유효성 증명을 위해 데이터를 머클 증명에 추가하는 과정의 O(n)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이를 이더리움에서는 2차 취약점(Quadratic Vulnerability) 이라고 언급하는데, 결국 스마트 컨트랙트 자체의 크기로 인하여 트랜잭션 처리 성능에 영향을 주는 경우가 발생하게 된다.&lt;br /&gt;
그리고 꼭 DoS가 아니더라도 굉장히 간단한 기능만을 사용하려는 사용자의 경우 단순히 &lt;u&gt;스마트 컨트랙트가 길다&lt;/u&gt;는 이유만으로 많은 가스비와 시간을 소비해야 할 수도 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스마트-컨트랙트의-사이즈를-확인하는-방법&quot;&gt;스마트 컨트랙트의 사이즈를 확인하는 방법&lt;/h2&gt;

&lt;p&gt;스마트 컨트랙트 바이트코드의 크기를 확인하려면 &lt;a href=&quot;https://github.com/IoBuilders/truffle-contract-size&quot;&gt;truffle-contract-size&lt;/a&gt;를 사용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;단계별로-스마트-컨트랙트의-사이즈를-줄이는-방법&quot;&gt;단계별로 스마트 컨트랙트의 사이즈를 줄이는 방법&lt;/h2&gt;

&lt;p&gt;본문에서는 3단계로 스마트 컨트랙트의 사이즈를 줄이는 방법을 제시한다.&lt;br /&gt;
1단계가 가장 큰 효과를 줄 수 있는(Big impact) 방법이고, 단계가 올라갈수록 소소하게 효과를 줄 수 있는 방법으로 보면 된다.&lt;/p&gt;

&lt;h3 id=&quot;1-big-impact&quot;&gt;1. Big impact&lt;/h3&gt;

&lt;h4 id=&quot;11-스마트-컨트랙트-분리하기&quot;&gt;1.1. 스마트 컨트랙트 분리하기&lt;/h4&gt;

&lt;p&gt;스마트 컨트랙트 분리의 첫걸음은 좋은 구조(Good Architecture)로부터 시작한다. 스마트 컨트랙트가 작아질수록 가독성은 높아진다.&lt;/p&gt;

&lt;p&gt;스마트 컨트랙트 분리 시 생각해보아야 하는 점들은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함께 동작하는 기능들은 모아두는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;상태(state)값을 확인 또는 변경하지 않는 기능은 분리해도 좋다.&lt;/li&gt;
  &lt;li&gt;스토리지(storage)에 접근하지 않는다면 분리해도 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;12-라이브러리-사용하기&quot;&gt;1.2. 라이브러리 사용하기&lt;/h4&gt;

&lt;p&gt;라이브러리를 사용하면 효율적으로 특정 기능들을 별도의 스마트 컨트랙트로 분리할 수 있다. 라이브러리는 다른 스마트 컨트랙트에서 컴파일 과정에 추가되어 사용되기 때문에 internal로 선언되어서는 안된다.&lt;br /&gt;
라이브러리를 사용할 때에는 &lt;a href=&quot;https://solidity.readthedocs.io/en/v0.6.10/contracts.html#using-for&quot;&gt;using for&lt;/a&gt;을 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity &amp;gt;=0.6.0 &amp;lt;0.7.0;

struct Data { mapping(uint =&amp;gt; bool) flags; }

library Set {
    function insert(Data storage self, uint value)
        public
        returns (bool)
    {
        if (self.flags[value])
            return false; // already there
        self.flags[value] = true;
        return true;
    }
    ...
}

contract C {
    using Set for Data; // this is the crucial change
    Data knownValues;

    function register(uint value) public {
        require(knownValues.insert(value));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약 public 함수로 외부에서 직접 사용할 수 있도록 선언하고자 한다면, 별도의 스마트 컨트랙트로 배포하는 것이 옳다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;13-프록시-적용하기&quot;&gt;1.3. 프록시 적용하기&lt;/h4&gt;

&lt;p&gt;본문에서는 프록시를 가장 진보한(advanced) 방법이라고 표현하는데, 다른 스마트 컨트랙트의 기능을 통해 본래 스마트 컨트랙트의 상태를 변경하는 delegatecall 호출 방식을 사용한다.&lt;br /&gt;
프록시 방법의 대표적인 예가 &lt;a href=&quot;https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2&quot;&gt;upgradable한 스마트 컨트랙트&lt;/a&gt;인데, 단점은 그만큼 코드가 복잡해진다는 것이다.&lt;br /&gt;
만약 단순히 스마트 컨트랙트의 사이즈만 줄이기 위해서는 사용을 권장하지 않는다고 한다.&lt;/p&gt;

&lt;h3 id=&quot;2-medium-impact&quot;&gt;2. Medium impact&lt;/h3&gt;

&lt;h4 id=&quot;21-함수-개수-줄이기&quot;&gt;2.1. 함수 개수 줄이기&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;External : 편리한 사용성을 위해 우리는 view 함수를 자주 작성하곤 한다. 스마트 컨트랙트 제한 크기 이하라면 전혀 상관이 없다만, 아니라면 가장 필요로하는 한개만 남긴다는 생각으로 함수를 줄이는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;Internal : 단발성으로 호출되는 internal 또는 private 함수를 줄이고, 이를 사용하는 함수 내부에 인라인 코드로 작성하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;22-새로운-변수-선언-줄이기&quot;&gt;2.2. 새로운 변수 선언 줄이기&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Before
function get(uint id) returns (address,address) {
    MyStruct memory myStruct = myStructs[id];
    return (myStruct.addr1, myStruct.addr2);
}

# After
function get(uint id) returns (address,address) {
    return (myStructs[id].addr1, myStructs[id].addr2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;별도의 변수를 선언하지 않았을 때, 무려(?) 0.28kb의 크기를 감소시킬 수 있다. 꼭 별도로 선언해야 하는 변수가 아니라면, 선언되어 있는 변수를 재활용하자.&lt;/p&gt;

&lt;h4 id=&quot;23-짧은-에러메시지&quot;&gt;2.3. 짧은 에러메시지&lt;/h4&gt;

&lt;p&gt;에러메시지의 길이 또한 스마트 컨트랙트의 크기를 변화시키는 요인이 된다. 에러 상황을 나타낼 때 메시지 보다는 코드를 사용할 것을 권장한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Before
require(msg.sender == owner, &quot;Only the owner of this contract can call this function&quot;);

# After
require(msg.sender == owner, &quot;OW1&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;24-커스텀-에러-사용하기&quot;&gt;2.4. 커스텀 에러 사용하기&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://soliditylang.org/blog/2021/04/21/custom-errors/&quot;&gt;솔리디티 0.8.4에서 소개된 커스텀 에러 방식&lt;/a&gt;은 스마트 컨트랙트의 사이즈를 줄일 수 있는 꽤나 효과적인 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error Unauthorized();

if (msg.sender != owner) {
    revert Unauthorized();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 방식이 커스텀 에러인데, 이처럼 선언하게 되면 해당 에러가 selector 형식으로 ABI 인코딩된다. 커스텀 에러 안에서도 다양한 방식이 있는데, 추후 포스팅하겠다.&lt;/p&gt;

&lt;h4 id=&quot;25-optimizer-수정하기&quot;&gt;2.5. Optimizer 수정하기&lt;/h4&gt;

&lt;p&gt;기본값 200은 것은 함수가 200번 호출될 경우를 대비한 바이트코드의 최적화를 의미한다. 만약 값을 1로 한다면 단일 호출인 경우에 대한 바이트코드 최적화를 의미하게 되는데, 다른 의미로 배포(deployment)를 나타내게 된다.&lt;br /&gt;
Optimizer에 사용되는 값이 증가할수록 가스비가 증가하므로, 배포된 이후 해당 컨트랙트를 직접 호출하는 경우가 없다면 값을 최소화하여 적용하는 방안을 고려하는 것을 권장한다.&lt;/p&gt;

&lt;h3 id=&quot;3-small-impact&quot;&gt;3. Small impact&lt;/h3&gt;

&lt;h4 id=&quot;31-함수-파라미터로-구조체-전달하지-않기&quot;&gt;3.1. 함수 파라미터로 구조체 전달하지 않기&lt;/h4&gt;

&lt;p&gt;ABIEncoderV2에서는 함수의 파라미터로 구조체를 전달할 수 있다. 편의성은 올라갈 수 있지만 스마트 컨트랙트의 사이즈는 증가한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Passing struct
function get(uint id) returns (address,address) {
    return _get(myStruct);
}

function _get(MyStruct memory myStruct) private view returns(address,address) {
    return (myStruct.addr1, myStruct.addr2);
}

# Passing variables
function get(uint id) returns(address,address) {
    return _get(myStructs[id].addr1, myStructs[id].addr2);
}

function _get(address addr1, address addr2) private view returns(address,address) {
    return (addr1, addr2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;구조체가 아닌 파라미터를 전달할 경우, 0.1kb의 크기가 차이난다.&lt;/p&gt;

&lt;h4 id=&quot;32-기능에-맞는-visibility-적용하기&quot;&gt;3.2. 기능에 맞는 visibility 적용하기&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;함수가 무조건 외부에서만 호출되는 경우 : public&lt;/li&gt;
  &lt;li&gt;함수가 다른 스마트 컨트랙트를 통해서만 호출되는 경우 : private 또는 internal&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;33-modifier-삭제하기&quot;&gt;3.3. Modifier 삭제하기&lt;/h4&gt;

&lt;p&gt;Modifier는 스마트 컨트랙트 사이즈에 큰 영향을 준다. 차라리 함수를 사용할 것을 권장한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Use modifier
modifier checkStuff() {}
function doSomething() checkStuff {}

# Use only functions
function checkStuff() private {}
function doSomething() { checkStuff(); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ethereum.org/en/developers/tutorials/downsizing-contracts-to-fight-the-contract-size-limit/&quot;&gt;DOWNSIZING CONTRACTS TO FIGHT THE CONTRACT SIZE LIMIT - ethereum.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>wonjoon</name></author><summary type="html"></summary></entry></feed>