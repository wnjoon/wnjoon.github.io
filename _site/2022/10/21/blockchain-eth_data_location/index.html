<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Storage, Memory, Calldata의 차이</title><!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Storage, Memory, Calldata의 차이" />
<meta name="author" content="Wonjoon" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduce differences between Storage, Memory and Calldata in Solidity." />
<meta property="og:description" content="Introduce differences between Storage, Memory and Calldata in Solidity." />
<link rel="canonical" href="http://localhost:4000/2022/10/21/blockchain-eth_data_location/" />
<meta property="og:url" content="http://localhost:4000/2022/10/21/blockchain-eth_data_location/" />
<meta property="og:site_name" content="월리의 탐구생활" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-10-21T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Storage, Memory, Calldata의 차이" />
<script type="application/ld+json">
{"headline":"Storage, Memory, Calldata의 차이","dateModified":"2022-10-21T00:00:00+09:00","datePublished":"2022-10-21T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2022/10/21/blockchain-eth_data_location/"},"url":"http://localhost:4000/2022/10/21/blockchain-eth_data_location/","author":{"@type":"Person","name":"Wonjoon"},"@type":"BlogPosting","description":"Introduce differences between Storage, Memory and Calldata in Solidity.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="월리의 탐구생활" /><link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="light">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/"><-home</a><article>
  <p class="post-meta">
    <time datetime="2022-10-21 00:00:00 +0900">2022-10-21</time>
  </p>
  
  <h1>Storage, Memory, Calldata의 차이</h1>

  <p><br /></p>

<h2 id="레퍼런스reference-타입-변수">레퍼런스(Reference) 타입 변수</h2>

<p>다이나믹(Dynamic) 타입이라고도 불리며, 아래와 같은 종류가 있다.</p>

<ul>
  <li>Array (솔리디티에서는 bytes, string 타입을 special array로 취급한다)</li>
  <li>Struct</li>
  <li>Mapping</li>
</ul>

<p>레퍼런스 타입은 해당 변수가 저장될 위치(location)를 명시하지 않으면 컴파일 과정에서 에러를 발생시킨다.</p>

<ul>
  <li>Storage
    <ul>
      <li>모든 상태 변수를 저장한다. 즉, 블록체인에 저장되는 데이터는 모두 Storage에 저장된다.</li>
    </ul>
  </li>
  <li>Memory
    <ul>
      <li>함수 호출(External) 과정에 휘발성으로 존재하는 데이터를 잠시 저장하는 곳이다.</li>
      <li>수정이 가능하다.</li>
    </ul>
  </li>
  <li>Calldata
    <ul>
      <li>함수 호출 시 파라미터에 포함되는 데이터를 잠시 저장하는 곳이다.</li>
      <li>수정이 불가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="예시">예시</h2>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">contract</span> <span class="n">sample</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="n">b</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>        
        <span class="kt">string</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="n">MyStruct</span><span class="p">)</span> <span class="k">public</span> <span class="n">myStructList</span><span class="p">;</span>

    
    <span class="k">function</span> <span class="n">setVariable</span><span class="p">(</span><span class="kt">address</span> <span class="n">_address</span><span class="p">,</span> <span class="kt">string</span> <span class="k">calldata</span> <span class="n">_val</span><span class="p">)</span> <span class="k">external</span> <span class="p">{</span> <span class="c1">// (1)
</span>        <span class="n">MyStruct</span> <span class="k">storage</span> <span class="n">ms</span> <span class="o">=</span> <span class="n">myStructList</span><span class="p">[</span><span class="n">_address</span><span class="p">];</span> <span class="c1">// (2) 
</span>        <span class="n">ms</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">_val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">getVariable</span><span class="p">(</span><span class="kt">address</span> <span class="n">_address</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">string</span> <span class="k">memory</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// (3)
</span>        <span class="k">return</span> <span class="n">myStructList</span><span class="p">[</span><span class="n">_address</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>(1)
    <ul>
      <li>파라미터로 전달된 _val 값을 그대로 받아서 변경 없이 새롭게 만들어진 MyStruct에 넣는다. 그렇기 때문에 수정이 불가능한 calldata 키워드를 사용한다.</li>
    </ul>
  </li>
  <li>(2)
    <ul>
      <li>myStructList 상태 변수를 변경하기 위해 storage 키워드 사용한다.</li>
      <li>memory 키워드를 사용하게 되면 myStructList 데이터를 복사해서 사용하기 때문에, 실제 myStructList 내부의 값은 절대 변하지 않는다.</li>
    </ul>
  </li>
  <li>(3)
    <ul>
      <li>값의 return에 memory 키워드를 사용한다.</li>
      <li>myStructList 내부 값을 변경하는 것이 아니기 때문에, 상태 변수에 변화를 주지 않는 memory 키워드를 사용하면 된다.</li>
      <li><u>상태 변수에 변화를 주지 않는다면, calldata를 사용해도 무방하지 않을까?</u></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="memory와-calldata의-차이">memory와 calldata의 차이</h2>

<h3 id="1-데이터의-복사-여부">1. 데이터의 복사 여부</h3>

<p>위에서 memory 수정이 가능하지만, calldata는 수정이 불가능하다고 했다.</p>

<p>아래는 솔리디티에서 변수에 memory 키워드를 사용할 경우의 단계별 동작이다.</p>

<ol>
  <li>calldata 형태로 데이터를 가지고 온다.</li>
  <li>새로운 memory에 데이터를 복사한다.</li>
  <li>memory 형태의 데이터를 전달한다.</li>
</ol>

<p>솔리디티에서 함수를 통해 전달되는 모든 파라미터는 트랜잭션 내 Data field에 들어간다. 여기에는 함수 호출에 필요한 데이터(function identifier, argument 등)가 들어가기 때문에 input data라고도 불리고 간혹 calldata 라고 부르기도 한다.</p>

<p>그러므로 calldata는 Data field의 input data(함수 호출에 사용된 데이터)를 그대로 사용하겠다는 말이고, memory 키워드는 Data field를 통해 가져온 데이터에 대한 복사본을 만들고 이를 사용하는 방식이다.</p>

<p>복사본을 사용할 경우 가스비가 증가하게 된다. 그러므로 데이터의 변경이 없을 것 같은 경우에는 calldata 키워드를 사용하는것이 무분별한 memory 키워드 사용보다는 더 좋을 것이다.</p>

<p><br /></p>

<h3 id="2-return-파라미터에서의-사용">2. Return 파라미터에서의 사용</h3>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mapping</span><span class="p">(</span><span class="kt">uint256</span> <span class="o">=&gt;</span> <span class="n">Order</span><span class="p">)</span> <span class="n">_orders</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">function</span> <span class="n">getOrder</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">id</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Order</span> <span class="k">calldata</span><span class="p">)</span> <span class="cm">/* &lt;- Return에 calldata 사용 */</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">_orders</span><span class="p">[</span><span class="n">id</span><span class="p">];</span> <span class="cm">/* &lt;- 오류 발생 */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>동일하게 상태를 변화시키지 않는데도 calldata를 return에 사용하면 오류가 발생한다. 이에 대한 답변으로 <a href="https://ethereum.stackexchange.com/questions/117770/how-to-use-calldata-return-values-in-solidity-and-when-are-they-useful">StackExchange</a>에서는 아래와 같이 말하고 있다.</p>

<blockquote>
  <p>Return argument type struct MatchingEngine.Order storage ref is not implicitly convertible to expected type (type of first return variable) struct MatchingEngine.Order calldata.</p>
</blockquote>

<p>확인 결과(), calldata는 input 파라미터로만 적용 가능하며 return 값에서는 사용이 불가능하다. 그러므로 Return 값에서는 memory를 사용하자.</p>

<p><br /></p>

<h2 id="요약">요약</h2>

<p>포스팅을 다시 요약해보면,</p>
<ul>
  <li>레퍼런스 타입 변수는 선언 시 데이터 위치(storage, memory, calldata)를 꼭 명시해야 한다.</li>
  <li>상태 변수의 변경이 블록체인에 저장되어야 한다면 storage 키워드를 사용한다.</li>
  <li>블록체인으로의 상태 변수 업데이트가 필요 없다면 memory, calldata를 사용한다. 단 변수 값의 수정이 이루어지지 않는 단순 읽기만 요구된다면, 가스비 절약을 위해서라도 calldata를 사용하는 것이 더 바람직하다.</li>
  <li>(추가) calldata는 함수의 리턴값에서는 사용할 수 없다. 오직 인풋 파라미터에서만 사용가능하다.</li>
</ul>

<p><br /></p>

<h2 id="참고자료">참고자료</h2>

<ul>
  <li><a href="https://solidity-by-example.org/data-locations/">Data Locations - Storage, Memory and Calldata</a></li>
  <li><a href="https://medium.com/@aiden.p/solidity-%EC%94%A8-%EB%A6%AC%EC%A6%88-%EC%9D%80%EA%B7%BC-%ED%97%B7%EA%B0%88%EB%A6%AC%EB%8A%94-data-location-2690cefb72db">은근 헷갈리는 Data Location - Solidity 씨-리즈</a></li>
  <li><a href="https://medium.com/coinmonks/solidity-storage-vs-memory-vs-calldata-8c7e8c38bce">Storage vs Memory vs Calldata - YBM</a></li>
  <li><a href="https://ethereum.stackexchange.com/questions/117770/how-to-use-calldata-return-values-in-solidity-and-when-are-they-useful">How to use calldata return values in Solidity and when are they useful? - StackExchange</a></li>
</ul>

</article>
      </div>
    </main>
  </body>
</html>